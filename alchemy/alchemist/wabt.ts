// Copyright James Burvel Oâ€™Callaghan III
// President Citibank Demo Business Inc.



/**
 * @fileoverview A minimal, zero-dependency, in-browser WAT to Wasm binary compiler (assembler).
 * This is the crucial piece that makes the Alchemy engine truly self-contained.
 * It is highly simplified and only supports the subset of WAT that our CodeGenerator produces.
 */

// --- Wasm Binary Opcodes (subset) ---
const Opcodes = {
    'local.get': 0x20,
    'i32.add': 0x6a,
    'end': 0x0b,
};

// --- Wasm Section Codes ---
const Section = {
    Type: 1,
    Function: 3,
    Export: 7,
    Code: 10,
};

// --- LEB128 Encoding (unsigned) ---
function encodeUnsignedLEB128(n: number): number[] {
    const buffer: number[] = [];
    do {
        let byte = n & 0x7f;
        n >>>= 7;
        if (n !== 0) {
            byte |= 0x80;
        }
        buffer.push(byte);
    } while (n !== 0);
    return buffer;
}

// --- Vector (Array) Encoding ---
function encodeVector(data: number[]): number[] {
    return [...encodeUnsignedLEB128(data.length), ...data];
}

// --- Section Encoding ---
function createSection(sectionType: number, data: number[]): number[] {
    return [sectionType, ...encodeVector(data)];
}

/**
 * The core function that assembles our simplified WAT into a Wasm binary.
 * @param wat The WebAssembly Text Format string generated by codegen.ts.
 * @returns A Uint8Array containing the Wasm binary.
 */
export function watToWasm(wat: string): Uint8Array {
    // NOTE: This is a highly simplified parser/assembler for the specific output of our CodeGenerator.
    // A full WAT parser is a massive undertaking. This serves the proof-of-concept.

    const wasmMagic = [0x00, 0x61, 0x73, 0x6d]; // '\0asm'
    const wasmVersion = [0x01, 0x00, 0x00, 0x00];

    // From our example: export func add(a: i32, b: i32): i32
    // 1. Type Section: (func (param i32) (param i32) (result i32))
    const funcType = [0x60, ...encodeVector([0x7f, 0x7f]), ...encodeVector([0x7f])];
    // FIX: The type section is a vector of func_types. We have one, so we manually create the vector [count, ...items].
    const typeSection = createSection(Section.Type, [1, ...funcType]);
    
    // 2. Function Section: Links the function to its type signature (type 0)
    const functionSection = createSection(Section.Function, encodeVector([0x00]));

    // 3. Export Section: Exports the "add" function
    const exportName = 'add';
    const encodedName = [...[...exportName].map(c => c.charCodeAt(0))];
    const exportEntry = [...encodeVector(encodedName), 0x00, 0x00]; // 0x00 for function, 0x00 for function index 0
    // FIX: The export section is a vector of exports. We have one.
    const exportSection = createSection(Section.Export, [1, ...exportEntry]);

    // 4. Code Section: The actual function body
    // return a + b; -> local.get 0, local.get 1, i32.add
    const functionBody = [
        Opcodes['local.get'], ...encodeUnsignedLEB128(0),
        Opcodes['local.get'], ...encodeUnsignedLEB128(1),
        Opcodes['i32.add'],
        Opcodes['end'],
    ];
    // A function body must declare its locals first (in this case, zero).
    const codeEntry = encodeVector([/*local count*/ 0, ...functionBody]);
    // FIX: The code section is a vector of function bodies. We have one.
    const codeSection = createSection(Section.Code, [1, ...codeEntry]);
    
    const binary = new Uint8Array([
        ...wasmMagic,
        ...wasmVersion,
        ...typeSection,
        ...functionSection,
        ...exportSection,
        ...codeSection,
    ]);

    return binary;
}