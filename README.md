
## `AISuggestionsCard.tsx.txt`
**Path:** 
```
import React, { useRef, useState, useEffect } from "react";
import useMeasure from "react-use-measure";
import ReactTooltip from "react-tooltip";
import TruncateString from "react-truncate-string";
import { v4 as uuidv4 } from "uuid";
import { useSpring, animated } from "react-spring";
import { createPortal } from "react-dom";
import { cn } from "~/common/utilities/cn";
import { getDrawerContent } from "~/common/utilities/getDrawerContent";
import {
  ButtonProps,
  Drawer,
  Icon,
  IconProps,
  LoadingDots,
  Tag,
  TagProps,
} from "~/common/ui-components";

export interface AITagProps
  extends Omit<TagProps, "size">,
    Omit<TagProps, "color"> {
  /** Sets the message of the tooltip. */
  fieldName?: string;
  /** Sets the string inside the tag. */
  message: string;
  /** Sets the styling inside the chip. */
  state: "match" | "partial_match" | "no_match";
  /** Sets the key for the tag. */
  tagKey?: React.Key;
}

/** Shows a property that is either an AI match, a partial match, or a no-match.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-ui-ai-
 suggestions-aitag--docs)
 */
export function AITag({
  buttonProps,
  className,
  fieldName,
  message,
  state,
  tagKey,
}: AITagProps) {
  const uuid = uuidv4();
  const textElementRef = useRef<HTMLInputElement | null>(null);
  const [isOverflow, setIsOverflow] = useState(false);
  useEffect(() => {
    const checkOverflow = () => {
      if (textElementRef?.current) {
        // 140 is roughly the max width of the text contents of a tag
        const overflow = textElementRef.current.scrollWidth > 140;
        setIsOverflow(overflow);
      }
    };

    checkOverflow();
    window.addEventListener("resize", checkOverflow);
    return () => {
      window.removeEventListener("resize", checkOverflow);
    };
  }, []);

  let iconName: IconProps["iconName"];

  switch (state) {
    case "match":
      iconName = "checkmark_circle";
      break;
    case "partial_match":
      iconName = "time_30_s";
      break;
    case "no_match":
      iconName = "clear_circle_outlined";
      break;
    default:
      iconName = "clear_circle_outlined";
      break;
  }

  return (
    <Tag
      buttonProps={buttonProps}
      className={cn("group/item max-h-5 max-w-fit", className)}
      color={state === "match" ? "purple" : "gray"}
      data-tip={fieldName}
      data-tooltip-id={uuid}
      icon={{ iconName, size: "s" }}
      key={tagKey}
      size="small"
    >
      <span
        data-tip={`${message}`}
        data-for={uuid}
        className="w-full flex-1"
        ref={textElementRef}
      >
        <TruncateString text={message} />
      </span>
      {isOverflow && (
        <>
          {createPortal(
            <ReactTooltip
              id={uuid}
              className="break-word max-w-md"
              data-place="top"
              data-effect="float"
              multiline
            />,
            document.body,
          )}
        </>
      )}
    </Tag>
  );
}
AITag.displayName = "AITag";

const ANIMATION_CLASSES = "transition-color ease-in-out";
const ANIMATION_CLASSES_WITH_DURATION =
  "transition-color duration-300 ease-in-out";
const ANIMATION_DELAYS = [
  "[animation-delay:_0s]",
  "[animation-delay:_0.05s]",
  "[animation-delay:_0.1s]",
  "[animation-delay:_0.15s]",
  "[animation-delay:_0.2s]",
  "[animation-delay:_0.25s]",
  "[animation-delay:_0.3s]",
  "[animation-delay:_0.35s]",
  "[animation-delay:_0.4s]",
  "[animation-delay:_0.45s]",
];

export interface AISuggestionProps extends UIContainerProps {
  /** Id of the associated entity. Needed to get the drawer content. */
  id?: string;
  /** Sets the styling inside the chip. */
  matches: AITagProps[];
  /** Sets the onClick action for the "Reconcile" button. */
  onClick?: ButtonProps["onClick"];
  /** Sets the path of the drawer. */
  path?: string;
  /** Sets the key for the suggestion. */
  suggestionKey?: React.Key;
  /** Sets the typename needed to get the Drawer content. */
  typename?: string;
}

/** Displays a series of properties that make up an AI suggestion.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-ui-ai-
 suggestions-aisuggestion--docs)
 */
export function AISuggestion({
  id,
  matches,
  onClick,
  path,
  suggestionKey,
  typename,
}: AISuggestionProps) {
  const suggestionRow = (
    <div
      className={cn(
        "group/suggestion relative flex w-full cursor-pointer items-center
        justify-between gap-2 rounded bg-alpha-black-50 pl-4 hover:bg-alpha-
        black-100",
        ANIMATION_CLASSES_WITH_DURATION,
      )}
      key={suggestionKey}
    >
      <div className="flex items-center gap-2">
        {matches.map((match, index) => (
          <AITag
            {...match}
            key={index}
            tagKey={index}
            className={cn("animate-fadeIn opacity-0", ANIMATION_DELAYS[index])}
          />
        ))}
      </div>
      <div className="invisible sticky right-0 flex h-full items-center gap-2
      bg-gradient-to-r from-transparent from-10% via-20% to-purple-100 to-40%
      px-4 py-2 ps-20 group-hover/suggestion:visible">
        {onClick && (
          <button
            className={cn(
              "reconcile-button rounded-sm px-2 py-1 text-sm font-medium
              hover:bg-white",
              ANIMATION_CLASSES,
            )}
            type="button"
            onClick={(e) => {
              if (
                (e.target as HTMLDivElement).classList.contains(
                  "reconcile-button",
                )
              ) {
                e.stopPropagation();
              }
              onClick(e);
            }}
          >
            Reconcile
          </button>
        )}
      </div>
    </div>
  );

  return (
    <Drawer path={path} trigger={suggestionRow}>
      {typename && id && getDrawerContent(typename, id)}
    </Drawer>
  );
}
AISuggestion.displayName = "AISuggestion";

export interface AISuggestionCardProps extends UIContainerProps {
  /** Builds out the row of a suggested entity with sub-items that match
  properties of the item selected by a user. */
  suggestions: AISuggestionProps[];
  /** When `true`, styles a loading state. */
  loading?: boolean;
  /** When `true`, styles an errored state. */
  error?: boolean;
  /** Sets the title of the card. */
  title?: string;
}

/** Shows AI suggestions in a card with a title header.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-ui-ai-
 suggestions-aisuggestioncard--docs)
 */
export function AISuggestionCard({
  error,
  loading,
  suggestions,
  title,
}: AISuggestionCardProps) {
  const [ref, { height }] = useMeasure();
  const animatedProps = useSpring({
    height: height || 0,
  });

  return (
    <animated.div style={{ ...animatedProps }} className="min-w-0">
      <div
        className={cn(
          "relative rounded-lg border-2 border-double border-transparent bg-ai-
          looping-gradient-with-border bg-300% bg-origin-border transition-all
          [background-clip:content-box,_border-box]",
          loading && "animate-backgroundPulse",
        )}
        ref={ref}
      >
        <div
          className={cn(
            "pointer-events-none absolute left-0 top-0 h-full w-full bg-ai-
            looping-gradient bg-300% opacity-25",
            suggestions?.length > 0 ? "py-4" : "py-2",
            loading && "animate-backgroundPulse",
          )}
        />
        <div
          className={cn(
            "flex flex-col gap-4 px-4",
            suggestions?.length > 0 ? "py-4" : "py-2",
          )}
        >
          {loading ? (
            <div className="flex justify-center">
              <div className="flex gap-2 font-medium">
                <Icon iconName="flare" />
                <div className="flex gap-1">
                  Loading
                  <LoadingDots />
                </div>
              </div>
            </div>
          ) : (
            <>
              {!error && title && (
                <div className="flex items-center justify-center gap-2 font-
                medium">
                  <Icon iconName="flare" size="s" />
                  {title}
                </div>
              )}
              {suggestions.length > 0 && !error && (
                <div className="grid gap-2 overflow-x-scroll">
                  {suggestions.map((suggestion, index) => (
                    <AISuggestion
                      {...suggestion}
                      key={index}
                      suggestionKey={index}
                    />
                  ))}
                </div>
              )}
              {error && (
                <div className="text-center font-medium italic">
                  No suggestions found
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </animated.div>
  );
}
AISuggestionCard.displayName = "AISuggestionCard";
```

---
## `APIKeyForm.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { APIKeyRolesForm } from "./APIKeyRolesForm";
import { IPAllowlistForm } from "./IPAllowlistForm";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { Button } from "../../common/ui-components";
import { ApiKeyFormDeprecatedQuery } from
"../../generated/dashboard/graphqlSchema";

function APIKeyForm({
  id,
  internalAccounts,
  ipAllowlist: initialIpAllowlist,
  roles: initialRoles,
  name: initialName,
  onSubmit,
}: {
  id?: string;
  internalAccounts: Pick<
    ApiKeyFormDeprecatedQuery["internalAccountsUnpaginated"][0],
    "id" | "longName"
  >[];
  ipAllowlist?: string[] | null;
  roles?: string[];
  name?: string;
  onSubmit: ({ name, roles, ipAllowlist }) => void;
}) {
  const [ipAllowlist, setIpAllowlist] = useState(initialIpAllowlist || []);
  const [roles, setRoles] = useState(initialRoles || []);
  const [name, setName] = useState(initialName || "");

  const updating = !!id;

  return (
    <div>
      <div className="form-row flex">
        <ReduxInputField
          input={{
            onChange: (e) => setName(e.target.value),
            value: name,
            name: "name",
          }}
          type="text"
          label="Name"
        />
      </div>

      <div className="form-section">
        <IPAllowlistForm
          ipAllowlist={ipAllowlist}
          setIpAllowlist={setIpAllowlist}
          enabled
        />
      </div>
      <div className="form-section">
        <APIKeyRolesForm
          roles={roles}
          setRoles={setRoles}
          internalAccounts={internalAccounts}
          enabled={!updating}
        >
          <div className="header-hint">
            You cannot edit the permissions assigned to a key once it has been
            created.
            {updating && (
              <div>
                If you need different permissions, create a new API key.
              </div>
            )}
          </div>
        </APIKeyRolesForm>
      </div>

      <div className="form-group">
        <Button
          buttonType="primary"
          onClick={() =>
            onSubmit({
              name,
              roles,
              ipAllowlist,
            })
          }
        >
          {updating ? "Update" : "Create"}
        </Button>
      </div>
    </div>
  );
}

export default APIKeyForm;
```

---
## `APIKeyFormV2.tsx.txt`
**Path:** `.`  
```
import { Field, Form, Formik, FormikProps } from "formik";
import React, { useRef } from "react";
import * as Yup from "yup";
import {
  FormikInputField,
  FormikErrorMessage,
  FormikSelectField,
} from "../../common/formik";
import { IPAllowlistForm } from "./IPAllowlistForm";
import { Button, Drawer, Label, Pill } from "../../common/ui-components";
import { PermissionFormValue } from "../containers/user_management/forms/types";
import PermissionsComponent from
"../containers/user_management/forms/Permissions";
import { Permission } from "../../generated/dashboard/graphqlSchema";
import PermissionsTable from "../containers/user_management/PermissionsTable";
import { cn } from "~/common/utilities/cn";
import { getDrawerContent } from "~/common/utilities/getDrawerContent";
import { AUTHORIZATION_RESOURCE_FIELDS_FOR_API } from
"../../generated/dashboard/constants/authorization_mapping";

export interface APIKeyFormValues {
  name: string;
  ipAllowlist: string[];
  permissions: PermissionFormValue[];
  roles: string[];
  roleId: string;
}

interface APIKeyFormProps {
  initialValues: APIKeyFormValues;
  submitMutation: ({ name, roles, ipAllowlist, permissions }) => void;
  displayPermissions?: Permission[];
  id?: string;
  roles: { id: string; name: string }[] | undefined;
  roleV2?: { id: string; name: string; mtManaged: boolean };
}

function APIKeyForm({
  initialValues,
  submitMutation,
  displayPermissions,
  id,
  roles,
  roleV2,
}: APIKeyFormProps) {
  const formikRef = useRef<
    FormikProps<{
      permissions: PermissionFormValue[];
      name?: string;
      ipAllowlist?: string[];
      roles?: string[];
      roleId?: string;
    }>
  >(null);

  const updating = !!id;

  const validate = () =>
    Yup.object({
      name: Yup.string().required("Required"),
      description: Yup.string(),
    });

  const roleOptions = (roles || []).map((role) => ({
    label: role.name,
    value: role.id,
  }));

  return (
    <div className="form-create form-create-wide">
      <Formik
        initialValues={initialValues}
        onSubmit={(values) => submitMutation(values)}
        innerRef={formikRef as React.RefObject<FormikProps<APIKeyFormValues>>}
        validationSchema={validate}
      >
        {({ values, setFieldValue }: FormikProps<APIKeyFormValues>) => (
          <Form>
            <div className="w-full">
              <Label id="name">Name</Label>
              <Field id="name" name="name" component={FormikInputField} />
              <FormikErrorMessage name="name" />
            </div>
            <div className="form-section mt-4">
              <IPAllowlistForm
                ipAllowlist={values.ipAllowlist}
                setIpAllowlist={(data) => {
                  void setFieldValue("ipAllowlist", data);
                }}
                enabled
              />
            </div>
            {updating ? (
              <div>
                <div>
                  You cannot edit the permissions assigned to a key once it has
                  been created.
                  {updating && (
                    <div>
                      If you need different permissions, create a new API key.
                    </div>
                  )}
                </div>
                <h1 className="mb-4 mt-8">Role</h1>
                {roleV2?.mtManaged ? (
                  <Drawer
                    trigger={
                      <div className="mr-1">
                        <Pill className="associated-entity z-10" showTooltip>
                          {roleV2.name}
                        </Pill>
                      </div>
                    }
                    path={`/settings/user_management/roles/${roleV2.id}`}
                  >
                    {getDrawerContent("Role", roleV2.id)}
                  </Drawer>
                ) : (
                  <div className="text-xs text-gray-300">N/A</div>
                )}
                <h1 className="mb-4 mt-8">Permissions</h1>
                <PermissionsTable permissions={displayPermissions || []} />
              </div>
            ) : (
              <>
                <div className="my-5">
                  <Label className="">Role</Label>
                  <Field
                    formikRef={formikRef}
                    id="roleId"
                    options={roleOptions}
                    name="roleId"
                    type="select"
                    placeholder="Select Role"
                    isClearable
                    component={FormikSelectField}
                    onChange={(value: { value: string; label: string }) => {
                      void setFieldValue("permissions", []);
                      if (value) {
                        void setFieldValue("roleId", value.value);
                      } else {
                        void setFieldValue("roleId", null);
                      }
                    }}
                    className={cn(
                      "h-8 w-full rounded-sm border border-border-default px-2
                      py-1 text-sm placeholder-gray-500 outline-none
                      hover:border-gray-300 focus:border-blue-500 disabled:bg-
                      gray-100",
                    )}
                  />
                </div>
                <PermissionsComponent
                  formikRef={formikRef}
                  values={values}
                  disabled={!!values.roleId}
                  authorizationResourceAttributes={
                    AUTHORIZATION_RESOURCE_FIELDS_FOR_API
                  }
                />
              </>
            )}
            <div className="flex flex-row space-x-4 pt-8">
              <Button isSubmit buttonType="primary">
                {updating ? "Update" : "Create"}
              </Button>
            </div>
          </Form>
        )}
      </Formik>
    </div>
  );
}

export default APIKeyForm;
```

---
## `APIKeyRolesForm.tsx.txt`
**Path:** `.`  
```
import React, { Dispatch, ReactNode, SetStateAction } from "react";
import filter from "lodash/filter";
import ReactTooltip from "react-tooltip";
import PermissionSelector from "../containers/roles/PermissionSelector";
import {
  ROLE_DEVELOPER_OPTIONS,
  ROLE_COUNTERPARTY_OPTIONS,
  ROLE_LEDGER_OPTIONS,
  ROLE_EXTERNAL_ACCOUNT_API_OPTIONS,
  ROLE_COMPLIANCE_API_OPTIONS,
} from "../constants/index";

import AccountPermissionsTable from
"../containers/roles/AccountPermissionsTable";
import {
  SafeInternalAccount,
  useActiveComplianceQuery,
} from "../../generated/dashboard/graphqlSchema";

export function APIKeyRolesForm({
  roles,
  setRoles,
  enabled,
  internalAccounts,
  children,
}: {
  roles: string[];
  setRoles?: Dispatch<SetStateAction<string[]>>;
  enabled: boolean;
  internalAccounts: SafeInternalAccount[];
  children?: ReactNode;
}) {
  const counterpartiesRole = roles.find((r) => r.includes("counterparties"));
  const developersRole = roles.find((r) => r.includes("developer"));
  const ledgersRole = roles.find((r) => r.includes("ledgers"));
  const externalAccountsRole = roles.find((r) =>
    r.includes("external_accounts"),
  );
  const complianceRole = roles.find((r) => r.includes("compliance"));

  const { data: activeComplianceData } = useActiveComplianceQuery();
  const activeCompliance = activeComplianceData?.products.totalCount === 1;

  function onRoleSelect(prefix: string, newRole: string) {
    if (!setRoles) {
      return;
    }

    setRoles(() => {
      const filteredRoles = filter(roles, (id) => !id.includes(prefix));
      return [...filteredRoles, newRole];
    });
  }

  function onAccountPermissionSelect(newRole: string) {
    if (!setRoles) {
      return;
    }

    const parts = newRole.split(":");

    let newRoles = [...roles];

    setRoles(() => {
      if (
        ["accounts:none", "accounts:read", "accounts:manage"].includes(newRole)
      ) {
        newRoles = newRoles.filter((role) => !role.startsWith("accounts:"));
      } else if (newRole === "accounts:partial") {
        // clear previous global account permissions, retain any account
        specific roles
        newRoles = newRoles.filter(
          (role) =>
            !(role.startsWith("accounts:") && role.split(":").length === 2),
        );
      } else {
        // remove old account specific permission
        newRoles = newRoles.filter((role) => !role.includes(parts[2]));
      }
      return [...newRoles, newRole];
    });
  }

  return (
    <div className="form-section">
      <h3 className="h3-no-bottom-border">
        <span>Permissions</span>
        {children}
      </h3>
      <ReactTooltip
        multiline
        data-place="top"
        data-type="dark"
        data-effect="float"
      />
      <div className="index-table table-permissions table w-full">
        <div className="table-body">
          <PermissionSelector
            role={counterpartiesRole || "counterparties:none"}
            onRoleSelect={(value: string) =>
              onRoleSelect("counterparties", value)
            }
            options={ROLE_COUNTERPARTY_OPTIONS}
            title="Counterparties"
            tooltipHint="Retrieve counterparties."
            select={{
              placeholder: "Counterparty Permissions",
              name: "counterparties-permission-select",
            }}
            editable={enabled}
          />
          <PermissionSelector
            role={externalAccountsRole || "external_accounts:none"}
            onRoleSelect={(value: string) =>
              onRoleSelect("external_accounts", value)
            }
            options={ROLE_EXTERNAL_ACCOUNT_API_OPTIONS}
            title="External Accounts"
            tooltipHint="Retrieve external accounts."
            select={{
              placeholder: "External Account Permissions",
              name: "external-account-permission-select",
            }}
            editable={enabled}
          />
          <PermissionSelector
            role={developersRole || "developer:none"}
            onRoleSelect={(value: string) => onRoleSelect("developer", value)}
            options={ROLE_DEVELOPER_OPTIONS}
            title="Developer Resources"
            tooltipHint="Retrieve events, view and edit webhook endpoints, and
            create webhook events"
            select={{
              placeholder: "Developer Permissions",
              name: "developer-permission-select",
            }}
            editable={enabled}
          />
          <AccountPermissionsTable
            roles={roles}
            onAccountRoleSelect={onAccountPermissionSelect}
            internalAccounts={internalAccounts}
            canEditGroup={enabled}
          />
          <PermissionSelector
            role={ledgersRole || "ledgers:none"}
            onRoleSelect={(value: string) => onRoleSelect("ledgers", value)}
            options={ROLE_LEDGER_OPTIONS}
            title="Ledgers"
            tooltipHint="View and edit ledgers data."
            select={{
              placeholder: "Ledgers Permissions",
              name: "ledgers-permission-select",
            }}
            editable={enabled}
          />
          {activeCompliance && (
            <PermissionSelector
              role={complianceRole || "compliance:none"}
              onRoleSelect={(value: string) =>
                onRoleSelect("compliance", value)
              }
              options={ROLE_COMPLIANCE_API_OPTIONS}
              title="Compliance Resources"
              tooltipHint="Access Compliance endpoints such as User Onboardings,
              Decisions, and more."
              select={{
                placeholder: "Compliance Permissions",
                name: "compliance-permission-select",
              }}
              editable={enabled}
            />
          )}
        </div>
      </div>
    </div>
  );
}
```

---
## `APIKeySecret.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { cn } from "~/common/utilities/cn";
import {
  ButtonClickEventTypes,
  Clickable,
  CopyableText,
} from "~/common/ui-components";

function APIKeySecret({
  secret,
  onShowApiKeySecret,
  loading,
}: {
  secret: string;
  onShowApiKeySecret: () => void;
  loading: boolean;
}) {
  const [showFullSecret, setShowFullSecret] = useState(false);

  if (!secret) {
    return null;
  }

  const truncatedSecret = `â¢â¢â¢â¢ ${secret.slice(
    secret.length - 4,
    secret.length,
  )}`;

  const keySecret = showFullSecret && !loading ? secret : truncatedSecret;

  const handleClick = (event: ButtonClickEventTypes) => {
    event.stopPropagation();

    if (!showFullSecret) {
      onShowApiKeySecret();
    }
    setShowFullSecret(!showFullSecret);
  };

  return (
    <div className="fs-exclude flex items-center">
      {showFullSecret ? (
        <CopyableText text={keySecret}>
          <code>{keySecret}</code>
        </CopyableText>
      ) : (
        <code>{truncatedSecret}</code>
      )}
      <div
        className={cn("btn hover:text-green-800", {
          "pl-0": showFullSecret,
        })}
      >
        <Clickable onClick={handleClick}>
          <span className="ml-2 text-green-500 hover:text-green-600">
            {showFullSecret ? "Hide" : "Show"}
          </span>
        </Clickable>
      </div>
    </div>
  );
}

export default APIKeySecret;
```

---
## `APIKeyViewForm.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  ApiKeyViewQuery,
  SafeInternalAccount,
  Permission,
} from "../../generated/dashboard/graphqlSchema";
import {
  CopyableText,
  DateTime,
  Drawer,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
  Pill,
} from "../../common/ui-components";
import APIKeySecret from "./APIKeySecret";
import { APIKeyRolesForm } from "./APIKeyRolesForm";
import PermissionsTable from "../containers/user_management/PermissionsTable";
import { getDrawerContent } from "~/common/utilities/getDrawerContent";

interface APIKeyViewFormProps {
  apiKey?: ApiKeyViewQuery["apiKey"];
  onShowApiKeySecret: (id: string) => void;
  loading: boolean;
  apiKeyMapping: Record<string, string>;
  roles: Array<string>;
  internalAccounts: SafeInternalAccount[];
  fullApiKey?: string | null;
  permissions?: Permission[];
  showPermissions?: boolean;
}

function formatAPIKey(
  apiKey: ApiKeyViewQuery["apiKey"],
  onShowKeySecret: (id: string) => void,
  keySecretLoading: boolean,
  fullApiKey?: string | null,
) {
  // Using the generated graphql type is convenient, but it can evaluate to
  null.
  // This function should never get called with a null apiKey.
  if (!apiKey) {
    return {};
  }
  return {
    ...apiKey,
    createdAtPrettyTime: <DateTime timestamp={apiKey.createdAt} />,
    decommissionedAtPrettyTime: apiKey.decommissionedAt ? (
      <DateTime timestamp={apiKey.decommissionedAt} />
    ) : null,
    liveMode: apiKey.liveMode ? "True" : "False",
    creator: apiKey.creator ? (
      <a href={apiKey.creator.path}>{apiKey.creator.name}</a>
    ) : (
      "Default"
    ),
    prettyIpAllowlist:
      apiKey.ipAllowlist && apiKey.ipAllowlist.length > 0 ? (
        apiKey.ipAllowlist.join(", ")
      ) : (
        <span className="italic">All IP Addresses</span>
      ),
    secret: (
      <APIKeySecret
        key={apiKey.id}
        secret={fullApiKey || apiKey.keySecret}
        onShowApiKeySecret={() => onShowKeySecret(apiKey.id)}
        loading={keySecretLoading}
      />
    ),
    organizationId: (
      <CopyableText text={apiKey.organizationId}>
        <code>{apiKey.organizationId}</code>
      </CopyableText>
    ),
    rateLimit: <span>{apiKey.rateLimit} requests per second</span>,
    ...(apiKey.rolesV2 &&
      apiKey.rolesV2.length > 0 &&
      apiKey.rolesV2[0].mtManaged && {
        roleV2: (
          <Drawer
            trigger={
              <div className="mr-1">
                <Pill className="associated-entity z-10" showTooltip>
                  {apiKey.rolesV2[0].name}
                </Pill>
              </div>
            }
            path={`/settings/user_management/roles/${apiKey.rolesV2[0].id}`}
          >
            {getDrawerContent("Role", apiKey.rolesV2[0].id)}
          </Drawer>
        ),
      }),
  };
}

export default function APIKeyViewForm({
  apiKey,
  onShowApiKeySecret,
  loading,
  apiKeyMapping,
  roles,
  internalAccounts,
  fullApiKey,
  permissions,
  showPermissions,
}: APIKeyViewFormProps) {
  return (
    <>
      <div>
        {!apiKey && <KeyValueTableSkeletonLoader dataMapping={apiKeyMapping} />}
        {!!apiKey && (
          <>
            {apiKey.default && (
              <div className="mb-6 mt-4 text-xs">
                This is a default API key. Permissions for new products will be
                automatically added to this key.
              </div>
            )}
            <KeyValueTable
              data={formatAPIKey(
                apiKey,
                onShowApiKeySecret,
                loading,
                fullApiKey,
              )}
              dataMapping={apiKeyMapping}
            />
          </>
        )}
      </div>

      {showPermissions ? (
        <>
          <h1 className="mb-4 mt-8">Permissions</h1>
          <PermissionsTable permissions={permissions || []} />
        </>
      ) : (
        <div className="mt-8">
          <APIKeyRolesForm
            roles={roles ?? []}
            internalAccounts={internalAccounts}
            enabled={false}
          />
        </div>
      )}
    </>
  );
}
```

---
## `AccountACHSettingBulkUploadActionItem.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateAccountAchSettingsMutation,
  useBulkValidateAccountAchSettingsMutation,
} from "~/generated/dashboard/graphqlSchema";
import FlatfileBulkUploadButton, {
  BulkResourceType,
} from "~/app/components/FlatfileBulkUploadButton";
import {
  accountACHSettingBlueprint,
  accountACHSettingBlueprintFields,
} from "./bulk_imports/blueprints/accountACHSettingBlueprint";

export const ACCOUNT_ACH_SETTING_CSV_HEADERS =
  accountACHSettingBlueprintFields.map((field) => field.key);

interface AccountCapabilityBulkUploadActionItemProps {
  connectionId: string;
}

function AccountCapabilityBulkUploadActionItem({
  connectionId,
}: AccountCapabilityBulkUploadActionItemProps) {
  const [bulkValidateAccountAchSettings] =
    useBulkValidateAccountAchSettingsMutation();
  const [bulkCreateAccountAchSettings] =
    useBulkCreateAccountAchSettingsMutation();

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateAccountAchSettings({
      variables: {
        input: {
          connectionId,
          accountAchSettings: resultsData,
        },
      },
    });
    return response.data?.bulkValidateAccountAchSettings?.recordErrors;
  };

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateAccountAchSettings({
      variables: {
        input: {
          connectionId,
          flatfileSheetId,
          flatfileSpaceId,
          accountAchSettings: resultsData,
        },
      },
    });

    const { id } =
      data?.bulkCreateAccountAchSettings?.connectionBulkImport ?? {};
    if (id) {
      return {
        success: true,
        path: `/operations/connection_bulk_imports/${id}`,
      };
    }
    return { success: false, path: "/" };
  };

  return (
    <FlatfileBulkUploadButton
      resource={BulkResourceType.AccountACHSettings}
      blueprint={accountACHSettingBlueprint}
      expectedFields={accountACHSettingBlueprintFields}
      onValidate={validate}
      onSubmit={submit}
      launchFromActionsList
    />
  );
}

export default AccountCapabilityBulkUploadActionItem;
```

---
## `AccountCapabilities.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { capitalize } from "lodash";
import { ACCOUNT_CAPABILITIES } from "../../common/constants/analytics";
import { InternalAccountViewQuery } from
"../../generated/dashboard/graphqlSchema";
import {
  Icon,
  IndexTable,
  IndexTableSkeletonLoader,
} from "../../common/ui-components";

export type AccountCapabilitiesProps = NonNullable<
  InternalAccountViewQuery["internalAccount"]
>["accountCapabilities"];
type AccountCapabilitiesItem = AccountCapabilitiesProps[number];

type ICapabilities = {
  key: string;
  value: string;
};

export const ACCOUNT_CAPABILITIES_MAPPING = {
  paymentType: "Payment Type",
  credit: "Credit (Pay)",
  debit: "Debit (Charge)",
};

const STYLE_MAPPING = {
  credit: "!pb-1 !pt-1.5 items-center",
  debit: "!pb-1 !pt-1.5 items-center",
};

// Make sure you also add your payment type to:
// - `app/javascript/src/app/constants/index.ts`
// - `app/javascript/src/app/containers/payment_order_form/PaymentMethod.tsx`
// - `app/models/payment_order.rb
export const CAPABILITY_MAP = {
  ach: { name: "ACH" },
  au_becs: { name: "Australian BECS", extra: true },
  bacs: { name: "Bacs", extra: true },
  book: { creditOnly: true, name: "Book", extra: true },
  card: { creditOnly: true, name: "Card", extra: true },
  chats: { name: "Hong Kong CHATS", creditOnly: true, extra: true },
  check: { creditOnly: true, name: "Check" },
  cross_border: {
    creditOnly: true,
    name: "Cross Border",
    extra: true,
    foreignExchangeCapable: true,
  },
  dk_nets: { name: "Denmark Nets", creditOnly: true, extra: true },
  eft: { name: "EFT", extra: true },
  hu_ics: { name: "Hungary ICS", creditOnly: true, extra: true },
  interac: { name: "Interac e-Transfer", extra: true },
  masav: { name: "Masav", extra: true },
  neft: { name: "NEFT", extra: true },
  nics: { name: "NICS", extra: true },
  nz_becs: { name: "New Zealand BECS", extra: true },
  provxchange: { name: "ProvXchange", extra: true, creditOnly: true },
  rtp: { name: "RTP", extra: true },
  se_bankgirot: { name: "Swedish Bankgirot", extra: true },
  sen: { name: "SEN", extra: true },
  sepa: { name: "SEPA", extra: true },
  sknbi: { name: "SKNBI", extra: true },
  sic: { name: "SIC", extra: true },
  signet: { name: "Signet", extra: true },
  wire: { name: "Wire" },
  zengin: { name: "Zengin", extra: true },
};

function boolToIcon(bool: boolean) {
  return bool ? (
    <Icon
      className="text-green-500"
      iconName="done"
      color="currentColor"
      size="m"
    />
  ) : (
    <Icon
      className="text-red-600"
      iconName="clear"
      color="currentColor"
      size="m"
    />
  );
}

function formatCapabilities(
  capabilities: Array<Record<string, unknown>>,
  mapping: Record<string, unknown>,
) {
  const { name, creditOnly } = mapping;

  const credit = !!capabilities.find(
    (capability) => capability.direction === "credit",
  );
  const creditIcon = boolToIcon(credit);

  const debit = !!capabilities.find(
    (capability) => capability.direction === "debit",
  );
  const debitIcon = boolToIcon(debit);

  return {
    credit: creditIcon,
    debit: creditOnly ? "N/A" : debitIcon,
    paymentType: name,
    id: name,
  };
}

function formatAccountCapabilities(
  accountCapabilities: AccountCapabilitiesProps,
) {
  return {
    data: Object.keys(CAPABILITY_MAP).reduce(
      (acc: Array<Record<string, unknown>>, capabilityKey: string) => {
        const mapping = CAPABILITY_MAP[capabilityKey] as Record<
          string,
          unknown
        >;
        const capabilities = accountCapabilities.filter(
          (capability: Record<string, unknown>) =>
            capability.paymentType === capabilityKey,
        );

        if (mapping.extra && !capabilities.length) {
          return acc;
        }
        return acc.concat([formatCapabilities(capabilities, mapping)]);
      },
      [],
    ),
    expandedData:
      accountCapabilities?.length > 0
        ? Object.keys(CAPABILITY_MAP).reduce(
            (
              acc: Record<string, Array<ICapabilities>>,
              capabilityKey: string,
            ) => {
              const mapping: Record<string, unknown> = CAPABILITY_MAP[
                capabilityKey
              ] as Record<string, unknown>;

              const capabilities = accountCapabilities
                .filter(
                  (capability) => capability.paymentType === capabilityKey,
                )
                .sort((a, b) => {
                  if (a.direction.toUpperCase() < b.direction.toUpperCase())
                    return -1;
                  if (a.direction.toUpperCase() > b.direction.toUpperCase())
                    return 1;
                  return 0;
                });

              const key = mapping?.name as string;

              if (key && capabilities.length) {
                acc[key] = [];
                capabilities.forEach((capability: AccountCapabilitiesItem) => {
                  acc[key].push({
                    key: `${key} ${capitalize(
                      capability.direction,
                    )} Currencies`,
                    value: capability.anyCurrency
                      ? "All Currencies Enabled"
                      : capability.currencies.join(", "),
                  });
                  if (capability.prettyPaymentSubtypes) {
                    acc[key].push({
                      key: `${key} ${capitalize(
                        capability.direction,
                      )} SEC Codes`,
                      value: capability.prettyPaymentSubtypes.join(", "),
                    });
                  }
                });
              }
              return acc;
            },
            {},
          )
        : undefined,
  };
}

function AccountCapabilities({
  accountId,
  accountCapabilities,
}: {
  accountId: string;
  accountCapabilities: AccountCapabilitiesProps | undefined;
}): JSX.Element {
  const loadingView: JSX.Element = (
    <IndexTableSkeletonLoader
      headers={Object.keys(ACCOUNT_CAPABILITIES_MAPPING)}
      numRows={5}
    />
  );

  if (!accountCapabilities) {
    return loadingView;
  }

  const { data, expandedData } = formatAccountCapabilities(accountCapabilities);

  return (
    <div id="accountCapabilitiesTable">
      <IndexTable
        disableBulkActions
        enableActions
        dataMapping={ACCOUNT_CAPABILITIES_MAPPING}
        styleMapping={STYLE_MAPPING}
        data={data}
        expandedData={expandedData}
        trackOnViewClick={{
          properties: { internal_account_id: accountId },
          show: ACCOUNT_CAPABILITIES.DETAILS_BUTTON_SHOW,
          hide: ACCOUNT_CAPABILITIES.DETAILS_BUTTON_HIDE,
        }}
      />
    </div>
  );
}

export default AccountCapabilities;
```

---
## `AccountCapabilityBulkUploadActionItem.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateAccountCapabilitiesMutation,
  useBulkValidateAccountCapabilitiesMutation,
} from "~/generated/dashboard/graphqlSchema";
import FlatfileBulkUploadButton, {
  BulkResourceType,
} from "~/app/components/FlatfileBulkUploadButton";
import {
  accountCapabilityBlueprint,
  accountCapabilityBlueprintFields,
} from "./bulk_imports/blueprints/accountCapabilityBlueprint";

export const ACCOUNT_CAPABILITY_CSV_HEADERS =
  accountCapabilityBlueprintFields.map((field) => field.key);

interface AccountCapabilityBulkUploadActionItemProps {
  connectionId: string;
}

function AccountCapabilityBulkUploadActionItem({
  connectionId,
}: AccountCapabilityBulkUploadActionItemProps) {
  const [bulkValidateAccountCapabilities] =
    useBulkValidateAccountCapabilitiesMutation();
  const [bulkCreateAccountCapabilities] =
    useBulkCreateAccountCapabilitiesMutation();

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateAccountCapabilities({
      variables: {
        input: {
          connectionId,
          accountCapabilities: resultsData,
        },
      },
    });
    return response.data?.bulkValidateAccountCapabilities?.recordErrors;
  };

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateAccountCapabilities({
      variables: {
        input: {
          connectionId,
          flatfileSheetId,
          flatfileSpaceId,
          accountCapabilities: resultsData,
        },
      },
    });

    const { id } =
      data?.bulkCreateAccountCapabilities?.connectionBulkImport ?? {};
    if (id) {
      return {
        success: true,
        path: `/operations/connection_bulk_imports/${id}`,
      };
    }
    return { success: false, path: "/" };
  };

  return (
    <FlatfileBulkUploadButton
      resource={BulkResourceType.AccountCapabilities}
      blueprint={accountCapabilityBlueprint}
      expectedFields={accountCapabilityBlueprintFields}
      onValidate={validate}
      onSubmit={submit}
      launchFromActionsList
    />
  );
}

export default AccountCapabilityBulkUploadActionItem;
```

---
## `AccountingCategorySelect.jsx.txt`
**Path:** `.`  
```
import React, { useMemo } from "react";
import { connect } from "react-redux";
import isEmpty from "lodash/isEmpty";
import { FieldGroup, Label, SelectField } from "../../common/ui-components";

const ACCOUNT_ORDER = ["asset", "equity", "expense", "liability", "revenue"];

function AccountingCategorySelect({
  metadata,
  label,
  helpText,
  ledgerEntities,
  input: { name, value: selectValue, onChange: handleChange },
  disabled,
}) {
  const ledgerAccountOptions = useMemo(() => {
    const options = {};

    ledgerEntities.allIds.forEach((id) => {
      const ledgerEntity = ledgerEntities.byId[id];

      if (ledgerEntity.ledger_sync_type === "account") {
        const {
          id: value,
          data: { classification, name: optionLabel },
        } = ledgerEntity;
        if (!options[classification]) {
          options[classification] = [];
        }

        options[classification].push({ value, label: optionLabel, metadata });
      }
    });

    return ACCOUNT_ORDER.map((key) => ({
      label: key,
      options: options[key],
    }));
  }, [ledgerEntities.allIds, ledgerEntities.byId, metadata]);

  return (
    <FieldGroup direction="top-to-bottom">
      <Label id={name}>{label}</Label>
      <SelectField
        selectValue={selectValue}
        helpText={helpText}
        disabled={isEmpty(ledgerEntities.allIds) || disabled}
        options={ledgerAccountOptions}
        handleChange={handleChange}
        name={name}
      />
    </FieldGroup>
  );
}

const mapStateToProps = (state) => ({
  ledgerEntities: state.ledgerEntities,
});

export default connect(mapStateToProps, {})(AccountingCategorySelect);
```

---
## `AccountingLedgerClassSelect.jsx.txt`
**Path:** `.`  
```
import React, { useMemo } from "react";
import { connect } from "react-redux";
import isEmpty from "lodash/isEmpty";
import { FieldGroup, Label, SelectField } from "../../common/ui-components";

function AccountingLedgerClassSelect({
  label,
  helpText,
  ledgerEntities,
  input: { name, value: selectValue, onChange: handleChange },
  disabled,
}) {
  const ledgerClassOptions = useMemo(() => {
    const options = [];

    ledgerEntities.allIds.forEach((id) => {
      const ledgerEntity = ledgerEntities.byId[id];

      if (ledgerEntity.ledger_sync_type === "ledger_class") {
        const {
          id: value,
          data: { name: optionLabel },
        } = ledgerEntity;
        options.push({ value, label: optionLabel });
      }
    });

    return options;
  }, [ledgerEntities.allIds, ledgerEntities.byId]);

  return (
    <FieldGroup>
      <Label id={name}>{label}</Label>
      <SelectField
        selectValue={selectValue}
        helpText={helpText}
        disabled={isEmpty(ledgerEntities.allIds) || disabled}
        options={ledgerClassOptions}
        handleChange={handleChange}
        name={name}
      />
    </FieldGroup>
  );
}

const mapStateToProps = (state) => ({
  ledgerEntities: state.ledgerEntities,
});

export default connect(mapStateToProps, {})(AccountingLedgerClassSelect);
```

---
## `AccountingLedgerSettingsForm.jsx.txt`
**Path:** `.`  
```
import React, { useState, useEffect } from "react";
import isNil from "lodash/isNil";
import { connect } from "react-redux";
import requestApi from "../../common/utilities/requestApi";
import { loadLedgerEntities } from "../actions";
import AccountingSubsidiarySelect from "./AccountingSubsidiarySelect";
import ReduxCheckbox from "../../common/deprecated_redux/ReduxCheckbox";
import { Button, FieldGroup, Label } from "../../common/ui-components";
import { useDispatchContext } from "../MessageProvider";
import Gon from "../../common/utilities/gon";

function AccountingLedgerSettingsForm({
  isSubView,
  loadLedgerEntities: loadLedgerEntitiesFunc,
}) {
  const {
    ui: { ledger },
  } = Gon.gon ?? {};
  const [state, setState] = useState(ledger);
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  useEffect(() => {
    loadLedgerEntitiesFunc(
      { ledger_sync_type: ["subsidiary"] },
      null,
      dispatchError,
    );
  }, [loadLedgerEntitiesFunc, dispatchError]);

  function submitForm(e, data) {
    if (!isNil(e)) {
      e.preventDefault();
    }

    const method = "PATCH";
    const action = `/accounting/ledgers/${state.id}`;

    requestApi(action, null, method, data)
      .json(() => {
        dispatchSuccess("Ledger data updated");
      })
      .catch((error) => {
        try {
          const {
            errors: { message },
          } = JSON.parse(error.message);
          dispatchError(message);
        } catch {
          dispatchError(
            "Sorry but we couldn't save this ledger data. Please check for
            anything that is invalid",
          );
        }
      });
  }

  function onUpdateLedgerSettings(e) {
    const data = {
      ledger_classes_enabled: state.ledger_classes_enabled,
      auto_sync_counterparties_enabled: state.auto_sync_counterparties_enabled,
      auto_sync_payment_orders_enabled: state.auto_sync_payment_orders_enabled,
    };

    submitForm(e, data);
  }

  function onUpdateVendorSpecificSettings(e) {
    const data = {
      default_subsidiary_id: state.default_subsidiary_id,
    };

    submitForm(e, data);
  }

  function handleChange(newState) {
    setState(newState);

    if (isSubView) {
      submitForm(null, newState);
    }
  }

  function toggleClassesEnabled() {
    handleChange({
      ...state,
      ledger_classes_enabled: !state.ledger_classes_enabled,
    });
  }

  function toggleCounterpartySyncingEnabled() {
    handleChange({
      ...state,
      auto_sync_counterparties_enabled: !state.auto_sync_counterparties_enabled,
    });
  }

  function togglePaymentOrderSyncingEnabled() {
    handleChange({
      ...state,
      auto_sync_payment_orders_enabled: !state.auto_sync_payment_orders_enabled,
    });
  }

  function onDefaultSubsidiaryIdChange(target) {
    handleChange({ ...state, default_subsidiary_id: target });
  }

  return (
    <>
      <div className="mt-container">
        <form className="form-create">
          <div className="form-section">
            <h3>Ledger Settings</h3>
            <FieldGroup direction="left-to-right">
              <ReduxCheckbox
                id="ledger_classes_enabled"
                name="ledger_classes_enabled"
                input={{
                  onChange: toggleClassesEnabled,
                  checked: state.ledger_classes_enabled,
                }}
              />
              <Label
                id="ledger_classes_enabled_label"
                helpText="When enabled, you can select an accounting class on
                each Payment Order.<br />When synced, Payment Orders will be
                associated to the assigned class."
              >
                Enable Ledger Classes
              </Label>
            </FieldGroup>
            <FieldGroup direction="left-to-right">
              <ReduxCheckbox
                id="auto_sync_counterparties_enabled"
                name="auto_sync_counterparties_enabled"
                input={{
                  onChange: toggleCounterpartySyncingEnabled,
                  checked: state.auto_sync_counterparties_enabled,
                }}
              />
              <Label
                id="auto_sync_counterparties_enabled_label"
                helpText="When enabled, counterparties will be automatically
                synced when they are created.<br />Given that a Counterparty can
                represent one or more accounting entities (e.g. Customer,
                Vendor, etc.), <br />to allow auto-syncing, you must select a
                Default Accounting Type for each Counterparty."
              >
                Auto Sync Counterparties
              </Label>
            </FieldGroup>
            <FieldGroup direction="left-to-right">
              <ReduxCheckbox
                id="auto_sync_payment_orders_enabled"
                name="auto_sync_payment_orders_enabled"
                input={{
                  onChange: togglePaymentOrderSyncingEnabled,
                  checked: state.auto_sync_payment_orders_enabled,
                }}
              />
              <Label
                id="auto_sync_payment_orders_enabled_label"
                helpText="When enabled, payment orders will be automatically
                synced.<br />Payment Orders are synced to your bank when when
                their status<br />transitions to Sent, meaning it has been sent
                to the bank."
              >
                Auto Sync Payment Orders
              </Label>
            </FieldGroup>
          </div>
          {!isSubView && (
            <div className="form-section">
              <Button buttonType="primary" onClick={onUpdateLedgerSettings}>
                Update Ledger Settings
              </Button>
            </div>
          )}
        </form>
      </div>
      {ledger.vendor === "NetSuite" && (
        <div className="mt-container">
          <form className="form-create">
            <div className="form-section">
              <h3>NetSuite Settings</h3>
              <div className="form-row form-row-full flex">
                <AccountingSubsidiarySelect
                  label="Default Subsidiary"
                  helpText="This is the Subsidiary we will use when syncing
                  records to your ledger."
                  name="default_subsidiary_id"
                  input={{
                    value: state.default_subsidiary_id,
                    onChange: onDefaultSubsidiaryIdChange,
                  }}
                />
              </div>
            </div>
            {!isSubView && (
              <div className="form-section">
                <Button
                  buttonType="primary"
                  onClick={onUpdateVendorSpecificSettings}
                >{`Update ${ledger.vendor} Settings`}</Button>
              </div>
            )}
          </form>
        </div>
      )}
    </>
  );
}

export default connect(null, {
  loadLedgerEntities,
})(AccountingLedgerSettingsForm);
```

---
## `AccountingSubsidiarySelect.jsx.txt`
**Path:** `.`  
```
import React, { useMemo } from "react";
import { connect } from "react-redux";
import isEmpty from "lodash/isEmpty";
import { FieldGroup, Label, SelectField } from "../../common/ui-components";

function AccountingSubsidiarySelect({
  label,
  helpText,
  ledgerEntities,
  input: { value: selectValue, onChange: handleChange },
}) {
  const subsidiaryOptions = useMemo(() => {
    const options = [];

    ledgerEntities.allIds.forEach((id) => {
      const ledgerEntity = ledgerEntities.byId[id];

      if (ledgerEntity.ledger_sync_type === "subsidiary") {
        const {
          ledger_resource_id: value,
          data: { name },
        } = ledgerEntity;
        options.push({ value, label: name });
      }
    });

    return options;
  }, [ledgerEntities.allIds, ledgerEntities.byId]);

  return (
    <FieldGroup direction="top-to-bottom">
      <Label id="accountingSubsidiarySelect">{label}</Label>
      <SelectField
        selectValue={selectValue}
        helpText={helpText}
        disabled={isEmpty(ledgerEntities.allIds)}
        options={subsidiaryOptions}
        handleChange={handleChange}
        name="accountingSubsidiarySelect"
      />
    </FieldGroup>
  );
}

const mapStateToProps = (state) => ({
  ledgerEntities: state.ledgerEntities,
});

export default connect(mapStateToProps, {})(AccountingSubsidiarySelect);
```

---
## `AddCardModal.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import requestApi from "../../common/utilities/requestApi";
import CardAcceptanceFields from
"../../auth/components/sign_up/CardAcceptanceFields";
import { ConfirmModal } from "../../common/ui-components";
import { DispatchMessageFnType, useDispatchContext } from "../MessageProvider";
import Gon from "../../common/utilities/gon";

interface AddCardModalProps {
  isOpen: boolean;
  handleModalClose: () => void;
}

const submitCardDetails = (
  cardToken: string,
  expiry: string,
  dispatchSuccess: DispatchMessageFnType["dispatchSuccess"],
) => {
  requestApi("/settings/billing/update_card", null, "POST", {
    card_token: cardToken,
    expiry,
  })
    .res(() => {
      window.location.href = "/settings/billing";
      dispatchSuccess("Payment Details Updated");
    })
    .catch(() => {});
};

function AddCardModal({ isOpen, handleModalClose }: AddCardModalProps) {
  const { dispatchSuccess } = useDispatchContext();
  const [disableSubmit, setDisableSubmit] = useState(true);
  const [cardToken, setCardToken] = useState("");
  const [expiry, setExpiry] = useState("");
  const handleCardTokenizationSuccess = (
    newCardToken: string,
    newCardExpiry: string,
  ) => {
    setCardToken(newCardToken);
    setExpiry(newCardExpiry);
    setDisableSubmit(false);
  };

  const {
    ui: { cardconnectEnvironment },
  } = Gon.gon;

  return (
    <ConfirmModal
      isOpen={isOpen}
      title="Add a New Card"
      onRequestClose={handleModalClose}
      confirmText="Submit"
      onConfirm={() => submitCardDetails(cardToken, expiry, dispatchSuccess)}
      confirmDisabled={disableSubmit}
      cancelText="Cancel"
      setIsOpen={handleModalClose}
    >
      <form className="form-create">
        <div className="form-section">
          <CardAcceptanceFields
            isModal
            cardconnectEnvironment={cardconnectEnvironment}
            onCardTokenization={handleCardTokenizationSuccess}
          />
        </div>
      </form>
    </ConfirmModal>
  );
}

export default AddCardModal;
```

---
## `AddPartnerContactModal.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useDispatch } from "react-redux";
import { ClipLoader } from "react-spinners";
import {
  Field,
  FieldProps,
  Form,
  Formik,
  FormikErrors,
  FormikProps,
} from "formik";
import { Alert, Input, Label, ConfirmModal } from "../../common/ui-components";
import { FormValues } from "../constants/partner_contact_form";
import {
  useOnboardingPartnerContactsHomeQuery,
  useUpsertOnboardingPartnerContactMutation,
} from "../../generated/dashboard/graphqlSchema";
import { EMAIL_REGEX } from "../../common/constants";
import { INITIAL_PAGINATION } from "./EntityTableView";

interface AddPartnerContactModalProps {
  isOpen: boolean;
  partnerId: string;
  existingId?: string;
  partnerContactFormValues: FormValues;
  handleModalClose: () => void;
}

function AddPartnerContactModal({
  isOpen,
  partnerId,
  existingId = "",
  partnerContactFormValues = {
    name: "",
    email: "",
    phone: "",
  },
  handleModalClose,
}: AddPartnerContactModalProps) {
  const [upsertContactErrorMessage, setUpsertContactErrorMessage] =
    useState<string>();
  const dispatch = useDispatch();
  const [upsertOnboardingPartnerContact] =
    useUpsertOnboardingPartnerContactMutation();
  const { data, loading, refetch } = useOnboardingPartnerContactsHomeQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: INITIAL_PAGINATION.perPage,
      partnerId,
    },
  });

  if (loading || !data) return <ClipLoader />;

  const validateForm = (values: FormValues) => {
    const errors: FormikErrors<FormValues> = {};
    if (!values.name) {
      errors.name = "Required";
      setUpsertContactErrorMessage("Name is required");
    }
    if (!values.email) {
      errors.email = "Required";
      setUpsertContactErrorMessage("Email is required");
    }
    if (values.email && !EMAIL_REGEX.test(values.email)) {
      errors.email = "Please enter valid email";
      setUpsertContactErrorMessage("Please enter valid email");
    }
    return errors;
  };

  const submitPartnerContactDetails = async (formValues: FormValues) => {
    const { name, email, phone } = formValues;

    const result = await upsertOnboardingPartnerContact({
      variables: {
        input: {
          input: {
            ...(existingId && { id: existingId }),
            name: name ?? "",
            email,
            phone,
            partnerId,
          },
        },
      },
    });

    if (result.data?.upsertOnboardingPartnerContact?.errors.length === 0) {
      await refetch();
      setUpsertContactErrorMessage("");
      dispatch(handleModalClose);
    } else {
      setUpsertContactErrorMessage(
        result.data?.upsertOnboardingPartnerContact?.errors?.join(","),
      );
    }
  };

  return (
    <div className="outer-mt-container">
      <Formik
        initialValues={partnerContactFormValues}
        onSubmit={submitPartnerContactDetails}
        validate={validateForm}
        validateOnChange={false}
        validateOnBlur={false}
      >
        {({ values, handleSubmit, resetForm }) => (
          <ConfirmModal
            title={existingId ? "Edit Contact" : "Create Contact"}
            isOpen={isOpen}
            onAfterOpen={() =>
              resetForm({
                values: {
                  name: partnerContactFormValues.name,
                  email: partnerContactFormValues.email,
                  phone: partnerContactFormValues.phone,
                },
              })
            }
            onRequestClose={handleModalClose}
            setIsOpen={handleModalClose}
            confirmText={existingId ? "Update" : "Create"}
            confirmType="confirm"
            onConfirm={handleSubmit}
            className="max-w-[420px]"
            bodyClassName="form-create form-create-wide form-create-rules"
          >
            {upsertContactErrorMessage && (
              <Alert
                onClear={() => setUpsertContactErrorMessage("")}
                alertType="danger"
              >
                {upsertContactErrorMessage}
              </Alert>
            )}
            <Form>
              <Field name="name" key="name">
                {({
                  field,
                  form,
                }: FieldProps<string> & FormikProps<FormValues>) => (
                  <div className="form-row mb-3 flex pt-5">
                    <Label className="text-sm font-medium">Name</Label>
                    <Input
                      value={values?.name || ""}
                      onChange={(event) => {
                        void form.setFieldValue(field.name, event.target.value);
                      }}
                    />
                  </div>
                )}
              </Field>
              <Field name="email" key="email">
                {({
                  field,
                  form,
                }: FieldProps<string> & FormikProps<FormValues>) => (
                  <div className="form-row mb-3 flex">
                    <Label className="text-sm font-medium">Email</Label>
                    <Input
                      value={values?.email || ""}
                      onChange={(event) => {
                        void form.setFieldValue(field.name, event.target.value);
                      }}
                    />
                  </div>
                )}
              </Field>
              <Field name="phone" key="phone">
                {({
                  field,
                  form,
                }: FieldProps<string> & FormikProps<FormValues>) => (
                  <div className="form-row mb-3 flex">
                    <Label className="text-sm font-medium">Phone</Label>
                    <Input
                      value={values?.phone || ""}
                      onChange={(event) => {
                        void form.setFieldValue(field.name, event.target.value);
                      }}
                    />
                  </div>
                )}
              </Field>
            </Form>
          </ConfirmModal>
        )}
      </Formik>
    </div>
  );
}

export default AddPartnerContactModal;
```

---
## `AddressForm.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Field } from "redux-form";
import { COUNTRY_CODES } from "../constants";
import { required } from "../../common/ui-components/validations";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { SelectField, Label, FieldGroup } from "../../common/ui-components";

interface AddressFormProps {
  fieldName: string;
  isDisabled?: boolean;
  address?: Record<string, unknown>;
  addressName: string;
  shouldValidate?: boolean;
}

function AddressForm({
  fieldName,
  isDisabled,
  address,
  addressName,
  shouldValidate,
}: AddressFormProps) {
  const validate = shouldValidate ? [required] : [];
  return (
    <div>
      <div className="subsection-row">
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.line1`}>Address Line 1</Label>
          <Field
            name={`${fieldName}.${addressName}.line1`}
            type="text"
            component={ReduxInputField}
            disabled={isDisabled}
            validate={validate}
          />
        </FieldGroup>
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.line2`}>Address Line 2</Label>
          <Field
            name={`${fieldName}.${addressName}.line2`}
            type="text"
            component={ReduxInputField}
            disabled={isDisabled}
          />
        </FieldGroup>
      </div>
      <div className="subsection-row">
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.locality`}>City</Label>
          <Field
            name={`${fieldName}.${addressName}.locality`}
            type="text"
            component={ReduxInputField}
            disabled={isDisabled}
            validate={validate}
          />
        </FieldGroup>
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.region`}>State</Label>
          <Field
            name={`${fieldName}.${addressName}.region`}
            type="text"
            component={ReduxInputField}
            disabled={isDisabled}
            validate={validate}
          />
        </FieldGroup>
      </div>

      <div className="subsection-row">
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.postal_code`}>
            Postal Code
          </Label>
          <Field
            name={`${fieldName}.${addressName}.postal_code`}
            type="text"
            component={ReduxInputField}
            disabled={isDisabled}
            validate={validate}
          />
        </FieldGroup>
        <FieldGroup>
          <Label id={`${fieldName}.${addressName}.country`}>Country</Label>
          <Field
            required
            name={`${fieldName}.${addressName}.country`}
            type="text"
            component={SelectField}
            disabled={isDisabled}
            options={COUNTRY_CODES}
            selectValue={address?.country}
            validate={validate}
          />
        </FieldGroup>
      </div>
    </div>
  );
}

export default AddressForm;
```

---
## `AddressFormSection.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { Formik, FormikProps } from "formik";
import AddressForm, {
  AddressFormValues,
  defaultAddress,
  formatAddress,
  isAddressEmpty,
} from "../../common/formik/FormikAddressForm";
import {
  Button,
  Checkbox,
  Heading,
  HorizontalRule,
  ConfirmModal,
  FieldGroup,
  Label,
  PopoverPanel,
  PopoverTrigger,
  Popover,
  Icon,
  ActionItem,
} from "../../common/ui-components";

interface AddressContainerProps {
  address: AddressFormValues;
  showAddressModal: () => void;
  deleteAddress: () => void;
  id: string;
}

function AddressContainer({
  address,
  showAddressModal,
  deleteAddress,
  id,
}: AddressContainerProps) {
  return (
    <>
      <div className="flex justify-between">
        {formatAddress(address)}
        <Popover>
          <PopoverTrigger
            className="border-none bg-white"
            buttonType="secondary"
            buttonHeight="small"
            hideFocusOutline
            id={id}
          >
            <Icon
              iconName="more_horizontal"
              color="currentColor"
              className="text-gray-600"
              size="s"
            />
          </PopoverTrigger>
          <PopoverPanel
            className="badge-action-dropdown reports-button-panel"
            anchorOrigin={{ horizontal: "right" }}
          >
            <ActionItem onClick={showAddressModal}>Edit</ActionItem>

            <ActionItem onClick={deleteAddress}>
              <div className="text-red-500">Delete</div>
            </ActionItem>
          </PopoverPanel>
        </Popover>
      </div>
      <div className="pb-2 pt-2">
        <HorizontalRule />
      </div>
    </>
  );
}

interface AddressFormSectionHeaderProps {
  addressType: AddressType;
  required: boolean;
  showAddButton: boolean;
  onAddClick: () => void;
  subheader?: string;
}

function AddressFormSectionHeader({
  addressType,
  required,
  showAddButton,
  onAddClick,
  subheader,
}: AddressFormSectionHeaderProps) {
  return (
    <div>
      <div className="flex items-center justify-between">
        <div>
          <div className="flex items-center">
            <div className="text-base">
              <Heading level="h2" size="m">
                {`${addressType} Address`}
              </Heading>
            </div>
            {!required && (
              <span className="pl-2 pt-1 text-xs font-normal text-gray-500">
                Optional
              </span>
            )}
          </div>
        </div>

        {showAddButton && (
          <Button onClick={onAddClick} buttonType="secondary">
            {`Add ${addressType} Address`}
          </Button>
        )}
      </div>
      <p className="font-base mt-2 text-xs text-gray-500">{subheader}</p>
    </div>
  );
}

type AddressType = "Billing" | "Party" | "Shipping" | "Sender";

interface SameAsOtherAddressProps {
  otherAddressType: AddressType;
  sameAsOtherAddress: boolean;
  onSameAsOtherAddressChange: (boolean: boolean) => void;
}

interface AddressFormSectionnProps {
  id: string;
  address: AddressFormValues;
  addressType: AddressType;
  onAddressChange: (address: AddressFormValues) => void;
  required?: boolean;
  sameAsOtherAddressProps?: SameAsOtherAddressProps;
  subheader?: string;
}

// Root for formik form state to re-use AddressForm component
const ADDRESS_FORM_ROOT_FIELD_NAME = "addressForm";
const FORM_ADDRESS_NAME = "address";

function AddressFormSection({
  id,
  address,
  addressType,
  subheader,
  onAddressChange,
  required = false,
  sameAsOtherAddressProps,
}: AddressFormSectionnProps) {
  const [showAddressModal, setShowAddressModal] = useState(false);

  const initialValues = {
    [ADDRESS_FORM_ROOT_FIELD_NAME]: {
      [FORM_ADDRESS_NAME]: address || defaultAddress,
    },
  };

  return (
    <Formik
      initialValues={initialValues}
      onSubmit={(data) => onAddressChange(data.addressForm.address)}
    >
      {({
        errors,
        touched,
        handleSubmit,
        setFieldValue,
        isValid,
      }: FormikProps<{
        [ADDRESS_FORM_ROOT_FIELD_NAME]: {
          [FORM_ADDRESS_NAME]: AddressFormValues;
        };
      }>) => (
        <>
          <div className="pb-8">
            <AddressFormSectionHeader
              addressType={addressType}
              required={required}
              subheader={subheader}
              showAddButton={
                isAddressEmpty(address) &&
                !sameAsOtherAddressProps?.sameAsOtherAddress
              }
              onAddClick={() => setShowAddressModal(true)}
            />

            <div className="pb-2 pt-2">
              <HorizontalRule />
            </div>

            {sameAsOtherAddressProps && (
              <FieldGroup direction="left-to-right" className="-mb-2">
                <Label>
                  {`Same as ${sameAsOtherAddressProps.otherAddressType}
                  Address`}
                </Label>
                <Checkbox
                  checked={sameAsOtherAddressProps.sameAsOtherAddress}
                  onChange={sameAsOtherAddressProps.onSameAsOtherAddressChange}
                  name="isSameAsOtherAddress"
                />
              </FieldGroup>
            )}

            {!sameAsOtherAddressProps && isAddressEmpty(address) && (
              <div className="text-gray-500">None</div>
            )}

            {!isAddressEmpty(address) && (
              <>
                {sameAsOtherAddressProps &&
                  !sameAsOtherAddressProps.sameAsOtherAddress && (
                    <div className="pb-2 pt-4">
                      <HorizontalRule />
                    </div>
                  )}
                {!sameAsOtherAddressProps?.sameAsOtherAddress && (
                  <AddressContainer
                    address={address}
                    showAddressModal={() => setShowAddressModal(true)}
                    deleteAddress={() => {
                      void setFieldValue(
                        `${ADDRESS_FORM_ROOT_FIELD_NAME}.${FORM_ADDRESS_NAME}`,
                        { ...defaultAddress },
                      );
                      setTimeout(() => {
                        handleSubmit();
                      });
                    }}
                    id={`${id}Actions`}
                  />
                )}
              </>
            )}
          </div>
          <ConfirmModal
            title={`${addressType} Address`}
            isOpen={showAddressModal}
            confirmText="Save"
            setIsOpen={() => setShowAddressModal(false)}
            onConfirm={() => {
              handleSubmit();
              setShowAddressModal(false);
            }}
            confirmDisabled={!isValid}
          >
            <AddressForm
              fieldName={ADDRESS_FORM_ROOT_FIELD_NAME}
              addressName={FORM_ADDRESS_NAME}
              id={id}
              errors={errors}
              touched={touched}
            />
          </ConfirmModal>
        </>
      )}
    </Formik>
  );
}

export default AddressFormSection;
```

---
## `AdminApprovalRoleProposedChanges.tsx.txt`
**Path:** `.`  
```
import React from "react";
import TruncateString from "react-truncate-string";
import ReactTooltip from "react-tooltip";
import {
  ProposedChange,
  Group,
  SafeInternalAccount,
} from "~/generated/dashboard/graphqlSchema";
import { KeyValueTable, Icon } from "~/common/ui-components";
import {
  ROLE_ORGANIZATION_MAPPING,
  ROLE_DEVELOPER_MAPPING,
  ROLE_COUNTERPARTY_MAPPING,
  ROLE_EXTERNAL_ACCOUNT_MAPPING,
  ROLE_LEDGER_MAPPING,
  ACCOUNT_PERMISSIONS_MAPPING,
  ROLE_COMPLIANCE_MAPPING,
  ROLE_PARTNER_SEARCH_MAPPING,
  ROLE_API_KEYS_MAPPING,
  ROLE_CUSTOMER_ADMIN_TOOLS_MAPPING,
  ROLE_PARTNER_ADMIN_TOOLS_MAPPING,
  ROLE_ENGINEERING_DEBUG_TOOLS_MAPPING,
  PER_ACCOUNT_PERMISSIONS_MAPPING,
} from "~/app/constants/index";
import { renderPermission } from "../containers/groups/renderPermission";

const TABLE_MAPPING = {
  customer_admin_tools: "Customer Admin Tools",
  partner_admin_tools: "Partner Admin Tools",
  engineering_debug_tools: "Engineering Debug Tools",
  organization: "Organization",
  developer: "Developer Settings",
  api_keys: "API Keys",
  ledgers: "Ledgers",
  compliance: "Compliance",
  partner_search: "Partner Search",
  external_accounts: "External Accounts",
  counterparties: "Counterparties",
  accounts: "Accounts",
};

const ROLE_MAPPING = {
  ...ROLE_CUSTOMER_ADMIN_TOOLS_MAPPING,
  ...ROLE_PARTNER_ADMIN_TOOLS_MAPPING,
  ...ROLE_ENGINEERING_DEBUG_TOOLS_MAPPING,
  ...ROLE_ORGANIZATION_MAPPING,
  ...ROLE_DEVELOPER_MAPPING,
  ...ROLE_COUNTERPARTY_MAPPING,
  ...ROLE_EXTERNAL_ACCOUNT_MAPPING,
  ...ROLE_LEDGER_MAPPING,
  ...ACCOUNT_PERMISSIONS_MAPPING,
  ...ROLE_COMPLIANCE_MAPPING,
  ...ROLE_PARTNER_SEARCH_MAPPING,
  ...ROLE_API_KEYS_MAPPING,
};

const NO_ACCOUNT_ACCESS = "accounts:none";
const PARTIAL_ACCOUNT_ACCESS = "accounts:partial";

const isAccountPermission = (permission: string) =>
  permission.startsWith("accounts") && permission.split(":").length > 2;

const getOverallAccountPermission = (
  permission: string,
  permissions: string[],
) => {
  if (permissions?.some(isAccountPermission)) {
    return PARTIAL_ACCOUNT_ACCESS;
  }
  return permission;
};

function getRoleRows(
  currentPermissions: string[],
  proposedPermissions: string[],
) {
  const dataMapping: Record<string, string> = {};
  const rows = Object.keys(TABLE_MAPPING).reduce((acc, permissionType) => {
    let currentPermission =
      currentPermissions.find((p) => p.startsWith(permissionType)) ||
      `${permissionType}:none`;
    let proposedPermission =
      proposedPermissions.find((p) => p.startsWith(permissionType)) ||
      `${permissionType}:none`;

    if (permissionType === "accounts") {
      currentPermission = getOverallAccountPermission(
        currentPermission,
        currentPermissions,
      );
      proposedPermission = getOverallAccountPermission(
        proposedPermission,
        proposedPermissions,
      );
    }

    if (currentPermission === proposedPermission) {
      return acc;
    }

    dataMapping[permissionType] = TABLE_MAPPING[permissionType] as string;

    return {
      ...acc,
      [permissionType]: (
        <div className="flex items-center gap-2">
          <span className="hidden gap-2 mint-2xl:flex mint-2xl:items-center">
            {renderPermission(ROLE_MAPPING[currentPermission])}
            <Icon iconName="arrow_forward" size="s" />
          </span>
          {renderPermission(ROLE_MAPPING[proposedPermission])}
        </div>
      ),
    };
  }, {});
  return [rows, dataMapping];
}

function getPerAccountRows(
  currentPermissions: string[],
  proposedPermissions: string[],
  accounts?: SafeInternalAccount[],
) {
  if (!accounts) {
    return [];
  }
  const currentAccountPermissions =
    currentPermissions.filter(isAccountPermission);
  const proposedAccountPermissions =
    proposedPermissions.filter(isAccountPermission);

  if (!currentAccountPermissions && !proposedAccountPermissions) {
    return [];
  }

  const accountIds = new Set([
    ...currentAccountPermissions.map((acc) => acc.split(":")[2]),
    ...proposedAccountPermissions.map((acc) => acc.split(":")[2]),
  ]);
  const accountMapping = {};
  const accountRows = {};
  accountIds.forEach((id) => {
    const current = currentAccountPermissions.find(
      (acc) => acc.split(":")[2] === id,
    );
    const proposed = proposedAccountPermissions.find(
      (acc) => acc.split(":")[2] === id,
    );

    const currPermission =
      current?.split(":").slice(0, -1).join(":") || NO_ACCOUNT_ACCESS;
    const propPermission =
      proposed?.split(":").slice(0, -1).join(":") || NO_ACCOUNT_ACCESS;

    if (currPermission !== propPermission) {
      const accountName = accounts.find((a) => a.id === id)?.longName;

      accountRows[id] = (
        <div className="flex items-center gap-2">
          <span className="hidden gap-2 mint-2xl:flex mint-2xl:items-center">
            {renderPermission(PER_ACCOUNT_PERMISSIONS_MAPPING[currPermission])}
            <Icon iconName="arrow_forward" size="s" />
          </span>
          {renderPermission(PER_ACCOUNT_PERMISSIONS_MAPPING[propPermission])}
        </div>
      );
      accountMapping[id] = (
        <>
          <div data-tip={accountName}>
            <TruncateString text={accountName} />
          </div>
          <ReactTooltip
            className="break-word max-w-md"
            data-place="top"
            data-effect="float"
            multiline
          />
        </>
      );
    }
  });

  return [accountRows, accountMapping];
}

function AdminApprovalRoleProposedChanges({
  proposedChange,
  group,
  accounts,
}: {
  proposedChange: ProposedChange | undefined;
  group: Group;
  accounts: SafeInternalAccount[] | undefined;
}) {
  const currentPermissions = group?.deprecatedRoles || [];
  const proposedPermissions = proposedChange?.proposedPermissions || [];

  if (!currentPermissions.length && !proposedPermissions.length) {
    return null;
  }

  const [rows, dataMapping] = getRoleRows(
    currentPermissions,
    proposedPermissions,
  );

  const [accountRows, accountMapping] = getPerAccountRows(
    currentPermissions,
    proposedPermissions,
    accounts,
  );

  return (
    <div className="space-y-8">
      {rows && Object.keys(rows).length > 0 && (
        <div className="mt-2">
          <KeyValueTable data={rows} dataMapping={dataMapping} />
        </div>
      )}
      {accountRows && Object.keys(accountRows).length > 0 && (
        <div>
          Per-Account Permissions ({Object.keys(accountRows).length})
          <div className="my-2 max-h-96 overflow-auto rounded border border-
          gray-100 p-4">
            <KeyValueTable data={accountRows} dataMapping={accountMapping} />
          </div>
        </div>
      )}
    </div>
  );
}

export default AdminApprovalRoleProposedChanges;
```

---
## `AdminApprovalRuleProposedChanges.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { ProposedChange } from "~/generated/dashboard/graphqlSchema";
import RuleConditionsList from "./RuleConditionsList";
import RuleApproversList from "./RuleApproversList";

function AdminApprovalRuleProposedChanges({
  proposedChange,
}: {
  proposedChange: ProposedChange;
}) {
  const { proposedName, proposedConditionsArray, proposedRequiredReviewers } =
    proposedChange;
  return (
    <>
      {proposedName && (
        <div className="mb-4 mt-2 font-medium">
          Proposed Name: {proposedName}
        </div>
      )}
      {proposedConditionsArray && proposedConditionsArray.length > 0 && (
        <>
          <div className="mb-2 mt-4 font-medium">Proposed Conditions</div>
          <div className="rounded border border-gray-100 p-6">
            <RuleConditionsList
              allRequiredConditions={proposedConditionsArray}
              operator="or"
            />
          </div>
        </>
      )}
      {proposedRequiredReviewers && proposedRequiredReviewers.length > 0 && (
        <>
          <div className="mb-2 mt-4 font-medium">Proposed Approvers</div>
          <div className="rounded border border-gray-100 p-6">
            <RuleApproversList requiredReviewers={proposedRequiredReviewers} />
          </div>
        </>
      )}
    </>
  );
}

export default AdminApprovalRuleProposedChanges;
```

---
## `AdminFileTransferBatchTotalsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  useAdminFileTransferBatchTotalsQuery,
  BatchTypeEnum,
  BatchSubtotal,
} from "../../generated/dashboard/graphqlSchema";
import {
  IndexTable,
  IndexTableSkeletonLoader,
} from "../../common/ui-components";

const MAPPING = {
  currency: "Currency",
  direction: "Direction",
  amount: "Amount",
  count: "Count",
};

interface FileTransferBatchTotalsViewProps {
  batchId: string;
  batchType: BatchTypeEnum;
  organizationId: string;
}

function formatBatchTotals(batchTotals: BatchSubtotal[]) {
  return batchTotals.map((batchSubtotal: BatchSubtotal) => ({
    ...batchSubtotal,
    count: <> {batchSubtotal.count} </>,
  }));
}

function AdminFileTransferBatchTotalsView({
  batchId,
  batchType,
  organizationId,
}: FileTransferBatchTotalsViewProps) {
  const { loading, data, error } = useAdminFileTransferBatchTotalsQuery({
    skip: !batchId || !batchType,
    variables: { batchId, batchType, organizationId },
  });

  const batchTotals =
    loading || !data || error
      ? []
      : data?.adminFileTransferCalculateBatchTotals;

  return loading || !data ? (
    <div className="mt-4">
      <IndexTableSkeletonLoader headers={Object.keys(MAPPING)} numRows={4} />
    </div>
  ) : (
    <IndexTable data={formatBatchTotals(batchTotals)} dataMapping={MAPPING} />
  );
}

export default AdminFileTransferBatchTotalsView;
```

---
## `AdminFileTransferDetailsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ReactJson from "react-json-view";
import {
  AdminFileTransferDetailsViewQuery,
  useAdminFileTransferDetailsViewQuery,
  useAdminOrganizationViewQuery,
} from "../../generated/dashboard/graphqlSchema";
import {
  CopyableText,
  DateTime,
  Icon,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../common/ui-components";

const MAPPING = {
  id: "ID",
  organization: "Organization",
  fileName: "File Name",
  filePath: "Full Path",
  direction: "Direction",
  fileCreatedAt: "Created At",
  transferredAt: "Transferred At",
  processed: "Processed",
  batchId: "Batch ID",
  batchType: "Batch Type",
  vendorName: "Vendor",
  serviceId: "Service",
  receipt: "Receipt",
  extra: "Extra",
};

interface FileTransferDetailsViewProps {
  fileTransferId: string;
  organizationId: string;
}

function formatFileTransfer(
  fileTransferData: AdminFileTransferDetailsViewQuery["fileTransfer"],
  orgName: string,
): Record<string, unknown> {
  return {
    ...fileTransferData,
    fileCreatedAt: fileTransferData.fileCreatedAt ? (
      <DateTime timestamp={fileTransferData.fileCreatedAt} />
    ) : null,
    transferredAt: fileTransferData.transferredAt ? (
      <DateTime timestamp={fileTransferData.transferredAt} />
    ) : null,
    processed: fileTransferData.processed ? (
      <Icon
        className="text-green-500"
        iconName="checkmark_circle"
        color="currentColor"
      />
    ) : (
      <Icon
        className="text-yellow-300"
        iconName="remove_circle"
        color="currentColor"
      />
    ),
    organization: orgName,
    receipt: fileTransferData.receipt ? (
      <ReactJson
        src={JSON.parse(fileTransferData.receipt) as Record<string, unknown>}
        name={null}
        displayObjectSize={false}
        displayDataTypes={false}
      />
    ) : null,
    extra:
      fileTransferData.extra === "{}" ? (
        fileTransferData.extra
      ) : (
        <ReactJson
          src={JSON.parse(fileTransferData.extra) as Record<string, unknown>}
          name={null}
          displayObjectSize={false}
          displayDataTypes={false}
        />
      ),
    // do the copyable text ourselves, otherwise KeyValueTable will render as a
    link
    fileName: (
      <CopyableText text={fileTransferData.fileName}>
        {fileTransferData.fileName}
      </CopyableText>
    ),
  };
}

function AdminFileTransferDetailsView({
  fileTransferId,
  organizationId,
}: FileTransferDetailsViewProps) {
  const { loading, data } = useAdminFileTransferDetailsViewQuery({
    variables: { fileTransferId, organizationId },
  });
  const { data: orgData, loading: orgLoading } = useAdminOrganizationViewQuery({
    variables: { organizationId },
  });
  const organization = orgData?.organization;
  const fileTransfer = data?.fileTransfer;
  return loading || orgLoading || !fileTransfer || !organization ? (
    <div className="mt-4">
      <KeyValueTableSkeletonLoader dataMapping={MAPPING} />
    </div>
  ) : (
    <KeyValueTable
      key={fileTransferId}
      data={formatFileTransfer(fileTransfer, organization.name)}
      dataMapping={MAPPING}
      copyableData={["id", "filePath", "batchId"]}
    />
  );
}

export default AdminFileTransferDetailsView;
```

---
## `ApprovalBlock.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { startCase } from "lodash";
import moment from "moment-timezone";
import { cn } from "~/common/utilities/cn";
import { Button, Icon, SelectField } from "../../common/ui-components";
import {
  Group,
  User,
  ReviewActionEnum,
  Reviewer,
  RequiredReviewer,
} from "../../generated/dashboard/graphqlSchema";

export enum RuleStatus {
  Pending,
  Approved,
  Denied,
}

export interface RuleInterface {
  id?: string;
  /** When `true`, sets the rule as the active rule needing approvals within the
  rule set. */
  activeRule?: boolean;
  /** Name of the rule */
  name?: string;
  /** Path to the rule */
  path?: string;
  /** States the kind of review required for the block.
   *
   * An example might be "Payment Review Required"
   */
  requiredReviewDescription: string;
  /** Reviewers associated with the given rule */
  reviewers?: Reviewer[];
  /** Required reviewers associated with triggered rule */
  requiredReviewers?: RequiredReviewer[];
}

interface SharedApprovalBlockProps {
  /** Allows you to pass custom styles to the outermost div of the component. */
  className?: string;
  /** Action fired when reviewing as a given group. */
  onReview?: (
    reviewAction: ReviewActionEnum,
    reviewAsGroupId: string | null,
    reviewerId: string | null,
    reviewAsAdminOverride: boolean,
  ) => void;
}

interface ReviewedByProps {
  /** When `true`, the reviewer is an admin override */
  adminOverride?: boolean;
  /** Used with conditional approvers */
  approvalGroupsComponent?: React.ReactNode;
  /** Allows you to pass custom styles to the outermost div of the component. */
  className?: string;
  /** Review action the user reviewed with. */
  reviewAction?: ReviewActionEnum.Approve | ReviewActionEnum.Deny;
  /** Time the reviewer was reviewed at. */
  reviewedAt?: Date;
  /** Group associated with the review. */
  reviewedByGroup?: Group;
  /** Who approved/denied this reviewer. */
  reviewedByUser?: User;
}

/**
 * Renders the approval or denial received from a user.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-
 approvalstimeline-reviewedby--docs)
 */
function ReviewedBy({
  adminOverride = false,
  approvalGroupsComponent,
  className,
  reviewAction,
  reviewedAt,
  reviewedByUser,
  reviewedByGroup,
}: ReviewedByProps) {
  return (
    <div className={cn(className, "align-middle")}>
      <Icon
        alignment="baseline"
        className="mr-2.5 shrink-0 text-gray-400"
        color="currentColor"
        iconName="time_60_s"
        size="s"
      />
      {reviewAction === ReviewActionEnum.Approve ? "Approved" : "Denied"}
      {" by "}
      <Button
        buttonType="link"
        display="inline-block"
        onClick={(): void => {
          window.open(reviewedByUser?.path, "_blank");
        }}
      >
        {reviewedByUser?.name}
      </Button>
      {" as "}
      {adminOverride && !reviewedByGroup ? (
        <span className="font-medium">Admin Override</span>
      ) : (
        <Button
          buttonType="link"
          display="inline-block"
          onClick={(): void => {
            window.open(reviewedByGroup?.path, "_blank");
          }}
        >
          {reviewedByGroup?.name}
        </Button>
      )}
      {approvalGroupsComponent && (
        <span>
          {" to override "}
          {approvalGroupsComponent}
          review
        </span>
      )}
      {" on "}
      {moment(reviewedAt).format("MMMM Do YYYY, h:mm a")}
    </div>
  );
}

interface ApprovalNeededProps extends SharedApprovalBlockProps {
  /** Admin override reviewer, if it exists. */
  adminOverrideReviewer: Reviewer;
  /** Groups the item needs approval from.
   *
   * Uses the `Group` item props to build approval buttons. */
  approvalGroups?: Group[];
  /** A list of `Groups` the user can review as. */
  canReviewAsGroups?: Group[];
  /** When `true`, disables all actions. */
  disableActions?: boolean;
  /** The total number of approvals needed for row.
   *
   * Defaults to 1.
   */
  numberOfApprovals?: number;
  /** Current reviewer id needing approval */
  reviewerId?: string;
}

/**
 * Renders the number of approvals needed and who those approvals are needed
 from.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-
 approvalstimeline-approvalneeded--docs)
 */
function ApprovalNeeded({
  adminOverrideReviewer,
  approvalGroups = [],
  canReviewAsGroups = [],
  className,
  disableActions = false,
  numberOfApprovals = 1,
  onReview,
  reviewerId,
}: ApprovalNeededProps) {
  const [currentApproverId, setCurrentApproverId] = useState(
    canReviewAsGroups.length > 1 || canReviewAsGroups.length === 0
      ? null
      : canReviewAsGroups && canReviewAsGroups[0].id,
  );

  const selectOptions = canReviewAsGroups.map((canReviewAsGroup) => ({
    label: canReviewAsGroup.name,
    value: canReviewAsGroup.id,
  }));

  const approvalGroupsComponent = approvalGroups?.map(
    (approvalGroup, index, array) => {
      const lastElement = array.length - 1 === index;
      return (
        <span key={`approval_groups_${approvalGroup.id}`}>
          <Button
            buttonType="link"
            className={cn("pr-1", !lastElement)}
            display="inline-block"
            onClick={(): void => {
              window.open(approvalGroup?.path, "_blank");
            }}
            disabled={disableActions}
          >
            {approvalGroup?.name}
          </Button>
          {!lastElement && "or "}
        </span>
      );
    },
  );

  if (adminOverrideReviewer) {
    return (
      <ReviewedBy
        adminOverride
        approvalGroupsComponent={approvalGroupsComponent}
        reviewAction={
          adminOverrideReviewer.action === ReviewActionEnum.Approve
            ? ReviewActionEnum.Approve
            : ReviewActionEnum.Deny
        }
        reviewedAt={new Date(adminOverrideReviewer.actionTime as string)}
        reviewedByUser={adminOverrideReviewer.user as User}
      />
    );
  }
  return (
    <div className={cn("flex flex-col gap-2", className)}>
      <div>
        <Icon
          alignment="baseline"
          className="mr-2.5 shrink-0 text-gray-400"
          color="currentColor"
          iconName="time_40_s"
          size="s"
        />
        {numberOfApprovals} {numberOfApprovals > 1 ? "Approvals" : "Approval"}{"
        "}
        needed from {approvalGroupsComponent}
      </div>
      {canReviewAsGroups.length > 0 && (
        <div className="ml-7 flex flex-col gap-2">
          {canReviewAsGroups.length > 1 && (
            <SelectField
              name="multiRoleApproverSelect"
              selectValue={currentApproverId}
              options={selectOptions}
              handleChange={(value: string) => {
                setCurrentApproverId(value);
              }}
              placeholder="Select a role to make this approval from"
            />
          )}
          <div className="flex w-full flex-row gap-2">
            {[ReviewActionEnum.Approve, ReviewActionEnum.Deny].map((action) => (
              <Button
                buttonType="secondary"
                disabled={!currentApproverId || disableActions}
                fullWidth
                onClick={() => {
                  onReview?.(
                    action,
                    currentApproverId as string,
                    reviewerId as string,
                    false, // reviewAsAdminOverride
                  );
                }}
              >
                {startCase(action)}
              </Button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

export function ruleStatus(
  reviewers: Reviewer[],
  adminOverrideReviewer?: Reviewer,
): RuleStatus {
  const actions = reviewers
    .filter((reviewer) => reviewer.action !== ReviewActionEnum.Create)
    .map((reviewer) => reviewer.action) as ReviewActionEnum[];

  if (actions.length === 0) {
    return RuleStatus.Pending;
  }

  if (
    actions.every((action) => action === ReviewActionEnum.Approve) ||
    adminOverrideReviewer?.action === ReviewActionEnum.Approve
  ) {
    return RuleStatus.Approved;
  }

  if (
    actions.includes(ReviewActionEnum.Deny) ||
    adminOverrideReviewer?.action === ReviewActionEnum.Deny
  ) {
    return RuleStatus.Denied;
  }

  return RuleStatus.Pending;
}

function renderIcon(reviewers: Reviewer[], adminOverrideReviewer?: Reviewer) {
  const currentRuleStatus = ruleStatus(reviewers, adminOverrideReviewer);

  switch (currentRuleStatus) {
    case RuleStatus.Pending:
      return (
        <Icon
          className="mr-2 shrink-0 text-orange-300"
          color="currentColor"
          iconName="error_outlined"
        />
      );
    case RuleStatus.Approved:
      return (
        <Icon
          className="mr-2 shrink-0 text-green-500"
          color="currentColor"
          iconName="checkmark_circle"
        />
      );
    case RuleStatus.Denied:
      return (
        <Icon
          className="mr-2 shrink-0 text-red-500"
          color="currentColor"
          iconName="clear_circle"
        />
      );
    default:
      return (
        <Icon
          className="mr-2 shrink-0 text-orange-300"
          color="currentColor"
          iconName="error_outlined"
        />
      );
  }
}

interface ApprovalBlockProps extends SharedApprovalBlockProps {
  /** Admin override reviewer, if it exists. */
  adminOverrideReviewer?: ApprovalNeededProps["adminOverrideReviewer"];
  /** When `true`, disables all actions. */
  disableActions?: ApprovalNeededProps["disableActions"];
  /** When `true`, shows any review actions the user can take and reviews that
  have already occurred. */
  renderReviewerDetails?: boolean;
  /** Rules triggered within the block.
   *
   * Each rule can have multiple approvals needed, or reviews already received.
   *
   * If there is more than one rule triggered, it will display the rules
   triggered in the order they exist in the array.
   */
  rules: RuleInterface[];
}

/**
 * Renders a block of approvals needed associated to a rule.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/app-
 approvalstimeline-approvalblock--docs)
 */
function ApprovalBlock({
  adminOverrideReviewer,
  children,
  className,
  disableActions = false,
  onReview,
  renderReviewerDetails,
  rules,
}: React.PropsWithChildren<ApprovalBlockProps>) {
  return (
    <div
      className={cn(
        "border-b border-gray-50 px-4 py-3 last:border-0",
        className,
      )}
    >
      {rules?.map((rule, index) => (
        <div
          key={`approval_rule_row_${rule.id || rule.name || index}`}
          className="flex flex-col gap-3 pb-3 last:pb-0"
        >
          <div className="flex flex-row">
            {rules.length > 1 ? (
              <div
                className={cn(
                  "mr-2 mt-0.5 flex h-4 w-4 items-center justify-center rounded-
                  full text-[10px] text-white",
                  rule.activeRule ? "bg-orange-300" : "bg-gray-400",
                )}
              >
                {index + 1}
              </div>
            ) : (
              renderIcon(rule.reviewers || [], adminOverrideReviewer)
            )}
            <div className="font-medium">
              {rule.requiredReviewDescription}
              {rule.path && (
                <>
                  {", "}
                  <Button
                    buttonType="link"
                    className="break-word !items-start !whitespace-normal text-
                    left"
                    display="inline-block"
                    onClick={(): void => {
                      window.open(rule.path, "_blank");
                    }}
                  >
                    {rule.name}
                  </Button>
                </>
              )}
            </div>
          </div>
          <div
            className={cn(
              "ml-2 pl-5",
              rules.length > 1 && "border-l border-gray-50",
            )}
          >
            {renderReviewerDetails && (
              <div className="flex flex-col gap-3">
                {rule.reviewers
                  ? rule.reviewers?.map((reviewer) => {
                      switch (reviewer.action) {
                        case ReviewActionEnum.Pending:
                        case ReviewActionEnum.Future:
                          return (
                            <ApprovalNeeded
                              key={`${reviewer.action}_${reviewer.id}`}
                              adminOverrideReviewer={
                                adminOverrideReviewer as Reviewer
                              }
                              approvalGroups={reviewer.groups as Group[]}
                              canReviewAsGroups={reviewer.canReviewAsGroups}
                              onReview={onReview}
                              disableActions={disableActions}
                              reviewerId={reviewer.id}
                            />
                          );
                        case ReviewActionEnum.Approve:
                        case ReviewActionEnum.Deny:
                          return (
                            <ReviewedBy
                              key={`${reviewer.action}_${reviewer.id}`}
                              reviewAction={
                                reviewer.action === ReviewActionEnum.Approve
                                  ? ReviewActionEnum.Approve
                                  : ReviewActionEnum.Deny
                              }
                              reviewedAt={
                                new Date(reviewer.actionTime as string)
                              }
                              reviewedByGroup={reviewer.group as Group}
                              reviewedByUser={reviewer.user as User}
                            />
                          );
                        default:
                          return null;
                      }
                    })
                  : rule.requiredReviewers &&
                    rule.requiredReviewers.map((requiredReviewer) => (
                      <ApprovalNeeded
                        approvalGroups={requiredReviewer.conditionalGroups}
                        numberOfApprovals={requiredReviewer.numberOfReviewers}
                        adminOverrideReviewer={
                          adminOverrideReviewer as Reviewer
                        }
                      />
                    ))}
              </div>
            )}
            {children}
          </div>
        </div>
      ))}
    </div>
  );
}

interface AdminOverrideApprovalBlockProps extends SharedApprovalBlockProps {
  /** When `true`, disables buttons */
  disableActions?: boolean;
}

function AdminOverrideApprovalBlock({
  className,
  disableActions,
  onReview,
}: AdminOverrideApprovalBlockProps) {
  return (
    <ApprovalBlock
      className={className}
      renderReviewerDetails
      rules={[
        {
          activeRule: true,
          requiredReviewDescription: "Admin Override",
        },
      ]}
    >
      <div className="mb-4">
        As an admin, you can override required approvals for this payment order.
      </div>
      <div className="flex w-full flex-row gap-2 text-red-400">
        {[ReviewActionEnum.Approve, ReviewActionEnum.Deny].map((action) => (
          <Button
            key={action}
            buttonType="secondary"
            fullWidth
            onClick={() => {
              onReview?.(
                action,
                null, // reviewAsGroupId
                null, // reviewerId
                true, // reviewAsAdminOverride
              );
            }}
            disabled={disableActions}
          >
            {startCase(action)}
          </Button>
        ))}
      </div>
    </ApprovalBlock>
  );
}

interface RulesListProps {
  className?: string;
}

/**
 * Renders a list of rules with appropriate spacing.
 */
function RulesList({
  children,
  className,
}: React.PropsWithChildren<RulesListProps>) {
  return (
    <div className={cn("flex flex-col gap-y-2", className)}>{children}</div>
  );
}

export {
  ApprovalNeeded,
  ApprovalNeededProps,
  ApprovalBlock,
  ApprovalBlockProps,
  ReviewedBy,
  ReviewedByProps,
  AdminOverrideApprovalBlock,
  AdminOverrideApprovalBlockProps,
  RulesList,
  RulesListProps,
};
```

---
## `ApprovalsScopeSelector.tsx.txt`
**Path:** `.`  
```
import React, { useCallback, useMemo } from "react";
import ReduxSelectBar from "../../common/deprecated_redux/ReduxSelectBar";
import { parse, stringify } from "../../common/utilities/queryString";
import { useMountEffect } from "../../common/utilities/useMountEffect";

export enum ReviewerScope {
  PendingMyApproval = "pending_my_approval",
  ViewAll = "view_all",
}

const REVIEWER_OPTIONS = [
  { value: ReviewerScope.PendingMyApproval, text: "Pending My Approval" },
  { value: ReviewerScope.ViewAll, text: "View All" },
];

interface ApprovalsScopeSelectorProps {
  scopeByPendingMyApproval?: boolean | null;
  onReviewerScopeChange: (scopeByPendingMyApproval: boolean | null) => void;
}

function ApprovalsScopeSelector({
  scopeByPendingMyApproval,
  onReviewerScopeChange,
}: ApprovalsScopeSelectorProps): JSX.Element {
  const reviewerScope = useMemo((): ReviewerScope => {
    if (scopeByPendingMyApproval) {
      return ReviewerScope.PendingMyApproval;
    }

    return ReviewerScope.ViewAll;
  }, [scopeByPendingMyApproval]);

  const onSelect = useCallback(
    (scope: ReviewerScope): void => {
      let scopeByPendingMyApprovalValue: boolean | null;

      if (scope === ReviewerScope.PendingMyApproval) {
        scopeByPendingMyApprovalValue = true;
      } else {
        scopeByPendingMyApprovalValue = null;
      }

      const parsedQueryString = parse(window.location.search);

      const newQuery = {
        ...parsedQueryString,
        status: "needs_approval",
        scopeByPendingMyApproval: scopeByPendingMyApprovalValue,
      };

      window.history.replaceState(null, "", `?${stringify(newQuery)}`);

      onReviewerScopeChange(scopeByPendingMyApprovalValue);
    },
    [onReviewerScopeChange],
  );

  useMountEffect((): void => {
    const { scopeByPendingMyApproval: initialScopeByPendingMyApproval } = parse(
      window.location.search,
    );

    // Run once on initial render if neither param is included
    // This helps backwards compatability with MCB Mailers
    if (initialScopeByPendingMyApproval === undefined) {
      onSelect(ReviewerScope.PendingMyApproval);
    }
  });

  return (
    <div className="max-w-lg">
      <ReduxSelectBar
        required
        selectOptions={REVIEWER_OPTIONS}
        input={{
          onChange: onSelect,
          value: reviewerScope,
          name: "reviewer-search",
        }}
      />
    </div>
  );
}

export default ApprovalsScopeSelector;
```

---
## `AsOfDateButton.tsx.txt`
**Path:** `.`  
```
import React, { forwardRef, Ref } from "react";
import moment from "moment-timezone";
import { Button, Icon } from "../../common/ui-components";

const asOfButton = forwardRef(
  (
    { value, onClick }: { value: string; onClick: () => void },
    ref: Ref<HTMLButtonElement>,
  ) => (
    <Button onClick={onClick} ref={ref}>
      <div className="flex h-4 self-center">
        <Icon
          className="text-gray-600"
          iconName="calendar_month"
          color="currentColor"
        />
      </div>
      <span className="font-medium">
        Balances as of {moment(value).format("YYYY-MM-DD")}
      </span>
    </Button>
  ),
);

export default asOfButton;
```

---
## `AuditActorSearch.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { OrganizationUser } from "../../generated/dashboard/graphqlSchema";
import ApiKeySelect, { ALL_API_KEYS_ID } from "../containers/ApiKeySelect";
import UserGroupSelect from "./UserGroupSelect";

const USER = "User";
const API_KEY = "APIKey";

interface AuditActorSearchProps {
  updateQuery: (input: Query) => void;
  field: string;
  query: Query;
  actor: Record<string, string>;
  disabled?: boolean;
}

function AuditActorSearch({
  updateQuery,
  field,
  query,
  actor,
  disabled = false,
}: AuditActorSearchProps) {
  const labelField = (query.userGroupSelectedLabel ||
    query.user_group_selected_label) as string;
  const resetQuery = () =>
    updateQuery({
      [field]: undefined,
      actor_type: undefined,
      userGroupSelectedLabel: undefined,
    });

  const updateUserGroup = (value?: OrganizationUser) => {
    if (value?.user.id) {
      updateQuery({
        [field]: value.user.id,
        actor_type: USER,
        userGroupSelectedLabel: `${value.user.name ?? ""} (${
          value.user.email
        })`,
      });
    } else resetQuery();
  };

  const updateApiKey = (value: string) => {
    if (value !== ALL_API_KEYS_ID) {
      updateQuery({ [field]: value, actor_type: API_KEY });
    } else resetQuery();
  };

  const currentUserId = () => (actor.actorType === USER ? actor.actorId : null);
  const currentApiKeyId = () =>
    actor.actorType === API_KEY ? actor.actorId : null;

  const userId = currentUserId();
  const selectValue =
    userId && labelField
      ? { value: { user: { id: userId } }, label: labelField }
      : undefined;

  return (
    <>
      <ApiKeySelect
        overrideOnApiKeySelect={updateApiKey}
        overrideCurrentApiKeyId={currentApiKeyId()}
        hideLabel={false}
        disabled={disabled}
      />
      <UserGroupSelect
        onChange={updateUserGroup}
        selectValue={selectValue}
        label="User"
        disabled={disabled}
      />
    </>
  );
}

export default AuditActorSearch;
```

---
## `AuditRecordsHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { useAuditRecordsHomeQuery } from
"../../generated/dashboard/graphqlSchema";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import { DateTime } from "../../common/ui-components";
import { ExportDataParams } from "./ExportDataButton";
import AuditRecordView from "../containers/AuditRecordView";
import { AUDIT_RECORD } from "../../generated/dashboard/types/resources";
import ArchivedRecordsBanner from "./exporting/ArchivedRecordsBanner";
import { useReadLiveMode } from "~/common/utilities/useReadLiveMode";

interface AuditRecordsHomeProps {
  title?: string;
  hideHeadline?: boolean;
  showIP?: boolean;
  hideSource?: boolean;
  hideLinks?: boolean;
  showDisabledPagination?: boolean;
  perPage?: number;
  queryArgs: {
    entityId?: string;
    entityType?: string;
    actorId?: string;
    actorType?: string;
    eventName?: string;
    includeAssociations?: boolean;
    includeAdminActions?: boolean;
  };
}

function AuditRecordsHome({
  title,
  hideHeadline,
  showIP,
  hideSource,
  hideLinks,
  showDisabledPagination = true,
  perPage,
  queryArgs,
}: AuditRecordsHomeProps) {
  const isLiveMode = useReadLiveMode();
  const { loading, data, error, refetch } = useAuditRecordsHomeQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: perPage ?? INITIAL_PAGINATION.perPage,
      ...queryArgs,
    },
  });

  const exportDataParams: ExportDataParams = {
    params: {
      entity_id: queryArgs.entityId,
      entity_type: queryArgs.entityType,
      actor_id: queryArgs.actorId,
      actor_type: queryArgs.actorType,
      event_name: queryArgs.eventName,
    },
  };

  const auditRecords =
    loading || !data || error
      ? []
      : data.auditRecords.edges.map(({ node }) => ({
          ...node,
          source: node.actorName,
          eventTime: <DateTime timestamp={node.eventTime} />,
        }));

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
  }) => {
    const { cursorPaginationParams } = options;
    await refetch({
      ...cursorPaginationParams,
    });
  };

  return (
    <div>
      {!loading && data?.relatedRecordsAreArchived && (
        <ArchivedRecordsBanner
          className="mb-4"
          liveMode={isLiveMode}
          resourceType="AuditRecord"
        />
      )}
      <EntityTableView
        data={auditRecords}
        title={hideHeadline ? undefined : title ?? "Audit Trail"}
        dataMapping={{
          prettyEventName: "Event",
          eventTime: "Time",
          ...(hideSource ? {} : { source: "Source" }),
          ...(showIP
            ? { ipAddress: "IP Address", geoLocation: "Location" }
            : {}),
        }}
        loading={loading}
        onQueryArgChange={handleRefetch}
        cursorPagination={data?.auditRecords?.pageInfo}
        defaultPerPage={perPage}
        showDisabledPagination={showDisabledPagination}
        resource={AUDIT_RECORD}
        enableExportData={!hideLinks && !data?.relatedRecordsAreArchived}
        exportDataParams={exportDataParams}
        renderDrawerContent={(_, id) => (
          <AuditRecordView
            match={{
              params: {
                auditRecordId: id,
              },
            }}
          />
        )}
        disableMetadata
      />
    </div>
  );
}

export default AuditRecordsHome;
```

---
## `BillingContactSelect.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import Select from "react-select";
import { EMAIL_REGEX } from "../constants";
import { BillingUser, User } from "../../generated/dashboard/graphqlSchema";
import { useDispatchContext } from "../MessageProvider";

type BillingContactSelectProps = {
  onChange: (email: string) => void;
  users: Pick<User, "name" | "email">[];
  billingContacts: BillingUser[];
};

const noMatchingUser = (
  users: Pick<User, "name" | "email">[],
  inputValue: string,
) =>
  inputValue &&
  users.every(
    ({ name }) =>
      !(name ?? "").toLowerCase().includes(inputValue.toLowerCase()),
  );

function BillingContactSelect({
  onChange,
  users = [],
  billingContacts = [],
}: BillingContactSelectProps) {
  const [inputValue, setInputValue] = useState("");

  const { dispatchError, dispatchClearMessage } = useDispatchContext();

  const billingEmails = billingContacts.map(({ email }) => email);

  const handleInputChange = (newValue: string) => {
    const cleanedValue = newValue.replace(/,/g, "");
    setInputValue(cleanedValue);
  };

  const handleChange = ({
    value: selectedEmail,
  }: {
    value: string;
    label: string;
  }) => {
    if (!EMAIL_REGEX.test(selectedEmail)) {
      dispatchError("Please select a user or enter a valid email");
      setTimeout(() => dispatchClearMessage, 3000);
      return;
    }
    onChange(selectedEmail);
  };

  let options = users
    .map(({ email, name }) => ({ value: email, label: name }))
    .filter(({ value }) => !billingEmails.includes(value));

  if (options.length === 0 || noMatchingUser(users, inputValue)) {
    options = [{ label: `+ Add ${inputValue}`, value: inputValue }];
  }
  return (
    <div className="w-72">
      <Select
        placeholder="Search users or add email..."
        onInputChange={handleInputChange}
        value={inputValue}
        options={options}
        onChange={(selectedOption: { value: string; label: string }) =>
          handleChange(selectedOption)
        }
      />
    </div>
  );
}

export default BillingContactSelect;
```

---
## `BillingUsageBarChart.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import moment from "moment-timezone";
import colors from "../../common/styles/colors";
import {
  SelectField,
  DateRangeFormValues,
  BarChart,
  MTContainer,
} from "../../common/ui-components";
import abbreviateAmount from "../../common/utilities/abbreviateAmount";
import {
  BillingMetricNameEnum,
  TimeUnitEnum,
  useDailyBillingMetricsQuery,
} from "../../generated/dashboard/graphqlSchema";
import ChartView from "../../common/ui-components/Charts/ChartView";
import DateSearch, {
  dateSearchMapper,
  DATE_SEARCH_FILTER_OPTIONS,
} from "./search/DateSearch";

type Option = {
  value: BillingMetricNameEnum;
  label: string;
  unit: BillingMetricUnit;
};

enum BillingMetricUnit {
  Dollar = "dollar",
  Count = "count",
}

type QueryFilter = {
  dateRange: DateRangeFormValues;
  metricName: BillingMetricNameEnum;
};

const BILLING_METRICS: Array<Option> = [
  {
    label: "Reconciled Payment Volume",
    value: BillingMetricNameEnum.ReconciledPaymentVolume,
    unit: BillingMetricUnit.Dollar,
  },
  {
    label: "Reconciled Payment Count",
    value: BillingMetricNameEnum.ReconciledPaymentCount,
    unit: BillingMetricUnit.Count,
  },
  {
    label: "Reconciled Virtual Account Transaction Volume",
    value: BillingMetricNameEnum.ReconciledVirtualAccountTransactionVolume,
    unit: BillingMetricUnit.Dollar,
  },
  {
    label: "Reconciled Virtual Account Transaction Count",
    value: BillingMetricNameEnum.ReconciledVirtualAccountTransactionCount,
    unit: BillingMetricUnit.Count,
  },
  {
    label: "Lob Check Count",
    value: BillingMetricNameEnum.LobCheckCount,
    unit: BillingMetricUnit.Count,
  },
];

const DOWNLOAD_FILE_NAME_PREFIX = "Billing_Usage_Bar_Chart";
const FILTER_WIDTH = "w-48";
const MIN_HEIGHT = "min-h-[350px]";

const CHART_FORMAT = {
  fontSize: "11px",
  lineHeight: "22",
  color: colors.gray[700],
  fill: colors.gray[700],
};

const tickFormatter = (value: number, billingMetricUnit: BillingMetricUnit) =>
  billingMetricUnit === BillingMetricUnit.Dollar
    ? abbreviateAmount(value, "USD")
    : value;

function tooltipFormatter(value: number, billingMetricUnit: BillingMetricUnit) {
  if (billingMetricUnit === BillingMetricUnit.Dollar)
    return [
      Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
      }).format(value),
    ];
  return [value];
}

function BillingUsageBarChart() {
  const initialBillingMetric = BILLING_METRICS[0];
  const [selectedBillingMetric, setBillingMetric] =
    useState<Option>(initialBillingMetric);
  const [query, setQuery] = useState<QueryFilter>({
    dateRange: {
      inTheLast: { unit: TimeUnitEnum.Months, amount: "1" },
    },
    metricName: initialBillingMetric.value,
  });

  const { loading, data, error, refetch } = useDailyBillingMetricsQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      dateRange: {
        inTheLast: { unit: TimeUnitEnum.Months, amount: 1 },
      },
      metricName: initialBillingMetric.value,
    },
  });

  const handleRefetch = async (newQuery: QueryFilter) => {
    await refetch({
      metricName: newQuery.metricName,
      dateRange: dateSearchMapper(newQuery.dateRange),
    });
    setQuery(newQuery);
  };

  const onOptionChange = async (newOption: Option) => {
    if (selectedBillingMetric.value !== newOption.value) {
      await handleRefetch({
        ...query,
        metricName: newOption.value,
      });
    }
    setBillingMetric(newOption);
  };

  const searchComponents = [
    {
      field: "dateRange",
      options: DATE_SEARCH_FILTER_OPTIONS,
      component: DateSearch,
      validateRange: true,
      isSearchable: false,
      placeholder: "Past Month",
      query,
      updateQuery: (input: Record<string, DateRangeFormValues>) =>
        handleRefetch({ ...query, dateRange: input.dateRange }),
    },
    {
      options: BILLING_METRICS,
      component: SelectField,
      selectValue: selectedBillingMetric.value,
      isSearchable: false,
      handleChange: (_, newOption: Option) => onOptionChange(newOption),
    },
  ];

  const dailyBillingMetrics: { name: string; metricValue: number }[] =
    loading || !data || error
      ? []
      : data.dailyBillingMetrics.map((billingMetric) => ({
          name: moment(billingMetric.date).format("M/D"),
          metricValue: billingMetric.metricValue,
        }));

  return (
    <MTContainer header="Billing Usage Chart" headerSize="l">
      <span className="text-xs text-gray-500">
        Show various billing metrics for a customer. It will list all metrics
        regardless of whether the customer is billed by the metric. This chart
        is currently only accessible by MT admins.
      </span>

      <ChartView
        title={`Billing Usage for ${selectedBillingMetric.label}`}
        loaderNumberOfBars={12}
        loading={loading}
        minHeightClass={MIN_HEIGHT}
        fileNamePrefix={DOWNLOAD_FILE_NAME_PREFIX}
        filterWidthClass={FILTER_WIDTH}
        searchComponents={searchComponents}
        hasChartOptions
      >
        <BarChart
          xAxisProps={{
            stroke: colors.gray[200],
            tickLine: {
              color: colors.gray[200],
            },
            tick: {
              ...CHART_FORMAT,
              fontSize: "10px",
            },
            tickSize: 12,
            tickMargin: 12,
            axisLine: false,
          }}
          yAxisProps={{
            stroke: colors.gray[200],
            tickLine: {
              color: colors.gray[200],
            },
            tickMargin: 10,
            axisLine: false,
            interval: "preserveEnd",
            tickFormatter: (value: number) =>
              tickFormatter(value, selectedBillingMetric.unit),
          }}
          excludeLegend
          tooltipProps={{
            cursor: false,
            contentStyle: {
              ...CHART_FORMAT,
            },
            itemStyle: {
              lineHeight: "22px",
              fontSize: "12px",
              padding: "0",
            },

            formatter: (value: number) =>
              tooltipFormatter(value, selectedBillingMetric.unit),
            labelFormatter: (x: string) => moment(x).format("MMM Do"),
            labelStyle: {
              lineHeight: "22px",
              fontSize: "12px",
              padding: "0",
            },
          }}
          data={dailyBillingMetrics}
          lines={[
            {
              key: "metricValue",
              dataKey: "metricValue",
              stroke: colors.green[600],
              fill: colors.green[600],
              type: "linear",
            },
          ]}
        />
      </ChartView>
    </MTContainer>
  );
}

export default BillingUsageBarChart;
```

---
## `BooleanReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { SelectField } from "~/common/ui-components";

interface BooleanReconciliationMatchResultProps {
  selectField: string;
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

function BooleanReconciliationMatchResult({
  selectField,
  selectFieldOptions,
  callback,
}: BooleanReconciliationMatchResultProps) {
  return (
    <div className="min-w-36">
      <SelectField
        className="justify-left flex"
        handleChange={(e) => {
          if (e === "Is True") {
            callback(e as string, "true", null, null, null, null, null);
          } else if (e === "Is False") {
            callback(e as string, "false", null, null, null, null, null);
          } else {
            callback(e as string, "", null, null, null, null, null);
          }
        }}
        id="select-id"
        name="select-name"
        selectValue={selectField}
        options={selectFieldOptions}
      />
    </div>
  );
}

export default BooleanReconciliationMatchResult;
```

---
## `BulkImportDetailsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { capitalize, startCase } from "lodash";
import ReactTooltip from "react-tooltip";
import { MutationFunction } from "@apollo/client/react/types/types";
import {
  BulkImportViewQuery,
  useBulkImportViewQuery,
  useCalculatePaymentOrderTotalsQuery,
  useCreateDownloadAuditRecordMutation,
  Exact,
  CreateDownloadAuditRecordMutation,
  CreateDownloadAuditRecordInput,
} from "../../generated/dashboard/graphqlSchema"; // Rename this query for this
view
import formatDate from "../../common/utilities/formatDate";
import {
  DateTime,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
  Tooltip,
} from "../../common/ui-components";

const MAPPING = {
  id: "ID",
  createdAt: "Created At",
  resourceType: "Resource",
  liveMode: "Live Mode",
  status: "Status",
  createdBy: "Uploaded By",
  resourceCount: "Total Created Resources",
  csvDownload: "CSV",
};

interface CurrencyTotalType {
  amount: string;
  currency: string;
  direction;
  string;
}

type CustomBulkImportType = Pick<BulkImportViewQuery, "bulkImport"> & {
  createdAt: JSX.Element;
  liveMode: string;
  createdBy: JSX.Element;
  status: string;
  resourceType: string;
  resourceCount: React.ReactNode;
  csvDownload: JSX.Element;
};

function csvDownloadFormat(
  bulkImportData: NonNullable<BulkImportViewQuery["bulkImport"]>,
  createDownloadAuditRecord: MutationFunction<
    CreateDownloadAuditRecordMutation,
    Exact<{
      input: CreateDownloadAuditRecordInput;
    }>
  >,
) {
  if (bulkImportData.fileUrl && bulkImportData.filename) {
    return (
      <a
        onClick={() => {
          void createDownloadAuditRecord({
            variables: { input: { id: bulkImportData.id } },
          });
        }}
        href={bulkImportData.fileUrl}
        download
      >
        {bulkImportData.filename}
      </a>
    );
  }
  if (bulkImportData.filename && !bulkImportData.fileUrl) {
    return (
      <>
        {bulkImportData.filename}
        <ReactTooltip
          multiline
          id="csv"
          data-place="top"
          data-type="dark"
          data-effect="float"
        />
        <Tooltip
          className="ml-1"
          data-for="csv"
          data-tip="You don't have permission to download"
        />
      </>
    );
  }
  return (
    <>
      <span>Unavailable</span>
      <ReactTooltip
        multiline
        id="download"
        data-place="top"
        data-type="dark"
        data-effect="float"
      />
      <Tooltip
        className="ml-1"
        data-for="download"
        data-tip="Check back later"
      />
    </>
  );
}

function buildPaymentOrderTotals(
  currencyTotals: CurrencyTotalType[],
  showCalculationTotal,
) {
  return showCalculationTotal ? (
    <div className="row-value">
      {currencyTotals.map(({ amount, currency, direction }) => (
        <>
          <div>
            {capitalize(direction as string)}
            &nbsp;
            {amount}
            &nbsp;
            <b>{currency}</b>
          </div>
          <br />
        </>
      ))}
    </div>
  ) : (
    <>
      <span>Insufficient Permissions</span>
      <ReactTooltip
        multiline
        id="resources"
        data-place="top"
        data-type="dark"
        data-effect="float"
      />
      <Tooltip
        className="ml-1"
        data-for="resources"
        data-tip="You must have permissions to view all payment orders to see
        totals."
      />
    </>
  );
}

function formatBulkImport(
  bulkImportData: NonNullable<BulkImportViewQuery["bulkImport"]>,
  currencyTotals: CurrencyTotalType[],
  entitiesDate: string,
  totalsLoaded,
  showCalculationTotal,
  createDownloadAuditRecord: MutationFunction<
    CreateDownloadAuditRecordMutation,
    Exact<{
      input: CreateDownloadAuditRecordInput;
    }>
  >,
): Record<string, unknown> {
  return {
    ...bulkImportData,
    createdAt: <DateTime timestamp={bulkImportData.createdAt} />,
    liveMode: bulkImportData.liveMode ? "True" : "False",
    createdBy: (
      <a href={`/settings/users/${bulkImportData.userId ?? ""}/edit`}>
        {bulkImportData.user.name}
      </a>
    ),
    status: bulkImportData.prettyStatus,
    resourceType: startCase(bulkImportData.prettyResourceType),
    resourceCount:
      bulkImportData.resourceCount === 0 &&
      new Date(bulkImportData.createdAt) <= new Date(entitiesDate) ? (
        <>
          <span>Unknown</span>
          <ReactTooltip
            multiline
            id="resources"
            data-place="top"
            data-type="dark"
            data-effect="float"
          />
          <Tooltip
            className="ml-1"
            data-for="resources"
            data-tip={`Unable to determine resources created for imports before
            ${
              formatDate(new Date(entitiesDate)) ?? ""
            }`}
          />
        </>
      ) : (
        bulkImportData.resourceCount
      ),
    csvDownload: csvDownloadFormat(bulkImportData, createDownloadAuditRecord),
    ...(totalsLoaded &&
      bulkImportData.resourceType === "PaymentOrder" && {
        totalAmounts: buildPaymentOrderTotals(
          currencyTotals,
          showCalculationTotal,
        ),
      }),
  } as CustomBulkImportType;
}

interface BulkImportDetailsViewProps {
  bulkImportId: string;
  entitiesDate: string;
  showCalculationTotal: boolean;
}

function BulkImportDetailsView({
  bulkImportId,
  entitiesDate,
  showCalculationTotal,
}: BulkImportDetailsViewProps) {
  const { loading, data } = useBulkImportViewQuery({
    variables: { id: bulkImportId },
  });
  const bulkImport = data?.bulkImport;
  const [createDownloadAuditRecord] = useCreateDownloadAuditRecordMutation();
  const {
    data: calcData,
    loading: calcLoading,
    error: calcError,
  } = useCalculatePaymentOrderTotalsQuery({
    notifyOnNetworkStatusChange: true,
    variables: { bulkImportId },
  });
  const currencyTotals =
    calcLoading || !calcData || calcError
      ? []
      : (calcData.calculatePaymentOrderTotals
          .prettyTotals as CurrencyTotalType[]);

  const bulkImportLoaded = !!(!loading && bulkImport);
  const totalsLoaded = !!(
    !calcLoading &&
    calcData &&
    calcData.calculatePaymentOrderTotals.paymentOrdersTotalCount !== 0
  );

  return (
    <div className="mt-4">
      {bulkImportLoaded ? (
        <KeyValueTable
          data={formatBulkImport(
            bulkImport,
            currencyTotals,
            entitiesDate,
            showCalculationTotal,
            totalsLoaded,
            createDownloadAuditRecord,
          )}
          dataMapping={{
            ...MAPPING,
            ...(bulkImport.resourceType === "PaymentOrder" &&
              totalsLoaded && { totalAmounts: "Total Payment Amounts" }),
          }}
        />
      ) : (
        <KeyValueTableSkeletonLoader dataMapping={MAPPING} />
      )}
    </div>
  );
}

export default BulkImportDetailsView;
```

---
## `BulkImportExpectedPaymentsButton.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { useFlatfileSpaceAccessTokenQuery } from
"~/generated/dashboard/graphqlSchema";
import { expectedPaymentBlueprintFields } from
"./bulk_imports/blueprints/expectedPaymentBlueprint";
import FlatfileBulkUploadButton, {
  BulkResourceType,
} from "./FlatfileBulkUploadButton";

export interface BulkImportTransactionsButtonProps {
  spaceId: string;
}

function BulkImportTransactionsButton({
  spaceId,
}: BulkImportTransactionsButtonProps): JSX.Element {
  const result = useFlatfileSpaceAccessTokenQuery({
    variables: {
      spaceId,
    },
  });

  return (
    <FlatfileBulkUploadButton
      accessToken={result.data?.flatfileSpace}
      expectedFields={expectedPaymentBlueprintFields}
      spaceId={spaceId}
      resource={BulkResourceType.ExpectedPayments}
    />
  );
}
export default BulkImportTransactionsButton;
```

---
## `BulkImportHeader.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Property as FlatfileProperty,
  CreateWorkbookConfig,
  CellValueUnion,
} from "@flatfile/api/api";
import { Button, Heading } from "../../common/ui-components";
import { BulkValidationError } from "../../generated/dashboard/graphqlSchema";
import FlatfileBulkUploadButton, {
  BulkResourceType,
} from "./FlatfileBulkUploadButton";
import { downloadCsvTemplate } from "../utilities/downloadCsvTemplate";

interface BulkImportHeaderProps {
  bulkImportType: string;
  submit: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => Promise<Record<string, string | boolean>>;
  validate: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => Promise<Array<BulkValidationError> | undefined | null>;
  expectedFields: FlatfileProperty[];
  blueprint: Pick<
    CreateWorkbookConfig,
    "name" | "labels" | "sheets" | "actions"
  >;
  resource: BulkResourceType;
}

function BulkImportHeader({
  bulkImportType,
  submit,
  validate,
  expectedFields,
  blueprint,
  resource,
}: BulkImportHeaderProps) {
  let bulkImportTypeText = "";
  let bulkImportHelpLink = "";

  switch (bulkImportType) {
    case "Expected Payment":
      bulkImportTypeText = "Expected Payments";
      bulkImportHelpLink =
        "https://docs.moderntreasury.com/reconciliation/docs/create-expected-
        payments-in-bulk";
      break;
    case "Payment Order":
      bulkImportTypeText = "Payment Orders";
      bulkImportHelpLink =
        "https://docs.moderntreasury.com/payments/docs/create-payment-orders-in-
        bulk";
      break;
    case "Counterparty":
      bulkImportTypeText = "Counterparties";
      bulkImportHelpLink =
        "https://docs.moderntreasury.com/payments/docs/create-counterparties-in-
        bulk";
      break;
    case "Invoice":
      bulkImportTypeText = "Invoices";
      bulkImportHelpLink =
        "https://docs.moderntreasury.com/payments/docs/create-invoices-in-bulk";
      break;
    default:
      break;
  }

  const headers = expectedFields.map((field) => field.key);

  return (
    <div className="grid mint-xl:grid-cols-2">
      <div>
        {bulkImportType && (
          <div id="mt-container-header">
            <Heading level="h1" size="l">
              {`Bulk ${bulkImportType}`}
            </Heading>
            <div className="mb-4 mt-2 max-w-lg">
              {`Bulk ${bulkImportType.toLowerCase()} allows you to upload a
              maximum of 1,000 ${bulkImportTypeText} at one time. For help with
              uploading or using templates, `}
              <a
                href={bulkImportHelpLink}
                target="_blank"
                rel="noreferrer"
                className="text-blue-500"
              >
                visit our guide.
              </a>
            </div>
          </div>
        )}
      </div>
      <div className="mb-4 flex space-x-4 mint-xl:justify-self-end">
        <Button
          buttonType="secondary"
          onClick={() => downloadCsvTemplate(headers)}
        >
          Download Template CSV
        </Button>
        <FlatfileBulkUploadButton
          onValidate={validate}
          onSubmit={submit}
          expectedFields={expectedFields}
          blueprint={blueprint}
          resource={resource}
        />
      </div>
    </div>
  );
}

export default BulkImportHeader;
```

---
## `CallScheduled.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { useDispatch } from "react-redux";
import moment from "moment-timezone";
import { Button } from "../../common/ui-components";
import { toggleLiveMode } from "../actions";
import { ChilipiperEvent } from "../../generated/dashboard/graphqlSchema";

interface CallScheduledProps {
  chilipiperEvent: ChilipiperEvent;
  onRescheduleClick: () => void;
  sandboxLink?: string;
}

function CallScheduled({
  chilipiperEvent,
  onRescheduleClick,
  sandboxLink = "/",
}: CallScheduledProps) {
  const dispatch = useDispatch();

  const returnToSandbox = () => {
    dispatch(toggleLiveMode(sandboxLink, false));
  };

  const renderDateTime = (dateTime: string) => (
    <p className="text-black">
      {moment(dateTime).format("MMMM Do YYYY, h:mm a")}
    </p>
  );

  return (
    <div className="flex flex-col items-center space-y-4 p-6">
      <h3 className="text-xl">Call scheduled</h3>
      <p className="text-sm text-text-muted">
        Weâre looking forward to meeting you at
      </p>
      <div className="flex">
        {renderDateTime(chilipiperEvent.slotStart)}
        &nbsp;to&nbsp;
        {renderDateTime(chilipiperEvent.slotEnd)}
      </div>
      <p className="mb-4 text-sm text-text-muted">
        Until then, you have full access to your sandbox environment.
      </p>
      {sandboxLink && (
        <div className="flex w-full flex-col space-y-4">
          <Button buttonType="primary" fullWidth onClick={returnToSandbox}>
            Return to Sandbox
          </Button>
          <Button buttonType="primary" fullWidth onClick={onRescheduleClick}>
            Reschedule Call
          </Button>
        </div>
      )}
    </div>
  );
}
export default CallScheduled;
```

---
## `CallScheduler.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { ClipLoader } from "react-spinners";
import moment from "moment-timezone";
import { cn } from "~/common/utilities/cn";
import CallScheduled from "./CallScheduled";
import ChilipiperScheduler, {
  ChilipiperEvent,
} from "../../partner_search/components/ChilipiperScheduler";
import {
  useChilipiperUserEventsQuery,
  useUpsertChilipiperEventMutation,
} from "../../generated/dashboard/graphqlSchema";

interface ScheduleACallContainerProps {
  routerName: string;
  extraTrackInfo?: Record<string, string>;
  sandboxLink?: string;
}

function CallScheduler({
  routerName,
  extraTrackInfo = {},
  sandboxLink,
}: ScheduleACallContainerProps) {
  const [reschedulerOpen, setReschedulerOpen] = useState<boolean>(false);
  const [upsertChilipiperEvent] = useUpsertChilipiperEventMutation();
  const { data, loading, error, refetch } = useChilipiperUserEventsQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      routerName,
      reschedulable: true,
    },
  });

  const scheduledCalls =
    loading || !data || error
      ? []
      : data.chilipiperUserEvents.edges.map(({ node }) => node);
  const upcomingCall = scheduledCalls.length > 0 ? scheduledCalls[0] : null;

  const updateChilipiperEvent = async ({
    args: { slot, eventId },
  }: ChilipiperEvent) => {
    const upsertChilipiperEventMutationInput = {
      id: upcomingCall?.id,
      slotStart: moment(slot.start).toISOString(),
      slotEnd: moment(slot.end).toISOString(),
      eventId,
      routerName,
    };
    await upsertChilipiperEvent({
      variables: {
        input: {
          input: upsertChilipiperEventMutationInput,
        },
      },
    });
    await refetch();
    setReschedulerOpen(false);
  };

  return loading ? (
    <ClipLoader />
  ) : (
    <div
      className={cn(
        "flex flex-col items-center space-y-2",
        upcomingCall && "rounded border",
      )}
    >
      {upcomingCall && (
        <CallScheduled
          chilipiperEvent={upcomingCall}
          onRescheduleClick={() => setReschedulerOpen(!reschedulerOpen)}
          sandboxLink={sandboxLink}
        />
      )}
      {(!upcomingCall || reschedulerOpen) && (
        <ChilipiperScheduler
          chiliPiperRouterName={routerName}
          bookingConfirmedCallback={updateChilipiperEvent}
          action={upcomingCall ? "reschedule" : "schedule"}
          rescheduledCallback={updateChilipiperEvent}
          extraTrackInfo={extraTrackInfo}
          chiliPiperEventId={upcomingCall?.eventId}
        />
      )}
    </div>
  );
}

export default CallScheduler;
```

---
## `CancelPlanModal.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Heading,
  Modal,
  ModalContainer,
  ModalContent,
  ModalHeader,
  ModalHeading,
  ModalTitle,
} from "../../common/ui-components";
import Gon from "../../common/utilities/gon";

interface CancelPlanModalProps {
  isOpen: boolean;
  handleModalClose: () => void;
}

function CancelPlanModal({ isOpen, handleModalClose }: CancelPlanModalProps) {
  const { organization } = Gon.gon;
  const organizationName = organization?.name ?? "";
  return (
    <Modal
      isOpen={isOpen}
      title="Cancel Subscription?"
      onRequestClose={handleModalClose}
    >
      <ModalContainer>
        <ModalHeader>
          <ModalHeading>
            <ModalTitle>
              <Heading level="h3" size="l">
                Cancel Subscription?
              </Heading>
            </ModalTitle>
          </ModalHeading>
        </ModalHeader>
        <ModalContent>
          Cancelling your subscription cannot be undone.
          <br />
          <br />
          - Cancelling your subscription will also result in loss of access to
          your live accounts, including API access.
          <br />
          - Any existing payments that were already sent to the bank will be
          processed by your bank.
          <br />
          - We recommend that you export your data before cancelling.
          <br />
          <br />
          Please{" "}
          <a
            href={`mailto:support@moderntreasury.com?subject=Plan Cancellation
            Request for ${organizationName}`}
          >
            contact Modern Treasury support (support@moderntreasury.com)
          </a>{" "}
          to cancel your account.
        </ModalContent>
      </ModalContainer>
    </Modal>
  );
}

export default CancelPlanModal;
```

---
## `CheckBoxWithLabel.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Checkbox, Label } from "~/common/ui-components";

interface CheckBoxWithLabelProps {
  id: string;
  name: string;
  label: string;
  value: boolean;
  onToggle: () => void;
}

function CheckboxWithLabel({
  id,
  name,
  label,
  value,
  onToggle,
}: CheckBoxWithLabelProps) {
  return (
    <div className="flex items-center rounded-sm outline-none transition-colors
    hover:cursor-pointer hover:bg-gray-25 focus:outline-none">
      <div className="flex w-full justify-center px-2 py-1">
        <div className="flex flex-row gap-2">
          <Checkbox checked={value} onChange={onToggle} id={id} name={name} />
          <Label className="font-medium" id={id}>
            {label}
          </Label>
        </div>
      </div>
    </div>
  );
}

export default CheckboxWithLabel;
```

---
## `ClearFiltersButton.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button, ButtonProps } from "../../common/ui-components";

export interface ClearFiltersButtonProps {
  disabled?: boolean;
  buttonHeight?: ButtonProps["buttonHeight"];
  onClick: () => void;
}

function ClearFiltersButton({
  disabled = false,
  buttonHeight = "extra-small",
  onClick,
}: ClearFiltersButtonProps) {
  return (
    <Button
      onClick={onClick}
      disabled={disabled}
      buttonType="text"
      buttonHeight={buttonHeight}
      className="text-gray-700"
    >
      Clear Filters
    </Button>
  );
}

export default ClearFiltersButton;
```

---
## `ColumnSelectorDropdown.tsx.txt`
**Path:** `.`  
```
import React, { useEffect, useState } from "react";
import { debounce, uniq } from "lodash";
import { cn } from "~/common/utilities/cn";
import MultiSelectDropdownPanel from "~/common/ui-
components/MultiSelectDropdown/MultiSelectDropdownPanel";
import { CUSTOM_COLUMN_EVENTS } from "../../common/constants/analytics";
import trackEvent from "../../common/utilities/trackEvent";
import {
  DisplayColumn,
  useColumnSelectorDropdownQuery,
} from "../../generated/dashboard/graphqlSchema";
import {
  RESOURCES,
  ResourcesEnum,
} from "../../generated/dashboard/types/resources";
import {
  Button,
  Icon,
  Popover,
  PopoverTrigger,
  PopoverPanel,
} from "../../common/ui-components";

export type Column = {
  id: string;
  label: string;
};

export interface ColumnSelectorDropdownProps {
  disableMetadata?: boolean;
  displayColumns?: Array<DisplayColumn | Column>;
  displayColumnsLoading?: boolean;
  /** When `true`, changes styling to accomodate being in the filter area. */
  inFilters?: boolean;
  onColumnSelectionChange?: (change: Record<string, Array<string>>) => void;
  resource?: ResourcesEnum;
  selectedColumns?: Array<string>;
  selectedMetadataColumns?: Array<string>;
}

const METADATA_PAGINATION_SIZE = 10;
const METADATA_KEYS_LIMIT = 50;

const currentRecordCount = (page: number) => page * METADATA_PAGINATION_SIZE;

const showLoadMore = (
  page: number,
  metadataKeys: Array<unknown>,
  searchValue: string,
) =>
  currentRecordCount(page) < METADATA_KEYS_LIMIT &&
  currentRecordCount(page) < metadataKeys.length &&
  !searchValue;

const showEndOfListMessage = (
  page: number,
  metadataKeys: Array<unknown>,
  searchValue: string,
  hasNextPage: boolean,
) =>
  !!metadataKeys.length &&
  currentRecordCount(page) >= METADATA_KEYS_LIMIT &&
  hasNextPage &&
  !searchValue;

const debouncedTrackSearch = debounce((searchValue: string, path: string) => {
  trackEvent(null, CUSTOM_COLUMN_EVENTS.CUSTOM_COLUMN_SEARCHED, {
    searchValue,
    path,
  });
}, 500);

const shouldQueryForMetadata = (
  disableMetadata: boolean,
  resource?: ResourcesEnum,
) => resource && !disableMetadata;

/* Track when the column selector dropdown is opened */
function ColumnSelectorDropdownTracker(props) {
  useEffect(() => {
    trackEvent(null, CUSTOM_COLUMN_EVENTS.CUSTOM_COLUMN_CLICKED, {
      path: window.location.pathname,
    });
  }, []);

  return <MultiSelectDropdownPanel {...props} />;
}

function ColumnSelectorDropdown({
  disableMetadata = false,
  displayColumns,
  displayColumnsLoading,
  inFilters,
  onColumnSelectionChange,
  resource,
  selectedColumns = [],
  selectedMetadataColumns = [],
}: ColumnSelectorDropdownProps) {
  const [searchValue, setSearchValue] = useState("");
  const [page, setPage] = useState(1);

  const { loading, data, error, refetch } = useColumnSelectorDropdownQuery({
    variables: {
      // Typescript can't detect that this wont get executed if
      // resource is not defined. Need to pass a dummy string
      resource: resource ? RESOURCES[resource].model : "",
      first: METADATA_KEYS_LIMIT,
    },
    skip: !shouldQueryForMetadata(disableMetadata, resource),
  });

  const { hasNextPage = false } =
    loading || !data || error ? {} : data.resourceMetadataKeys.pageInfo;
  // We must concatenate the metadatakeys with selected metadata columns
  // to make sure deleted metadata keys that are persisted as columns
  // show up on the dropdown for customers to be able to remove them.
  const metadataKeys =
    loading || !data || error
      ? []
      : uniq(
          data.resourceMetadataKeys.edges
            .map(({ node }) => node.metadataKey)
            .concat(selectedMetadataColumns),
        );

  const handleSearchValueChange = (newSearchValue: string) => {
    setSearchValue(newSearchValue);
    debouncedTrackSearch(newSearchValue, window.location.pathname);
    if (shouldQueryForMetadata(disableMetadata, resource)) {
      refetch({
        resource,
        first: METADATA_KEYS_LIMIT,
        key: newSearchValue,
      }).catch(() => {});
    }
  };

  return (
    <Popover>
      <PopoverTrigger
        buttonHeight={inFilters ? "extra-small" : undefined}
        className={cn(inFilters && "h-4 py-[6px]")}
        disabled={displayColumnsLoading}
        iconOnly={inFilters}
      >
        <Icon
          iconName="table"
          className="text-gray-700"
          size={inFilters ? "s" : undefined}
        />
        <span className={cn(inFilters && "text-sm")}>Edit Columns</span>
      </PopoverTrigger>
      <PopoverPanel
        className="max-h-96 overflow-y-auto"
        anchorOrigin={
          inFilters
            ? {
                horizontal: "right",
              }
            : {}
        }
      >
        {(panelProps: { close: () => void }) => (
          <>
            <ColumnSelectorDropdownTracker
              onClose={panelProps.close}
              categories={[
                {
                  items: (displayColumns || []).map((column) => ({
                    id: column.id,
                    label: column.label,
                  })),
                  id: "selectedColumns",
                },
                {
                  label: "Metadata",
                  items: metadataKeys
                    .slice(0, currentRecordCount(page))
                    .map((key) => ({
                      id: key,
                      label: key,
                      icon: "label",
                    })),
                  id: "selectedMetadataColumns",
                },
              ]}
              onChange={onColumnSelectionChange && onColumnSelectionChange}
              initialValues={{
                selectedColumns,
                selectedMetadataColumns,
              }}
              onSearchValueChange={handleSearchValueChange}
              searchValue={searchValue}
            />
            {showLoadMore(page, metadataKeys, searchValue) && (
              <div className="px-3 pb-4">
                <Button onClick={() => setPage(page + 1)} fullWidth>
                  Load More
                </Button>
              </div>
            )}
            {showEndOfListMessage(
              page,
              metadataKeys,
              searchValue,
              hasNextPage,
            ) && (
              <div className="max-w-xs pb-4 pl-6 pr-3 text-sm text-gray-800">
                Not all metadata keys are shown. Use the search box to narrow
                down the results.
              </div>
            )}
          </>
        )}
      </PopoverPanel>
    </Popover>
  );
}

export default ColumnSelectorDropdown;
```

---
## `ComplianceKybRuleForm.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { snakeCase } from "lodash";
import { Field, Form, Formik } from "formik";
import {
  Compliance__RuleActionEnum,
  RulePrimitivesEnum,
  useComplianceRuleViewQuery,
  useCreateComplianceRuleMutation,
  useDeleteComplianceRuleMutation,
  useUpdateComplianceRuleMutation,
} from "../../generated/dashboard/graphqlSchema";
import Button, {
  ButtonClickEventTypes,
} from "../../common/ui-components/Button/Button";
import {
  FieldGroup,
  FieldsRow,
  HorizontalRule,
  Label,
} from "../../common/ui-components";
import { FormikInputField, FormikSelectField } from "../../common/formik";
import { DECISION_SCORE_OPTIONS } from "../constants";
import ComplianceKybRuleConditionSection from
"../containers/ComplianceKybRuleConditionSection";
import { useDispatchContext } from "../MessageProvider";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";

type NormalizedRule = {
  field: string;
  operator: string;
  negate: string;
  value: string;
};

type DenormalizedRule = {
  field: string;
  operator: string;
  value: string;
};

type ConditionType = {
  operator: string;
  negate: boolean;
  value: NormalizedRule[];
};

type ComplianceKybRuleFormProps = {
  id: string;
  isEditForm: boolean;
};

type ComplianceKybFormValue = {
  name: string;
  conditions: DenormalizedRule[];
  operator: string;
  action: string;
};

function normalizeRules(conditions: DenormalizedRule[]) {
  return conditions?.map((condition) => {
    const { field, value, operator } = condition;
    return {
      field,
      operator: "equals",
      negate: !(operator === RulePrimitivesEnum.Eql),
      value,
    };
  });
}

function denormalizeRules(conditions: NormalizedRule[]) {
  return conditions?.map((condition) => {
    const { field, value, negate } = condition;
    return {
      field,
      operator: negate
        ? `not_${RulePrimitivesEnum.Eql}`
        : RulePrimitivesEnum.Eql,
      value,
    };
  });
}

function ComplianceKybRuleForm({ id, isEditForm }: ComplianceKybRuleFormProps) {
  const [disable, setDisable] = useState<boolean>(false);
  const rulesPath = `/settings/compliance/kyb/rules`;
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  const { data: queryData } = useComplianceRuleViewQuery({
    variables: {
      id,
    },
  });

  const [createComplianceRule] = useCreateComplianceRuleMutation();
  const [updateComplianceRule] = useUpdateComplianceRuleMutation();
  const [deleteComplianceRule] = useDeleteComplianceRuleMutation();

  function cancelRuleEdit(event: ButtonClickEventTypes) {
    handleLinkClick(rulesPath, event);
  }

  const createRule = async (rule: ComplianceKybFormValue) => {
    setDisable(true);

    const conditions = {
      operator: rule?.operator,
      negate: false,
      value: normalizeRules(rule.conditions),
    };

    try {
      const response = await createComplianceRule({
        variables: {
          input: {
            input: {
              name: rule.name,
              conditions: JSON.stringify(conditions),
              action: rule.action as Compliance__RuleActionEnum,
            },
          },
        },
      });

      if (response?.data?.createComplianceRule?.errors) {
        dispatchError(response?.data?.createComplianceRule?.errors.toString());
      } else {
        dispatchSuccess("Success!");
        window.location.href = rulesPath;
      }
    } catch (error) {
      dispatchError("Sorry, but something went wrong.");
    } finally {
      setDisable(false);
    }
  };

  const updateRule = async (rule: ComplianceKybFormValue) => {
    setDisable(true);

    const conditions = {
      operator: rule?.operator,
      negate: false,
      value: normalizeRules(rule?.conditions),
    };

    try {
      const response = await updateComplianceRule({
        variables: {
          input: {
            input: {
              id: queryData?.complianceRule?.id,
              name: rule?.name,
              conditions: JSON.stringify(conditions),
              action: rule?.action as Compliance__RuleActionEnum,
            },
          },
        },
      });

      if (response?.data?.updateComplianceRule?.errors) {
        dispatchError(response?.data?.updateComplianceRule?.errors.toString());
      } else {
        dispatchSuccess("Success!");
        window.location.href = rulesPath;
      }
    } catch (error) {
      dispatchError("Sorry, but something went wrong.");
    } finally {
      setDisable(false);
    }
  };

  const deleteRule = async () => {
    setDisable(true);

    try {
      const response = await deleteComplianceRule({
        variables: {
          input: {
            input: {
              id,
            },
          },
        },
      });

      if (response?.data?.deleteComplianceRule?.errors?.length) {
        dispatchError(response?.data?.deleteComplianceRule?.errors.toString());
      } else {
        dispatchSuccess("Success!");
        window.location.href = rulesPath;
      }
    } catch (error) {
      dispatchError(
        "We were unable to delete the rule. Please contact us if this error
        persists.",
      );
    } finally {
      setDisable(false);
    }
  };

  const initialValues = (): ComplianceKybFormValue => {
    const conditions = queryData?.complianceRule
      ?.conditions as unknown as string;

    if (conditions) {
      const parsedCondition = JSON.parse(conditions) as ConditionType;
      const value = denormalizeRules(parsedCondition?.value);
      return {
        name: queryData?.complianceRule?.name || "",
        conditions: value,
        operator: parsedCondition?.operator,
        action: snakeCase(queryData?.complianceRule?.action),
      };
    }
    return {
      name: "",
      conditions: [{ field: "", operator: "", value: "" }],
      operator: "",
      action: "",
    };
  };

  return (
    <Formik
      initialValues={initialValues()}
      onSubmit={async (values) => {
        if (isEditForm) {
          await updateRule(values);
        } else {
          await createRule(values);
        }
      }}
      enableReinitialize
    >
      <Form>
        <FieldsRow columns={3}>
          <FieldGroup>
            <Label>Rule Name</Label>
            <Field
              id="name"
              type="input"
              name="name"
              value
              component={FormikInputField}
              options={DECISION_SCORE_OPTIONS}
            />
          </FieldGroup>
        </FieldsRow>
        <HorizontalRule />
        <ComplianceKybRuleConditionSection />
        <HorizontalRule />
        <FieldsRow columns={2}>
          <FieldGroup>
            <Label className="pt-2">Action</Label>
            <Field
              id="action"
              type="select"
              name="action"
              value
              component={FormikSelectField}
              options={DECISION_SCORE_OPTIONS}
            />
          </FieldGroup>
        </FieldsRow>
        <div className="flex flex-row space-x-4">
          <Button buttonType="primary" isSubmit disabled={disable}>
            {isEditForm ? "Update" : "Create Rule"}
          </Button>
          {isEditForm && (
            <Button
              buttonType="destructive"
              onClick={() => {
                void deleteRule();
              }}
            >
              Delete
            </Button>
          )}
          <Button
            onClick={(event: ButtonClickEventTypes) => cancelRuleEdit(event)}
          >
            Cancel
          </Button>
        </div>
      </Form>
    </Formik>
  );
}

export default ComplianceKybRuleForm;
```

---
## `ContentDownloadButton.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button } from "../../common/ui-components";
import useObjectUrl from "../../common/utilities/useObjectUrl";

export interface ContentDownloadButtonProps {
  filename: string;
  content: string;
  children: string;
}

function ContentDownloadButton({
  filename,
  content,
  children,
}: ContentDownloadButtonProps) {
  const objectUrl = useObjectUrl(content);
  return (
    <a href={objectUrl} download={filename}>
      <Button buttonType="primary">{children}</Button>
    </a>
  );
}

export default ContentDownloadButton;
```

---
## `CounterpartyAccountCountryOptions.tsx.txt`
**Path:** `.`  
```
import usFlag from "../../../images/flags/us_flag.svg";
import ukFlag from "../../../images/flags/uk_flag.svg";
import unFlag from "../../../images/flags/un_flag.svg";
import caFlag from "../../../images/flags/ca_flag.svg";
import auFlag from "../../../images/flags/au_flag.svg";
import euFlag from "../../../images/flags/eu_flag.svg";
import hkFlag from "../../../images/flags/hk_flag.svg";
import inFlag from "../../../images/flags/in_flag.svg";
import jpFlag from "../../../images/flags/jp_flag.svg";
import seFlag from "../../../images/flags/se_flag.svg";
import nzFlag from "../../../images/flags/nz_flag.svg";
import dkFlag from "../../../images/flags/dk_flag.svg";
import huFlag from "../../../images/flags/hu_flag.svg";
import idFlag from "../../../images/flags/id_flag.svg";

export enum AccountCountryType {
  AU = "AU",
  CA = "CA",
  DK = "DK",
  EU = "EU",
  GB = "GB",
  International = "INTERNATIONAL",
  US = "US",
  USChecksOnly = "US_CHECKS_ONLY",
  HK = "HK",
  HU = "HU",
  ID = "ID",
  IN = "IN",
  JP = "JP",
  SE = "SE",
  NZ = "NZ",
}

export enum RoutingNumberField {
  ABA = "aba_routing_number",
  AU_BSB = "au_bsb_routing_number",
  CA_CPA = "ca_cpa_routing_number",
  DK_INTERBANK_CLEARING_CODE = "dk_interbank_clearing_code_routing_number",
  GB_SORT_CODE = "gb_sort_code_routing_number",
  HK_INTERBANK_CLEARING_CODE = "hk_interbank_clearing_code_routing_number",
  HU_INTERBANK_CLEARING_CODE = "hu_interbank_clearing_code_routing_number",
  ID_SKNBI_CODE = "id_sknbi_code_routing_number",
  IN_IFSC = "in_ifsc_routing_number",
  JP_ZENGIN_CODE = "jp_zengin_code_routing_number",
  NZ_NATIONAL_CLEARING_CODE = "nz_national_clearing_code_routing_number",
  SE_BANKGIRO_CLEARING_CODE = "se_bankgiro_clearing_code_routing_number",
  SWIFT_CODE = "swift_code",
}

export enum AccountNumberField {
  WALLET_ADDRESS = "wallet_address_account_number",
  CLABE = "clabe_account_number",
  PAN = "pan_account_number",
  IBAN = "iban_account_number",
  OTHER = "account_number",
}

export const AccountCountryOptions = [
  { label: "US Account", value: AccountCountryType.US, icon: usFlag },
  {
    label: "US Account (Checks Only)",
    value: AccountCountryType.USChecksOnly,
    icon: usFlag,
  },
  {
    label: "International Account",
    value: AccountCountryType.International,
    icon: unFlag,
  },
  // Non-US International Rails
  { label: "AU Account", value: AccountCountryType.AU, icon: auFlag },
  { label: "CA Account", value: AccountCountryType.CA, icon: caFlag },
  { label: "DK Account", value: AccountCountryType.DK, icon: dkFlag },
  { label: "EU Account", value: AccountCountryType.EU, icon: euFlag },
  { label: "GB Account", value: AccountCountryType.GB, icon: ukFlag },
  { label: "HK Account", value: AccountCountryType.HK, icon: hkFlag },
  { label: "HU Account", value: AccountCountryType.HU, icon: huFlag },
  { label: "ID Account", value: AccountCountryType.ID, icon: idFlag },
  { label: "IN Account", value: AccountCountryType.IN, icon: inFlag },
  { label: "JP Account", value: AccountCountryType.JP, icon: jpFlag },
  { label: "NZ Account", value: AccountCountryType.NZ, icon: nzFlag },
  { label: "SE Account", value: AccountCountryType.SE, icon: seFlag },
];
```

---
## `CounterpartyAccountFormActions.tsx.txt`
**Path:** `.`  
```
import React from "react";

import {
  ActionItem,
  Icon,
  Popover,
  PopoverPanel,
  PopoverTrigger,
} from "../../common/ui-components";

function CounterpartyAccountFormActions({
  onDelete,
}: {
  onDelete: () => void;
}) {
  return (
    <Popover>
      <PopoverTrigger>
        <Icon iconName="more_horizontal" />
      </PopoverTrigger>
      <PopoverPanel anchorOrigin={{ horizontal: "right" }}>
        <ActionItem type="danger" onClick={() => onDelete()}>
          Delete
        </ActionItem>
      </PopoverPanel>
    </Popover>
  );
}

export default CounterpartyAccountFormActions;
```

---
## `CounterpartyAccountFormSection.jsx.txt`
**Path:** `.`  
```
import React from "react";
import { connect } from "react-redux";
import { compose } from "redux";
import { Field, FieldArray, change, reduxForm } from "redux-form";

import isNil from "lodash/isNil";

import AddressForm from "./AddressForm";
import CounterpartyAccountFormActions from "./CounterpartyAccountFormActions";
import ToggleableAddressForm from "./ToggleableAddressForm";
import { CounterpartyAccountRoutingDetails } from
"./CounterpartyAccountRoutingDetails";
import {
  AccountCountryOptions,
  RoutingNumberField,
} from "./CounterpartyAccountCountryOptions";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import ReduxSelectBar from "../../common/deprecated_redux/ReduxSelectBar";
import { FieldGroup, Label, SelectField } from "../../common/ui-components";

function AccountsSection({
  fields,
  accounts,
  reduxChange,
  formName,
  counterpartyName,
  isEdit,
}) {
  function pushNewAccount(accountCountryType) {
    const data = {
      party_address: {},
      account_country_type: accountCountryType,
    };
    fields.push(data);
  }

  function getData(index, dataName) {
    return accounts && !isNil(accounts[index]) ? accounts[index][dataName] : {};
  }

  const clearRoutingAndAccountNumbers = (account) => {
    Object.values(RoutingNumberField).forEach((routingNumber) => {
      if (routingNumber !== RoutingNumberField.SWIFT_CODE) {
        reduxChange(`${account}.${routingNumber}`, null, false, false);
        reduxChange(`${account}.${routingNumber}_touched`, false, false, false);
      }
    });
    reduxChange(`${account}.iban_account_number`, null, false, false);
    reduxChange(`${account}.account_number`, null, false, false);
  };

  let partyAddress;

  return (
    <div>
      {fields.map((account, index) => {
        partyAddress = getData(index, "party_address");
        return (
          <div key={account} className="form-subsection">
            <div className="border-mt-gray-200 grid grid-flow-col justify-
            between border-b py-4">
              <div>
                <SelectField
                  selectValue={getData(index, "account_country_type")}
                  classes="w-56"
                  disabled={isEdit}
                  options={AccountCountryOptions}
                  handleChange={(value) => {
                    reduxChange(
                      `${account}.account_country_type`,
                      value,
                      false,
                      false,
                    );
                    clearRoutingAndAccountNumbers(account);
                  }}
                />
              </div>
              <CounterpartyAccountFormActions
                onDelete={() => fields.remove(index)}
              />
            </div>
            <div className="subsection-row my-2">
              <FieldGroup>
                <Label
                  id={`${account}.party_name`}
                  helpText="This is the name your counterparty has on their
                  account.<br />It helps us route the payment to them
                  correctly.<br />If the account name is the same as the name
                  you put above, you may leave this blank."
                >
                  Name on Account
                </Label>
                <Field
                  placeholder={counterpartyName}
                  name={`${account}.party_name`}
                  component={ReduxInputField}
                  type="text"
                />
              </FieldGroup>

              <FieldGroup>
                <Label
                  id={`${account}.name`}
                  helpText="This is the nickname of this specific account.<br
                  />This can help indicate the correct account when creating
                  payment orders."
                >
                  Account Nickname
                </Label>
                <Field
                  name={`${account}.name`}
                  component={ReduxInputField}
                  type="text"
                />
              </FieldGroup>
            </div>
            {accounts[index].account_country_type !== "US_CHECKS_ONLY" && (
              <>
                <div className="mb-4 mr-4 max-w-24/25">
                  <Field
                    name={`${account}.party_type`}
                    label="Counterparty Type"
                    component={ReduxSelectBar}
                    selectOptions={[
                      {
                        text: "Business",
                        value: "business",
                        selectedClassName: "bg-cyan-600 text-white",
                      },
                      {
                        text: "Individual",
                        value: "individual",
                        selectedClassName: "bg-cyan-600 text-white",
                      },
                    ]}
                    helpText="This helps us determine how to route the payment
                    to the counterparty. You may leave this blank if are not
                    using electronic payments."
                  />
                </div>
                <div className="mb-4 mr-4 max-w-24/25">
                  <Field
                    name={`${account}.account_type`}
                    label="Account Type"
                    component={ReduxSelectBar}
                    selectOptions={[
                      {
                        text: "Checking",
                        value: "checking",
                        selectedClassName: "bg-cyan-600 text-white",
                      },
                      {
                        text: "Savings",
                        value: "savings",
                        selectedClassName: "bg-cyan-600 text-white",
                      },
                    ]}
                    helpText="You may leave this blank if you are not using
                    electronic payments."
                  />
                </div>
                <CounterpartyAccountRoutingDetails
                  index={index}
                  account={account}
                  formName={formName}
                  getData={getData}
                  reduxChange={reduxChange}
                  accountCountryType={getData(index, "account_country_type")}
                />
                <ToggleableAddressForm
                  formName={formName}
                  fieldName={account}
                  address={partyAddress}
                  addressName="party_address"
                  reduxChange={reduxChange}
                />
              </>
            )}
            {accounts[index].account_country_type === "US_CHECKS_ONLY" && (
              <AddressForm
                fieldName={account}
                address={partyAddress}
                addressName="party_address"
                shouldValidate
              />
            )}
          </div>
        );
      })}

      <div>
        <SelectField
          name="accountCountryTypeSelect"
          selectValue={undefined}
          classes="w-52"
          placeholder="Add Bank Account"
          disabled={false}
          options={AccountCountryOptions}
          handleChange={(value) => {
            pushNewAccount(value);
          }}
          optionIcon
        />
      </div>
    </div>
  );
}

function CounterpartyAccountFormSection({
  formName,
  accounts,
  change: reduxChange,
  counterpartyName,
  isEdit,
}) {
  return (
    <FieldArray
      reduxChange={reduxChange}
      name="accounts"
      component={AccountsSection}
      accounts={accounts}
      formName={formName}
      counterpartyName={counterpartyName}
      isEdit={isEdit}
    />
  );
}

export default compose(
  connect(null, { change }),
  reduxForm({ form: "counterparty" }),
)(CounterpartyAccountFormSection);
```

---
## `CounterpartyAccountRoutingDetails.tsx.txt`
**Path:** `.`  
```
/* eslint-disable @typescript-eslint/restrict-template-expressions */
import React, { useEffect, useState } from "react";
import { Field, FormAction, GenericField, Validator } from "redux-form";
import { isEmpty, isNil } from "lodash";
import {
  validAbaRoutingNumber,
  validSwiftRoutingNumber,
  validAccountNumber,
  validCaCpaRoutingNumber,
  validDkInterbankClearingCode,
  validAuGbSortCode,
  validHkInterbankClearingCode,
  validHuInterbankClearingCode,
  validIdSknbiCode,
  validInIfscNumber,
  validJpZenginCode,
  validSeBankgiroClearingCode,
  validNzNationalClearingCode,
  required,
} from "../../common/ui-components/validations";
import requestApi from "../../common/utilities/requestApi";
import {
  AccountCountryType,
  RoutingNumberField,
  AccountNumberField,
} from "./CounterpartyAccountCountryOptions";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { Clickable } from "../../common/ui-components";

interface CustomProps {
  type: string;
  label: string;
  required?: boolean;
  optionalLabel?: "Required" | "Optional" | null;
  helpText?: string;
}

const FieldCustom = Field as new () => GenericField<CustomProps>;

type Validations = Array<{ (value: string): string | undefined }>;
export interface RoutingFieldInfo {
  fieldName: string;
  label: string;
  validations: Validations;
}
// This field info is also used for the inline counterparty create:
// containers/payment_order_form/create_counterparty/InlineCounterpartyAccountRo
utingDetails.tsx
export const USInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.ABA,
  label: "ABA Routing Number",
  validations: [validAbaRoutingNumber],
};
export const AUInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.AU_BSB,
  label: "Australian BSB Number",
  validations: [validAuGbSortCode],
};
export const CAInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.CA_CPA,
  label: "Canadian Routing Number",
  validations: [validCaCpaRoutingNumber],
};
export const DKInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.DK_INTERBANK_CLEARING_CODE,
  label: "Danish Interbank Clearing Code",
  validations: [validDkInterbankClearingCode],
};
export const GBInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.GB_SORT_CODE,
  label: "British Sort Code",
  validations: [validAuGbSortCode],
};
export const HKInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.HK_INTERBANK_CLEARING_CODE,
  label: "Hong Kong Interbank Clearing Code",
  validations: [validHkInterbankClearingCode],
};
export const HUInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.HU_INTERBANK_CLEARING_CODE,
  label: "Hungarian Interbank Clearing Code",
  validations: [validHuInterbankClearingCode],
};
export const IDInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.ID_SKNBI_CODE,
  label: "Indonesian SKNBI Code",
  validations: [validIdSknbiCode],
};
export const INInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.IN_IFSC,
  label: "IFSC Code",
  validations: [validInIfscNumber],
};
export const JPInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.JP_ZENGIN_CODE,
  label: "Zengin Code",
  validations: [validJpZenginCode],
};
export const NZInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.NZ_NATIONAL_CLEARING_CODE,
  label: "New Zealand National Clearing Code",
  validations: [validNzNationalClearingCode],
};
export const SEInfo: RoutingFieldInfo = {
  fieldName: RoutingNumberField.SE_BANKGIRO_CLEARING_CODE,
  label: "Swedish Clearing Number",
  validations: [validSeBankgiroClearingCode],
};

interface AccountNumberRoutingDetailProps {
  index: number;
  account: unknown;
  getData(index: number, field: string): string;
  reduxChange(
    field: string,
    value: unknown,
    touch?: boolean,
    persistentSubmitErrors?: boolean,
  ): FormAction;
  validators: Array<Validator>;
}

function AccountNumberRoutingDetail({
  index,
  account,
  getData,
  reduxChange,
  validators,
}: AccountNumberRoutingDetailProps) {
  return isEmpty(getData(index, "account_number")) ||
    !getData(index, "account_number").includes("â¢") ? (
    <FieldCustom
      name={`${account}.account_number`}
      type="text"
      component={ReduxInputField}
      label="Account Number"
      validate={validators}
      onChange={(event, newValue) => {
        reduxChange(`${account}.account_number`, newValue, false, false);
        reduxChange(`${account}.account_number_touched`, true, false, false);
      }}
    />
  ) : (
    <div>
      <ReduxInputField
        disabled
        label="Account Number"
        input={{ value: getData(index, "account_number"), onChange: () => {} }}
      >
        <Clickable
          onClick={() => {
            reduxChange(`${account}.account_number`, null, false, false);
            reduxChange(
              `${account}.account_number_touched`,
              true,
              false,
              false,
            );
          }}
          id="delete-account-number-btn"
        >
          <span className="text-blue-500">Delete Account Number</span>
        </Clickable>
      </ReduxInputField>
    </div>
  );
}

interface CounterpartyAccountRoutingDetailsProps {
  index: number;
  account: unknown;
  accountCountryType: AccountCountryType;
  getData(index: number, field: string): string;
  reduxChange(
    field: string,
    value: unknown,
    touch?: boolean,
    persistentSubmitErrors?: boolean,
  ): FormAction;
}

export function CounterpartyAccountRoutingDetails({
  index,
  account,
  accountCountryType,
  getData,
  reduxChange,
}: CounterpartyAccountRoutingDetailsProps) {
  const [bankName, setBankName] = useState<string>();

  const fetchBankDetails = (routingNumber: string) => {
    if (isNil(routingNumber) || routingNumber.length !== 9) {
      return;
    }
    requestApi(
      `/counterparties/bank_details?routing_number=${routingNumber}`,
      null,
      "GET",
    )
      .json(({ bank_name }) => setBankName(bank_name as string))
      .catch(() => null); // do nothing
  };

  // Extra routing fields could have been set through the API
  const [extraFieldInfos, setExtraFieldInfos] = useState<
    Array<RoutingFieldInfo>
  >([]);

  const getRoutingFieldInfo = (): RoutingFieldInfo | undefined => {
    switch (accountCountryType) {
      case AccountCountryType.US:
        return USInfo;
      case AccountCountryType.AU:
        return AUInfo;
      case AccountCountryType.CA:
        return CAInfo;
      case AccountCountryType.DK:
        return DKInfo;
      case AccountCountryType.GB:
        return GBInfo;
      case AccountCountryType.HK:
        return HKInfo;
      case AccountCountryType.HU:
        return HUInfo;
      case AccountCountryType.ID:
        return IDInfo;
      case AccountCountryType.IN:
        return INInfo;
      case AccountCountryType.JP:
        return JPInfo;
      case AccountCountryType.SE:
        return SEInfo;
      case AccountCountryType.NZ:
        return NZInfo;
      case AccountCountryType.International:
      case AccountCountryType.EU:
      case AccountCountryType.USChecksOnly:
      default:
        return undefined;
    }
  };

  const hasMultipleCountries =
    Object.values(RoutingNumberField).reduce(
      (result, field) =>
        !isEmpty(getData(index, field)) &&
        field !== RoutingNumberField.SWIFT_CODE
          ? result + 1
          : result,
      0,
    ) > 1;

  const nonAddressOnlyFields = [
    ...Object.values(RoutingNumberField),
    ...Object.values(AccountNumberField),
  ];

  // Checks if there are no routing numbers(including Swift Code) or
  account_number
  // AND that there is an address for a given account
  const addressOnly =
    nonAddressOnlyFields.every((field) => isEmpty(getData(index, field))) &&
    getData(index, "partyAddress");
  const displayIBAN = () =>
    [
      AccountCountryType.GB,
      AccountCountryType.EU,
      AccountCountryType.International,
    ].includes(accountCountryType) ||
    !isEmpty(getData(index, "iban_account_number"));
  const requiredSwiftCode = () =>
    [AccountCountryType.International, AccountCountryType.EU].includes(
      accountCountryType,
    ) && !hasMultipleCountries;
  const routingFieldInfo = getRoutingFieldInfo();

  useEffect(() => {
    // When editing routing details, the account_country_type wasn't persisted,
    can infer from set fields
    const inferAccountCountryType = () => {
      let value = AccountCountryType.International;
      if (hasMultipleCountries) {
        value = AccountCountryType.International;
      } else if (getData(index, RoutingNumberField.ABA)) {
        value = AccountCountryType.US;
      } else if (getData(index, RoutingNumberField.AU_BSB)) {
        value = AccountCountryType.AU;
      } else if (getData(index, RoutingNumberField.CA_CPA)) {
        value = AccountCountryType.CA;
      } else if (
        getData(index, RoutingNumberField.DK_INTERBANK_CLEARING_CODE)
      ) {
        value = AccountCountryType.DK;
      } else if (getData(index, RoutingNumberField.GB_SORT_CODE)) {
        value = AccountCountryType.GB;
      } else if (
        getData(index, RoutingNumberField.HK_INTERBANK_CLEARING_CODE)
      ) {
        value = AccountCountryType.HK;
      } else if (
        getData(index, RoutingNumberField.HU_INTERBANK_CLEARING_CODE)
      ) {
        value = AccountCountryType.HU;
      } else if (getData(index, RoutingNumberField.ID_SKNBI_CODE)) {
        value = AccountCountryType.ID;
      } else if (getData(index, RoutingNumberField.IN_IFSC)) {
        value = AccountCountryType.IN;
      } else if (getData(index, RoutingNumberField.JP_ZENGIN_CODE)) {
        value = AccountCountryType.JP;
      } else if (getData(index, RoutingNumberField.NZ_NATIONAL_CLEARING_CODE)) {
        value = AccountCountryType.NZ;
      } else if (getData(index, RoutingNumberField.SE_BANKGIRO_CLEARING_CODE)) {
        value = AccountCountryType.SE;
      } else if (
        getData(index, "iban_account_number") &&
        getData(index, "swift_code")
      ) {
        value = AccountCountryType.EU;
      } else if (addressOnly) {
        value = AccountCountryType.USChecksOnly;
      }
      reduxChange(`${account}.account_country_type`, value, false, false);
    };

    // 'International' may have multiple country's routing number
    if (accountCountryType === AccountCountryType.International) {
      const fieldInfos: Array<RoutingFieldInfo> = [];
      [
        USInfo,
        AUInfo,
        CAInfo,
        DKInfo,
        GBInfo,
        HKInfo,
        HUInfo,
        IDInfo,
        INInfo,
        JPInfo,
        SEInfo,
        NZInfo,
      ].forEach((info) => {
        if (
          !isEmpty(getData(index, info.fieldName)) ||
          getData(index, `${info.fieldName}_touched`)
        ) {
          fieldInfos.push(info);
        }
      });
      setExtraFieldInfos(fieldInfos);
    } else if (!accountCountryType) {
      inferAccountCountryType();
    }
  }, [
    getData,
    index,
    account,
    accountCountryType,
    reduxChange,
    hasMultipleCountries,
    addressOnly,
  ]);

  return (
    <>
      {routingFieldInfo && (
        <div className="subsection-row">
          <FieldCustom
            name={`${account}.${routingFieldInfo.fieldName}`}
            required
            type="text"
            component={ReduxInputField}
            label={routingFieldInfo.label}
            validate={
              accountCountryType === AccountCountryType.US
                ? routingFieldInfo.validations
                : routingFieldInfo.validations.concat([required])
            }
            onBlur={(event, routingNumber: string) =>
              fetchBankDetails(routingNumber)
            }
            onChange={(event, newValue) => {
              reduxChange(
                `${account}.${routingFieldInfo.fieldName}`,
                newValue,
                false,
                true,
              );
              reduxChange(
                `${account}.${routingFieldInfo.fieldName}_touched`,
                true,
                false,
                false,
              );
              setBankName(undefined);
            }}
            helpText={
              accountCountryType === AccountCountryType.US
                ? "You may leave this blank if are not using electronic
                payments."
                : undefined
            }
          >
            {bankName ? <span>{bankName}</span> : null}
          </FieldCustom>
          <AccountNumberRoutingDetail
            index={index}
            account={account}
            getData={getData}
            reduxChange={reduxChange}
            validators={[validAccountNumber]}
          />
        </div>
      )}
      {extraFieldInfos && (
        <div className="subsection-row">
          {extraFieldInfos.map((extraFieldInfo, extraFieldIndex) => (
            <div className={extraFieldIndex > 1 ? "mt-3" : ""}>
              <FieldCustom
                name={`${account}.${extraFieldInfo.fieldName}`}
                type="text"
                component={ReduxInputField}
                label={extraFieldInfo.label}
                validate={extraFieldInfo.validations}
                onChange={(event, newValue) => {
                  reduxChange(
                    `${account}.${extraFieldInfo.fieldName}`,
                    newValue,
                    false,
                    true,
                  );
                  reduxChange(
                    `${account}.${extraFieldInfo.fieldName}_touched`,
                    true,
                    false,
                    false,
                  );
                }}
              />
            </div>
          ))}
        </div>
      )}
      <div className="subsection-row">
        <FieldCustom
          name={`${account}.swift_code`}
          required={requiredSwiftCode()}
          optionalLabel={!requiredSwiftCode() ? "Optional" : null}
          type="text"
          component={ReduxInputField}
          label="SWIFT Code"
          validate={
            requiredSwiftCode()
              ? [required, validSwiftRoutingNumber]
              : [validSwiftRoutingNumber]
          }
          helpText="Required for sending international wire or SEPA transfers."
          onChange={(event, newValue) => {
            reduxChange(`${account}.swift_code`, newValue, false, false);
            reduxChange(`${account}.swift_code_touched`, true, false, false);
          }}
        />
        {displayIBAN() &&
          (isEmpty(getData(index, "iban_account_number")) ||
          !getData(index, "iban_account_number").includes("â¢") ? (
            <FieldCustom
              name={`${account}.iban_account_number`}
              required={accountCountryType === AccountCountryType.EU}
              optionalLabel={
                accountCountryType !== AccountCountryType.EU &&
                accountCountryType !== AccountCountryType.International
                  ? "Optional"
                  : null
              }
              type="text"
              component={ReduxInputField}
              validate={
                accountCountryType === AccountCountryType.EU ? [required] : []
              }
              label="IBAN Number"
              helpText="Required for sending international wire or SEPA
              transfers."
              onChange={(event, newValue) => {
                reduxChange(
                  `${account}.iban_account_number`,
                  newValue,
                  false,
                  false,
                );
                reduxChange(
                  `${account}.iban_account_number_touched`,
                  true,
                  false,
                  false,
                );
              }}
            />
          ) : (
            <div>
              <ReduxInputField
                disabled
                label="IBAN Number"
                input={{
                  value: getData(index, "iban_account_number"),
                  onChange: () => {},
                }}
              >
                <Clickable
                  id="delete-iban-number-btn"
                  onClick={() => {
                    reduxChange(
                      `${account}.iban_account_number`,
                      null,
                      false,
                      false,
                    );
                    reduxChange(
                      `${account}.iban_account_number_touched`,
                      true,
                      false,
                      false,
                    );
                  }}
                >
                  <span className="text-blue-500">Delete IBAN Number</span>
                </Clickable>
              </ReduxInputField>
            </div>
          ))}
      </div>
      {accountCountryType === AccountCountryType.International && (
        <div className="subsection-row">
          <AccountNumberRoutingDetail
            index={index}
            account={account}
            getData={getData}
            reduxChange={reduxChange}
            validators={[validAccountNumber]}
          />
        </div>
      )}
    </>
  );
}
```

---
## `CounterpartyBulkImport.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateCounterpartiesMutation,
  useBulkValidateCounterpartiesMutation,
} from "../../generated/dashboard/graphqlSchema";
import { BulkResourceType } from "./FlatfileBulkUploadButton";
import BulkImportHeader from "./BulkImportHeader";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import {
  counterpartyBlueprint,
  counterpartyBlueprintFields,
} from "./bulk_imports/blueprints/counterpartyBlueprint";

function CounterpartyBulkImport(): JSX.Element {
  const [bulkCreateCounterparties] = useBulkCreateCounterpartiesMutation();
  const [bulkValidateCounterparties] = useBulkValidateCounterpartiesMutation();

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateCounterparties({
      variables: {
        input: {
          counterparties: resultsData,
          flatfileSheetId,
          flatfileSpaceId,
        },
      },
    });
    const { bulkImportId } = data?.bulkCreateCounterparties ?? {};
    if (bulkImportId) {
      return { success: true, bulkImportId };
    }
    return { success: false, bulkImportId: "" };
  };

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateCounterparties({
      variables: {
        input: {
          counterparties: resultsData,
        },
      },
    });
    return response.data?.bulkValidateCounterparties?.recordErrors;
  };

  return (
    <PageHeader
      crumbs={[
        {
          name: "Counterparties",
          path: "/counterparties",
        },
      ]}
      title="Bulk Imports"
    >
      <BulkImportHeader
        bulkImportType="Counterparty"
        validate={validate}
        submit={submit}
        expectedFields={counterpartyBlueprintFields}
        blueprint={counterpartyBlueprint}
        resource={BulkResourceType.Counterparties}
      />
    </PageHeader>
  );
}

export default CounterpartyBulkImport;
```

---
## `CounterpartyDetailsForm.jsx.txt`
**Path:** `.`  
```
import React, { useEffect } from "react";
import { connect } from "react-redux";
import { compose } from "redux";
import { reduxForm, Field, change, formValueSelector } from "redux-form";
import { required, email } from "../../common/ui-components/validations";
import AccountingCategorySelect from "./AccountingCategorySelect";
import AccountingLedgerClassSelect from "./AccountingLedgerClassSelect";
import { loadLedgerEntities } from "../actions";
import ReduxCheckbox from "../../common/deprecated_redux/ReduxCheckbox";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import {
  FieldGroup,
  FieldsRow,
  Label,
  SelectField,
  Tooltip,
} from "../../common/ui-components";
import Gon from "../../common/utilities/gon";
import { useDispatchContext } from "../MessageProvider";

const ledgerTypeOptions = [
  { value: "customer", label: "Customer" },
  { value: "vendor", label: "Vendor" },
];

function CounterpartyDetailsForm({
  accounting_category: accountingCategory,
  accounting_ledger_class: accountingLedgerClass,
  ledger_type: ledgerType,
  change: reduxChange,
  loadLedgerEntities: loadLedgerEntitiesFunc,
  newCounterpartyForm,
}) {
  const { dispatchError } = useDispatchContext();
  useEffect(() => {
    loadLedgerEntitiesFunc(
      { ledger_sync_type: ["account", "ledger_class"] },
      null,
      dispatchError,
    );
  }, [loadLedgerEntitiesFunc, dispatchError]);

  const {
    ui: {
      ledger: {
        id: ledgerId = "",
        ledger_classes_enabled: ledgerClassesEnabled = false,
        auto_sync_counterparties_enabled: autoSyncCounterpartiesEnabled = false,
      } = {},
    },
  } = Gon.gon ?? {};

  function onAccountingCategoryChange(value) {
    reduxChange("accounting_category", value, false, false);
  }

  function onAccountingLedgerClassChange(value) {
    reduxChange("accounting_ledger_class", value, false, false);
  }

  function onledgerTypeChange(value) {
    reduxChange("ledger_type", value, false, false);
  }

  return (
    <div className="form-section">
      <div className="mb-2 w-full mint-md:w-72">
        <FieldGroup>
          <Label id="name">Counterparty Name</Label>
          <Field
            name="name"
            type="text"
            component={ReduxInputField}
            validate={[required]}
            required
          />
        </FieldGroup>
      </div>
      <FieldsRow centered={false} columns={2} gap={4} className="items-end">
        <div className="mb-0 w-full mint-md:mb-2 mint-md:w-72">
          <FieldGroup>
            <Label id="email">Email</Label>
            <Field
              name="email"
              type="text"
              component={ReduxInputField}
              validate={[email]}
              helpText="This field is optional. If you'd like us to onboard the
              counterparty for you, we'll need their email."
            />
          </FieldGroup>
        </div>
        <div className="mb-1 flex items-center">
          <FieldGroup direction="left-to-right">
            <Field name="send_remittance_advice" component={ReduxCheckbox} />
            <Label className="ml-2">Email counterparty when paid</Label>
          </FieldGroup>
        </div>
      </FieldsRow>
      {ledgerId && (
        <div className="form-section mt-6">
          <h3>
            <span>Default Accounting Details</span>
            <span className="addendum">OPTIONAL</span>
            <Tooltip
              className="tooltip-holder"
              data-tip="These accounting details will be pre-selected when
              creating a payment order involving this counterparty."
            />
          </h3>
          <div className="form-row flex">
            <Field
              label="Accounting Category"
              helpText="This is the list of accounting categories we've pulled
              from your accounting system."
              component={AccountingCategorySelect}
              name="accounting_category"
              selectValue={accountingCategory}
              handleChange={onAccountingCategoryChange}
            />
            {ledgerClassesEnabled && (
              <Field
                label="Accounting Class"
                helpText="This is the list of accounting classes we've pulled
                from your accounting system."
                component={AccountingLedgerClassSelect}
                name="accounting_ledger_class"
                selectValue={accountingLedgerClass}
                handleChange={onAccountingLedgerClassChange}
              />
            )}
          </div>
          {autoSyncCounterpartiesEnabled && newCounterpartyForm && (
            <div className="form-row flex">
              <FieldGroup direction="top-to-bottom">
                <Label
                  helpText="This counterparty will be synced as the selected
                  type when it is auto synced to your ledger."
                  id="ledger_type"
                >
                  Ledger Type
                </Label>
                <SelectField
                  name="ledger_type"
                  handleChange={onledgerTypeChange}
                  selectValue={ledgerType}
                  options={ledgerTypeOptions}
                />
              </FieldGroup>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

const selector = formValueSelector("counterparty");
function mapStateToProps(state) {
  return {
    accounting_category: selector(state, "accounting_category"),
    accounting_ledger_class: selector(state, "accounting_ledger_class"),
    ledger_type: selector(state, "ledger_type"),
  };
}

export default compose(
  connect(mapStateToProps, { change, loadLedgerEntities }),
  reduxForm({ form: "counterparty" }),
)(CounterpartyDetailsForm);
```

---
## `CounterpartyDetailsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { connect } from "react-redux";
import { ClipLoader } from "react-spinners";
import { reduxForm, SubmitHandler } from "redux-form";
import { useMountEffect } from "~/common/utilities/useMountEffect";
import { submitCounterparty } from "../actions";
import CounterpartyDetailsForm from "./CounterpartyDetailsForm";
import {
  CounterpartyInput,
  UpsertCounterpartyMutationFn,
  useAuditableTextFieldLazyQuery,
  useCounterpartyDetailsViewQuery,
  useUpsertCounterpartyMutation,
} from "../../generated/dashboard/graphqlSchema";
import {
  Button,
  DateTime,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../common/ui-components";
import AuditableTextField from "./auditable_fields/AuditableTextField";
import { DispatchMessageFnType, useDispatchContext } from "../MessageProvider";

const COUNTERPARTY_MAPPING = {
  id: "ID",
  name: "Name",
  email: "Email",
  taxpayerIdentifier: "Taxpayer Identifier",
  sendRemittanceAdvice: "Remittance Notification",
  accountCollectionPending: "External Account Collection",
  accountingCategoryName: "Default Accounting Category",
  accountingLedgerClassName: "Default Accounting Class",
  verificationStatus: "Verification Status",
  createdAt: "Created At",
};

interface CounterpartyDetailsProps {
  setIsUpdatingCounterparty: (isUpdating: boolean) => void;
  errorMessage?: string;
  onPendingDocumentChange?: (docs: Record<string, Document>) => void;
}

interface ReduxProps {
  submitting: boolean;
  handleSubmit: SubmitHandler<
    Record<string, unknown>,
    CounterpartyDetailsProps,
    string
  >;
}

function CounterpartyDetails({
  setIsUpdatingCounterparty,
  handleSubmit,
  submitting,
  errorMessage,
  onPendingDocumentChange,
}: CounterpartyDetailsProps & ReduxProps) {
  return (
    <form autoComplete="off" className="form-create">
      <CounterpartyDetailsForm
        onPendingDocumentChange={onPendingDocumentChange}
      />

      <div className="form-group form-group-submit flex flex-row">
        <Button
          id="save-counterparty-details-btn"
          buttonType="primary"
          onClick={handleSubmit}
          disabled={submitting}
        >
          Save
        </Button>
        <Button
          className="ml-4"
          onClick={() => setIsUpdatingCounterparty(false)}
          disabled={submitting}
        >
          Cancel
        </Button>
        {submitting ? (
          <ClipLoader
            // Our usage if ClipLoader does not match the current types
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            loaderStyle={{ verticalAlign: "middle", marginLeft: "1rem" }}
          />
        ) : undefined}
        {errorMessage && <span className="error-message">{errorMessage}</span>}
      </div>
    </form>
  );
}

const ReduxedCounterpartyDetails = reduxForm<
  Record<string, unknown>,
  CounterpartyDetailsProps
>({
  // a unique name for the form
  form: "counterparty",
})(CounterpartyDetails);

interface CounterpartyDetailsViewProps {
  counterpartyId: string;
  isUpdatingCounterparty: boolean;
  setIsUpdatingCounterparty: (isUpdating: boolean) => void;
  submitCounterparty: (
    data: CounterpartyInput,
    mutation: UpsertCounterpartyMutationFn,
    callback: () => void | null,
    pendingDocuments: Record<string, unknown> | null,
    dispatchError: DispatchMessageFnType["dispatchError"],
  ) => Promise<void>;
}

function CounterpartyDetailsView({
  counterpartyId,
  isUpdatingCounterparty,
  setIsUpdatingCounterparty,
  submitCounterparty: submitCounterpartyFunc,
}: CounterpartyDetailsViewProps) {
  const [upsertCounterparty] = useUpsertCounterpartyMutation();
  const { data, loading, refetch } = useCounterpartyDetailsViewQuery({
    variables: {
      id: counterpartyId,
    },
  });
  const { dispatchError } = useDispatchContext();
  const counterparty = !data || loading ? null : data.counterparty;
  const bulkImport = !data || loading ? null : data.bulkImport;

  useMountEffect((): void => {
    if (isUpdatingCounterparty) {
      void refetch();
    }
  });

  const successCallback = () => {
    setIsUpdatingCounterparty(false);
    void refetch();
  };

  return (
    <div className="counterparty-details-view">
      {!isUpdatingCounterparty && !loading && counterparty ? (
        <KeyValueTable
          data={{
            id: counterparty.id,
            name: counterparty.name,
            email: counterparty.email,
            sendRemittanceAdvice: counterparty.sendRemittanceAdvice
              ? "Enabled"
              : "Disabled",
            accountCollectionPending: counterparty.accountCollectionPending
              ? "Sent Account Collection Email"
              : null,
            taxpayerIdentifier: counterparty.hasTaxpayerIdentifier ? (
              <AuditableTextField
                graphqlQuery={useAuditableTextFieldLazyQuery}
                queryVariables={{
                  id: counterparty.id,
                  resourceName: "Counterparty",
                  fieldName: "taxpayerIdentifier",
                }}
                fieldName="auditableTextField"
              />
            ) : null,
            accountingCategoryName: counterparty.accountingCategory?.name,
            accountingLedgerClassName: counterparty.accountingLedgerClass?.name,
            createdAt: <DateTime timestamp={counterparty.createdAt} />,
            verificationStatus: counterparty.prettyVerificationStatus,
            bulkImport: bulkImport ? (
              <a href={`/bulk_imports/${bulkImport.id}`}>{bulkImport.id}</a>
            ) : null,
          }}
          dataMapping={{
            ...COUNTERPARTY_MAPPING,
            ...(bulkImport ? { bulkImport: "Bulk Import" } : {}),
          }}
          copyableData={["id", "email"]}
        />
      ) : null}
      {loading && !counterparty && (
        <KeyValueTableSkeletonLoader dataMapping={COUNTERPARTY_MAPPING} />
      )}
      {isUpdatingCounterparty && counterparty ? (
        <ReduxedCounterpartyDetails
          setIsUpdatingCounterparty={setIsUpdatingCounterparty}
          onSubmit={(values) =>
            submitCounterpartyFunc(
              {
                ...values,
                id: counterpartyId,
              },
              upsertCounterparty,
              successCallback,
              null,
              dispatchError,
            )
          }
          initialValues={{
            name: counterparty.name,
            email: counterparty.email,
            send_remittance_advice: counterparty.sendRemittanceAdvice,
            accounting_category: counterparty.accountingCategory?.id,
            accounting_ledger_class: counterparty.accountingLedgerClass?.id,
          }}
        />
      ) : null}
    </div>
  );
}

export default connect(undefined, { submitCounterparty })(
  CounterpartyDetailsView,
);
```

---
## `CounterpartyDrawer.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Clickable, Drawer } from "../../common/ui-components";

import CounterpartyView from "../containers/CounterpartyView";

export function counterpartyDrawer(counterpartyId: string) {
  const trigger = (
    <Clickable onClick={() => {}}>
      <div className="text-blue-500 hover:text-blue-600">{counterpartyId}</div>
    </Clickable>
  );
  const counterpartyPath = `/counterparties/${counterpartyId}`;

  return (
    <Drawer trigger={trigger} path={counterpartyPath}>
      <CounterpartyView
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        match={{
          params: {
            counterparty_id: counterpartyId,
          },
        }}
      />
    </Drawer>
  );
}
```

---
## `CounterpartyForm.jsx.txt`
**Path:** `.`  
```
import React from "react";
import { compose } from "redux";
import { reduxForm, formValueSelector, Field, change } from "redux-form";
import { connect } from "react-redux";
import { ClipLoader } from "react-spinners";
import CounterpartyDetailsForm from "./CounterpartyDetailsForm";
import CounterpartyAccountFormSection from "./CounterpartyAccountFormSection";
import DocumentUploadContainer from "../containers/DocumentUploadContainer";
import { Button } from "../../common/ui-components";
import { COUNTERPARTY } from "../../generated/dashboard/types/resources";
import MetadataInput from "./MetadataInput";

function CounterpartyForm({
  handleSubmit,
  submitting,
  accounts,
  name,
  onPendingDocumentChange,
  change: reduxChange,
}) {
  return (
    <form autoComplete="off" className="form-create">
      <CounterpartyDetailsForm
        newCounterpartyForm
        onPendingDocumentChange={onPendingDocumentChange}
      />
      <div className="form-section">
        <h3>
          <span>Bank Accounts</span>
          <span className="addendum">OPTIONAL</span>
        </h3>

        <CounterpartyAccountFormSection
          counterpartyName={name}
          accounts={accounts}
          formName="counterparty"
        />
      </div>
      <div className="form-section">
        <h3>
          <span>Counterparty Metadata</span>
          <span className="addendum">OPTIONAL</span>
        </h3>
        <Field
          name="receiving_entity_metadata"
          component={MetadataInput}
          props={{
            resource: COUNTERPARTY,
            onChange: (metadata) => {
              reduxChange("receiving_entity_metadata", {
                ...metadata,
              });
            },
          }}
        />
      </div>
      <div className="form-section">
        <h3>
          <span>Documents</span>
          <span className="addendum">OPTIONAL</span>
        </h3>
        <DocumentUploadContainer
          skipInitialFetch
          enableSave={false}
          documentable_type="Counterparty"
          onPendingDocumentChange={onPendingDocumentChange}
        />
      </div>
      <div className="form-group">
        <Button
          buttonType="primary"
          onClick={handleSubmit}
          disabled={submitting}
        >
          Create
        </Button>
        {submitting ? (
          <ClipLoader
            loaderStyle={{ verticalAlign: "middle", marginLeft: "1rem" }}
          />
        ) : undefined}
      </div>
    </form>
  );
}

const selector = formValueSelector("counterparty");
function mapStateToProps(state) {
  return {
    accounts: selector(state, "accounts"),
    name: selector(state, "name"),
  };
}

export default compose(
  connect(mapStateToProps, { change }),
  reduxForm({ form: "counterparty" }),
)(CounterpartyForm);
```

---
## `CreateReconciliationSuggestionForm.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { ApolloQueryResult } from "@apollo/client";
import { Field, Form, Formik } from "formik";
import * as Yup from "yup";
import {
  StrategiesQuery,
  useCreateReconciliationSuggestionMutation,
  BatchTypeEnum,
} from "../../generated/dashboard/graphqlSchema";
import useErrorBanner from "../../common/utilities/useErrorBanner";
import {
  FormikErrorMessage,
  FormikInputField,
  FormikSelectField,
} from "../../common/formik";
import { Button, FieldGroup, Label } from "../../common/ui-components";
import FileTransferBatchTotalsView from "./FileTransferBatchTotalsView";

export interface Props {
  transactionId: string;
  refetchStrategies: () => Promise<ApolloQueryResult<StrategiesQuery>>;
}

const validate = Yup.object({
  transactableId: Yup.string().required("Transactable ID is required"),
  transactableType: Yup.string().required("Transactable type is required"),
});

const TRANSACTABLE_OPTIONS = [
  { label: "Payment Order", value: "PaymentOrder" },
  { label: "Incoming Payment Detail", value: "IncomingPaymentDetail" },
  { label: "Return", value: "Return" },
  { label: "Reversal", value: "Reversal" },
  { label: "Paper Item", value: "PaperItem" },
  { label: "Payment Order Batch", value: "PaymentOrderBatch" },
];

export default function CreateReconciliationSuggestionForm({
  transactionId,
  refetchStrategies,
}: Props) {
  const [createReconciliationSuggestion] =
    useCreateReconciliationSuggestionMutation({
      refetchQueries: ["ReconciliationSuggestionsView"],
    });

  const flashError = useErrorBanner();

  const batchTypeFromTransactableType = (
    transactableType: string | undefined,
  ): BatchTypeEnum | undefined => {
    if (transactableType != null) {
      switch (transactableType) {
        case "PaymentOrderBatch":
          return BatchTypeEnum.PaymentOrderBatch;
        case "ReturnReport":
          return BatchTypeEnum.ReturnReport;
        case "ReversalBatch":
          return BatchTypeEnum.ReversalBatch;
        default:
          return undefined;
      }
    }

    return undefined;
  };

  const showBatchSummary = (
    transactableId: string,
    transactableType: string,
  ) => {
    const batchType = batchTypeFromTransactableType(transactableType);
    if (batchType === undefined) {
      return null;
    }

    return (
      <div>
        <Label id="batchPreview">Batch Summary</Label>
        <FileTransferBatchTotalsView
          batchId={transactableId}
          batchType={batchType}
        />
      </div>
    );
  };

  const onSubmit = (transactableId: string, transactableType: string) => {
    createReconciliationSuggestion({
      variables: {
        input: {
          transactionId,
          transactableType,
          transactableId,
        },
      },
    })
      .then((result) => {
        if (result.errors) {
          flashError("Something went wrong!");
        } else if (
          result.data?.createReconciliationSuggestion?.errors?.length
        ) {
          flashError(result.data.createReconciliationSuggestion.errors[0]);
        } else {
          void refetchStrategies();
        }
      })
      .catch((err: Error) => {
        flashError(err.message);
      });
  };

  return (
    <Formik
      initialValues={{ transactableType: "", transactableId: "" }}
      onSubmit={({ transactableType, transactableId }, actions) => {
        onSubmit(transactableId, transactableType);
        actions.resetForm();
        actions.setSubmitting(false);
      }}
      validationSchema={validate}
    >
      {({ values, isSubmitting }) => (
        <Form>
          <FieldGroup>
            <Label id="transactableType">Transactable Type</Label>
            <Field
              id="transactableType"
              name="transactableType"
              component={FormikSelectField}
              options={TRANSACTABLE_OPTIONS}
            />
            <FormikErrorMessage name="transactableType" />
          </FieldGroup>
          <FieldGroup>
            <Label id="transactableId">Transactable ID</Label>
            <Field
              id="transactableId"
              name="transactableId"
              component={FormikInputField}
            />

            {showBatchSummary(values.transactableId, values.transactableType)}
            <FormikErrorMessage name="transactableId" />
          </FieldGroup>
          <Button buttonType="primary" isSubmit disabled={isSubmitting}>
            Create
          </Button>
        </Form>
      )}
    </Formik>
  );
}
```

---
## `CurrencyDropdown.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  ActionItem,
  Icon,
  Popover,
  PopoverPanel,
  PopoverTrigger,
} from "../../common/ui-components";
import trackEvent from "../../common/utilities/trackEvent";
import { ACCOUNT_ACTIONS } from "../../common/constants/analytics";

type CurrencyDropdownProps = {
  currencies: string[];
  selectedCurrency: string | null;
  setSelectedCurrency: (currency: string) => void;
  setGlobalDateFilterLabel?: () => void;
};

export default function CurrencyDropdown(props: CurrencyDropdownProps) {
  const {
    currencies,
    selectedCurrency,
    setSelectedCurrency,
    setGlobalDateFilterLabel,
  } = props;

  return currencies.length < 2 ? null : (
    <Popover>
      <PopoverTrigger buttonType="secondary">
        <Icon iconName="money_vs" size="s" />
        <div className="w-px border-l border-gray-200">&nbsp;</div>
        <div>{selectedCurrency ?? currencies[0]}</div>
        <Icon
          iconName="chevron_down"
          size="s"
          color="currentColor"
          className="text-gray-300"
        />
      </PopoverTrigger>
      <PopoverPanel anchorOrigin={{ horizontal: "right" }}>
        {(panelProps: { close: () => void }) => (
          <>
            {currencies.map((currency) => (
              <ActionItem
                key={currency}
                onClick={() => {
                  trackEvent(
                    null,
                    ACCOUNT_ACTIONS.CHANGED_GLOBAL_CURRENCY_FILTER,
                    {
                      path: window.location.pathname,
                    },
                  );
                  if (setGlobalDateFilterLabel) setGlobalDateFilterLabel();
                  setSelectedCurrency(currency);
                  panelProps.close();
                }}
              >
                <div id="payment-order">{currency}</div>
              </ActionItem>
            ))}
          </>
        )}
      </PopoverPanel>
    </Popover>
  );
}
```

---
## `CurrencySelector.tsx.txt`
**Path:** `.`  
```
import { Field } from "formik";
import React from "react";
import { FieldGroup, Label } from "../../common/ui-components";
import { CurrencyEnum } from "../../generated/dashboard/graphqlSchema";
import { FormikSelectField, FormikErrorMessage } from "../../common/formik";

const currencyOptions = Object.values(CurrencyEnum).map((value) => ({
  label: value,
  value,
}));

export interface CurrencySelectorProps {
  name?: string;
}

function CurrencySelector({ name }: CurrencySelectorProps) {
  return (
    <FieldGroup key="currency">
      <Label id="currency">Currency</Label>
      <Field
        id="currency"
        name={name || "currency"}
        options={currencyOptions}
        component={FormikSelectField}
      />
      <FormikErrorMessage name="currency" />
    </FieldGroup>
  );
}

export default CurrencySelector;
```

---
## `DatabaseReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import {
  MatchResult,
  useMatchResultQuery,
} from "../../generated/dashboard/graphqlSchema";
import {
  Label,
  Icon,
  Modal,
  ModalContainer,
  ModalFooter,
  Button,
  Stack,
  Chip,
  Clickable,
} from "../../common/ui-components";
import StringReconciliationMatchResult from "./StringReconciliationMatchResult";
import DateOffsetReconciliationMatchResult from
"./DateOffsetReconciliationMatchResult";
import PaymentReferenceReconciliationMatchResult from
"./PaymentReferenceReconciliationMatchResult";
import FromTransactionReconciliationMatchResult from
"./FromTransactionReconciliationMatchResult";
import GroupByReconciliationMatchResult from
"./GroupByReconciliationMatchResult";
import BooleanReconciliationMatchResult from
"./BooleanReconciliationMatchResult";
import { cn } from "~/common/utilities/cn";

interface DatabaseReconciliationMatchResultProps {
  matchResult: MatchResult;
  strategyName: string;
  matcherType: string;
  transactionId: string;
  callback: (
    id: string,
    matcher: string,
    parser: string,
    transactionField: string,
    matchResultType: string,
    modified: boolean,
    tentative: boolean,
  ) => void;
  modalOpen?: boolean;
  removable?: boolean;
}

function DatabaseReconciliationMatchResult({
  matchResult,
  strategyName,
  matcherType,
  transactionId,
  callback,
  modalOpen = false,
  removable = true,
}: DatabaseReconciliationMatchResultProps) {
  const matcherId = strategyName + matcherType + matchResult.field;
  const [initialMatcherValue] = useState(matchResult.matcher);
  const [currentMatcherValue, setCurrentMatcherValue] = useState<string | null>(
    initialMatcherValue,
  );
  const [tempMatcherValue, setTempMatcherValue] = useState(
    initialMatcherValue || null,
  );
  const [updatedMatcherValue, setUpdatedMatcherValue] = useState(
    initialMatcherValue || null,
  );
  const [offsetStart, setOffsetStart] = useState(matchResult.startOffset);
  const [offsetEnd, setOffsetEnd] = useState(matchResult.endOffset);
  const [currentMatched, setCurrentMatched] = useState(matchResult.match);
  const [expectedValue, setExpectedValue] = useState(matchResult.expected);
  const [actualValue, setActualValue] = useState(matchResult.actual);
  const selectFieldLabelMap = {
    equals: "Equals",
    matches_regex: "Matches",
    date_offset: "Between",
    payment_reference: "Payment Reference",
    short_id: "Short ID",
    from_transaction: "From Transaction",
    is_true: "Is True",
    is_false: "Is False",
    is_null: "Is Null",
    any: "Any",
    group_by: "Group By",
  };
  const selectFieldReverseLabelMap = {
    Equals: "equals",
    Matches: "matches_regex",
    Between: "date_offset",
    "Payment Reference": "payment_reference",
    "Short ID": "short_id",
    "From Transaction": "from_transaction",
    "Is True": "is_true",
    "Is False": "is_false",
    "Is Null": "is_null",
    Any: "any",
    "Group By": "group_by",
  };
  const [isModalOpen, setIsModalOpen] = useState(modalOpen);
  const [wasTentative] = useState(modalOpen);
  const [isTentative, setIsTentative] = useState(modalOpen);
  const newMatcher = matchResult.suggestedMatcher === "-new matcher-";
  const [hoverState, setHoverState] = useState(false);
  const [isRemovable] = useState(removable);
  const [openRemoveMatcherModal, setOpenRemoveMatcherModal] = useState(false);
  const [currentSelectField, setCurrentSelectField] = useState(
    matchResult.matchResultType
      ? (selectFieldLabelMap[matchResult.matchResultType] as string)
      : null,
  );
  const [tempMatchResultType, setTempMatchResultType] = useState(
    matchResult.matchResultType,
  );
  const [updatedMatchResultType, setUpdatedMatchResultType] = useState(
    matchResult.matchResultType,
  );
  const [tempSelectField, setTempSelectField] = useState(currentSelectField);
  const [parserValue, setParserValue] = useState(matchResult.parser);
  const [updatedParserValue, setUpdatedParserValue] = useState(
    matchResult.parser,
  );
  const [showParserValue, setShowParserValue] = useState(!!matchResult.parser);
  const [tempPaymentReferenceTypeValue, setTempPaymentReferenceTypeValue] =
    useState<string | undefined>(matchResult.matcher);
  const [transactionFieldValue, setTransactionFieldValue] = useState(
    matchResult.transactionField,
  );
  const [updatedTransactionFieldValue, setUpdatedTransactionFieldValue] =
    useState(matchResult.transactionField);
  const [tempTransactionField, setTempTransactionField] = useState(
    matchResult.transactionField,
  );
  const [startDateValue, setStartDateValue] = useState(matchResult.startDate);
  const [updatedStartDateValue, setUpdatedStartDateValue] = useState(
    matchResult.startDate,
  );
  const [endDateValue, setEndDateValue] = useState(matchResult.endDate);
  const [updatedEndDateValue, setUpdatedEndDateValue] = useState(
    matchResult.endDate,
  );
  const selectFieldOptions = [
    {
      label: "Equals",
      value: "Equals",
    },
    {
      label: "Matches Regex",
      value: "Matches",
    },
    {
      label: "Within Date Range",
      value: "Between",
    },
    {
      label: "Payment Reference",
      value: "Payment Reference",
    },
    {
      label: "Short ID",
      value: "Short ID",
    },
    {
      label: "From Transaction",
      value: "From Transaction",
    },
    {
      label: "Is True",
      value: "Is True",
    },
    {
      label: "Is False",
      value: "Is False",
    },
    {
      label: "Is Null",
      value: "Is Null",
    },
    {
      label: "Is Anything",
      value: "Any",
    },
  ];

  const { data: matchResultData } = useMatchResultQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      transactionId,
      matcherInput: {
        id: matcherId,
        strategyName,
        field: matchResult.field,
        matcherType,
        matcher: tempMatcherValue,
        transactionField: transactionFieldValue,
        parser: parserValue,
        matchResultType: tempMatchResultType,
        startDate: startDateValue,
        endDate: endDateValue,
      },
    },
  });

  const matchResultCallback = (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null | undefined,
    endDate: string | null | undefined,
  ) => {
    setExpectedValue(matchResultData?.matchResult?.expected || "");
    setActualValue(matchResultData?.matchResult?.actual || "");

    if (matchResultType) {
      setTempMatchResultType(
        selectFieldReverseLabelMap[matchResultType] as string,
      );
      setTempSelectField(matchResultType);
    }
    setTempMatcherValue(matcher || null);
    setParserValue(parser);
    setShowParserValue(showParser || false);
    setTransactionFieldValue(transactionField);
    setStartDateValue(startDate);
    setEndDateValue(endDate);
  };

  const matchResultHasChanged = () => {
    if (!matchResultData) {
      return false;
    }

    return (
      matchResult.matchResultType !==
        matchResultData.matchResult.matchResultType ||
      matchResult.matcher !== matchResultData.matchResult.matcher ||
      (matchResult.parser || null) !== matchResultData.matchResult.parser ||
      (matchResult.transactionField || null) !==
        matchResultData.matchResult.transactionField ||
      matchResult.startDate !== matchResultData.matchResult.startDate ||
      matchResult.endDate !== matchResultData.matchResult.endDate
    );
  };

  const matchResultIsEdited = () => {
    if (!matchResultData) {
      return false;
    }

    return (
      selectFieldReverseLabelMap[currentSelectField || ""] !==
        tempMatchResultType ||
      currentMatcherValue !== tempMatcherValue ||
      matchResultData.matchResult.parser !== parserValue ||
      matchResultData.matchResult.transactionField !== transactionFieldValue ||
      matchResultData.matchResult.startDate !== startDateValue ||
      matchResultData.matchResult.endDate !== endDateValue
    );
  };

  const matchResultIsUpdated = () => {
    if (!matchResultData) {
      return false;
    }

    return (
      matchResult.matchResultType !== updatedMatchResultType ||
      (matchResult.matcher !== updatedMatcherValue &&
        matchResult.matcher !== "" &&
        updatedMatcherValue !== null) ||
      matchResult.parser !== updatedParserValue ||
      matchResult.transactionField !== updatedTransactionFieldValue ||
      matchResult.startDate !== updatedStartDateValue ||
      matchResult.endDate !== updatedEndDateValue
    );
  };

  const updateDisabled = () => {
    if (matcherType === "payment_reference") {
      return !tempMatcherValue || !transactionFieldValue;
    }
    if (matcherType === "group_by") {
      const matchers =
        tempMatcherValue &&
        tempMatcherValue
          .slice(1, -1)
          .split(", ")
          .map((p) => p.slice(1));

      return Boolean(matchers && matchers.length === 1 && matchers[0] === "");
    }

    return false;
  };

  const groupByMatchers =
    currentSelectField === "Group By"
      ? currentMatcherValue
          ?.slice(1, -1)
          .split(", ")
          .map((p) => p.slice(1))
      : null;

  const matcherChips = (classNames: string, matched, hover) => {
    const rightChipClass = `${matched ? "rounded-r" : ""}`;
    let contentClasses = "";

    if (matched) {
      if (hover) {
        contentClasses = "bg-gray-500 text-white hover:cursor-pointer";
      } else {
        contentClasses = "";
      }
    } else if (hover) {
      contentClasses = "bg-red-500 text-white hover:cursor-pointer";
    } else {
      contentClasses = "bg-red-300 text-gray-900";
    }

    return (
      <Stack className={cn("overflow-hidden", classNames)}>
        {currentSelectField === "Equals" || currentSelectField === "Matches" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={contentClasses}>{currentSelectField}</Chip>
            <Chip
              className="whitespace-nowrap"
              contentClassName={`${contentClasses} ${rightChipClass}`}
            >
              {currentMatcherValue}
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Any" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              Is Anything
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Between" && offsetStart === offsetEnd && (
          <div className={`flex gap-px `}>
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={contentClasses}>Is </Chip>
            <Chip contentClassName={contentClasses}>{offsetStart}</Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              Business Days
            </Chip>
          </div>
        )}
        {currentSelectField === "Between" && offsetStart !== offsetEnd && (
          <div className={`flex gap-px `}>
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={contentClasses}>Is Between</Chip>
            <Chip contentClassName={contentClasses}>
              {offsetStart}..{offsetEnd}
            </Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              Business Days
            </Chip>
          </div>
        )}
        {currentSelectField === "Is Null" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              {currentSelectField}
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Payment Reference" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {tempPaymentReferenceTypeValue}
            </Chip>
            <Chip contentClassName={contentClasses}>Parsed From</Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              {tempTransactionField}
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Short ID" ||
        currentSelectField === "From Transaction" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={contentClasses}>From Transaction</Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              {currentMatcherValue}
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Is True" ||
        currentSelectField === "Is False" ? (
          <div className="flex gap-px">
            <Chip contentClassName={`${contentClasses} rounded-l`}>
              {matchResult.field}
            </Chip>
            <Chip contentClassName={`${contentClasses} ${rightChipClass}`}>
              {currentSelectField}
            </Chip>
          </div>
        ) : null}
        {currentSelectField === "Group By" ? (
          <div className="flex gap-px overflow-x-scroll">
            {groupByMatchers?.map((m, i) => (
              <Chip
                contentClassName={`${i === 0 ? "rounded-l" : ""} ${
                  i === (groupByMatchers?.length || 1) - 1 ? "rounded-r" : ""
                } ${contentClasses}`}
              >
                {m}
              </Chip>
            ))}
          </div>
        ) : null}
      </Stack>
    );
  };

  return (
    <div className="pr-2">
      <Modal
        isOpen={isModalOpen}
        title={matchResult.field}
        onRequestClose={() => {
          if (!isTentative) setIsModalOpen(false);
        }}
      >
        <ModalContainer>
          <div className="p-2">
            <div className="flex">
              <Label className="flex pb-2 pl-4 text-base font-medium">
                {matchResult.field}
              </Label>

              <div className="ml-auto flex pl-2 pr-2">
                {matchResultHasChanged() && !wasTentative ? (
                  <Clickable
                    onClick={() => {
                      matchResultCallback(
                        matchResult.matchResultType
                          ? (selectFieldLabelMap[
                              matchResult.matchResultType
                            ] as string)
                          : currentSelectField,
                        matchResult.matcher,
                        matchResult.parser,
                        !!matchResult.parser,
                        matchResult.transactionField,
                        matchResult.startDate || null,
                        matchResult.endDate || null,
                      );
                    }}
                  >
                    <div className="mb-2 flex rounded-sm  border px-2">
                      <Icon
                        className="self-center text-gray-500"
                        iconName="sync"
                        color="currentColor"
                        size="s"
                      />
                      <Label className="flex self-center p-1 text-xs
                      hover:cursor-pointer">
                        Reset Change
                      </Label>
                    </div>
                  </Clickable>
                ) : null}
              </div>
              {matchResultData?.matchResult.match ? (
                <Icon
                  className="justify-right flex pb-2 text-green-500"
                  iconName="checkmark_circle"
                  color="currentColor"
                  size="l"
                />
              ) : (
                <Icon
                  className="justify-right flex pb-2 text-red-500"
                  iconName="remove_circle"
                  color="currentColor"
                  size="l"
                />
              )}
            </div>

            <div className="border-mt-gray-200 border-t p-2" />
            <div className="form-row flex w-full border-b-2 border-gray-50">
              {tempSelectField === "Equals" ||
              tempSelectField === "Matches" ||
              tempSelectField === "Any" ||
              tempSelectField === "Is Null" ? (
                <StringReconciliationMatchResult
                  selectField={tempSelectField}
                  selectFieldOptions={selectFieldOptions.filter(
                    (op) =>
                      matchResultData?.matchResult?.matchResultTypeOptions
                        ?.map((o) => selectFieldLabelMap[o] as string)
                        ?.includes(op.value),
                  )}
                  matcher={tempMatcherValue}
                  suggestedMatcher={
                    matchResultData?.matchResult?.suggestedMatcher
                  }
                  callback={matchResultCallback}
                />
              ) : null}
              {tempSelectField === "Between" ? (
                <DateOffsetReconciliationMatchResult
                  selectField={tempSelectField}
                  selectFieldOptions={selectFieldOptions.filter(
                    (op) =>
                      matchResultData?.matchResult?.matchResultTypeOptions
                        ?.map((o) => selectFieldLabelMap[o] as string)
                        ?.includes(op.value),
                  )}
                  matcher={tempMatcherValue || ""}
                  startOffset={matchResultData?.matchResult?.startOffset}
                  endOffset={matchResultData?.matchResult?.endOffset}
                  startDate={matchResultData?.matchResult?.startDate}
                  endDate={matchResultData?.matchResult?.endDate}
                  callback={matchResultCallback}
                />
              ) : null}
              {tempSelectField === "Payment Reference" ? (
                <PaymentReferenceReconciliationMatchResult
                  selectFieldOptions={
                    matchResultData?.matchResult?.matchResultTypeOptions?.map(
                      (e) => ({ label: e, value: e }),
                    ) || []
                  }
                  matcher={tempMatcherValue}
                  referenceValue={matchResultData?.matchResult?.expected}
                  parser={parserValue}
                  showParser={showParserValue}
                  transactionField={transactionFieldValue}
                  transactionFieldString={
                    matchResultData?.matchResult?.transactionFieldValue
                  }
                  suggestedMatcher={
                    matchResultData?.matchResult?.suggestedMatcher
                  }
                  callback={matchResultCallback}
                />
              ) : null}
              {tempSelectField === "Short ID" ||
              tempSelectField === "From Transaction" ? (
                <FromTransactionReconciliationMatchResult
                  selectField={tempSelectField}
                  selectFieldOptions={selectFieldOptions.filter(
                    (op) =>
                      matchResultData?.matchResult?.matchResultTypeOptions
                        ?.map((o) => selectFieldLabelMap[o] as string)
                        ?.includes(op.value),
                  )}
                  matcher={tempMatcherValue}
                  parser={parserValue}
                  showParser={showParserValue}
                  transactionField={transactionFieldValue}
                  transactionFieldString={
                    matchResultData?.matchResult?.transactionFieldValue
                  }
                  suggestedMatcher={
                    matchResultData?.matchResult?.suggestedMatcher
                  }
                  callback={matchResultCallback}
                />
              ) : null}
              {tempSelectField === "Is True" ||
              tempSelectField === "Is False" ? (
                <BooleanReconciliationMatchResult
                  selectField={tempSelectField}
                  selectFieldOptions={selectFieldOptions.filter(
                    (op) =>
                      matchResultData?.matchResult?.matchResultTypeOptions
                        ?.map((o) => selectFieldLabelMap[o] as string)
                        ?.includes(op.value),
                  )}
                  callback={matchResultCallback}
                />
              ) : null}
              {tempSelectField === "Group By" ? (
                <GroupByReconciliationMatchResult
                  selectFieldOptions={(
                    matchResultData?.matchResult?.matchResultTypeOptions ||
                    matchResult.matchResultTypeOptions ||
                    []
                  ).map((e) => ({ value: e, label: e }))}
                  matcher={tempMatcherValue}
                  groupBy={matchResultData?.matchResult?.groupBy}
                  groupByGroups={matchResultData?.matchResult?.groupByGroups}
                  suggestedMatcher={
                    matchResultData?.matchResult?.suggestedMatcher
                  }
                  callback={matchResultCallback}
                />
              ) : null}
            </div>

            <div className="flex flex-col pt-2">
              <div className="flex">
                <Label className="justify-right ml-auto flex self-center pb-1
                pr-1 font-medium">
                  Expected:
                </Label>
                <Label className="flex break-all pb-1">
                  {matchResultData?.matchResult?.expected || expectedValue}
                </Label>
              </div>
              <div className="form-row flex w-full border-t border-gray-25 pb-2"
              />
              <div className="flex">
                <Label className="justify-right ml-auto flex self-center pb-2
                pl-6 pr-1 font-medium">
                  Actual:
                </Label>
                <Label className="flex break-all pb-2">
                  {matchResultData?.matchResult?.actual || actualValue}
                </Label>
              </div>
            </div>
          </div>

          <ModalFooter className="-mt-3 border-none">
            <div className="flex w-full space-x-4">
              <Button
                buttonType="secondary"
                className="flex-1"
                onClick={() => {
                  setIsModalOpen(false);
                  setTempMatchResultType(updatedMatchResultType);
                  setTempMatcherValue(updatedMatcherValue);
                  if (isTentative)
                    callback(matcherId, "", "", "", "", false, true);
                }}
              >
                Cancel
              </Button>
              <Button
                id="reconcile-items-button"
                buttonType="primary"
                isSubmit
                disabled={
                  (!matchResultHasChanged() &&
                    !matchResultIsEdited() &&
                    !matchResultIsUpdated() &&
                    !isTentative) ||
                  matchResultData === null ||
                  updateDisabled()
                }
                className="flex-1"
                onClick={() => {
                  setIsModalOpen(false);
                  setUpdatedMatcherValue(tempMatcherValue);
                  setUpdatedMatchResultType(tempMatchResultType);
                  setUpdatedParserValue(parserValue);
                  setUpdatedTransactionFieldValue(transactionFieldValue);
                  setUpdatedStartDateValue(startDateValue);
                  setUpdatedEndDateValue(endDateValue);
                  setCurrentSelectField(tempSelectField);

                  const matcherVal =
                    tempSelectField === "Between"
                      ? `${String(
                          matchResultData?.matchResult?.startOffset,
                        )}..${String(matchResultData?.matchResult?.endOffset)}`
                      : tempMatcherValue;

                  setTempMatcherValue(matcherVal);
                  setCurrentMatcherValue(matcherVal);
                  setCurrentMatched(
                    matchResultData?.matchResult.match || false,
                  );
                  setOffsetStart(matchResultData?.matchResult?.startOffset);
                  setOffsetEnd(matchResultData?.matchResult?.endOffset);
                  setTempTransactionField(
                    matchResultData?.matchResult?.transactionField,
                  );
                  setTempPaymentReferenceTypeValue(
                    matchResultData?.matchResult?.matcher,
                  );
                  callback(
                    matcherId,
                    matcherVal || "",
                    parserValue || "",
                    transactionFieldValue || "",
                    tempMatchResultType || "",
                    matchResultHasChanged() ||
                      matchResultIsEdited() ||
                      isTentative,
                    false,
                  );
                  setIsTentative(false);
                }}
              >
                {isTentative ? "Add Matcher" : "Update"}
              </Button>
            </div>
          </ModalFooter>
        </ModalContainer>
      </Modal>

      <div
        className="mb-1 flex w-full"
        onMouseEnter={() => setHoverState(true)}
        onMouseLeave={() => setHoverState(false)}
      >
        {matchResultIsUpdated() || newMatcher ? (
          <Icon
            className="mr-1 self-center text-blue-400"
            iconName="circle"
            color="currentColor"
            size="s"
          />
        ) : (
          <Icon
            className="mr-1 self-center text-white"
            iconName="circle"
            color="currentColor"
            size="s"
          />
        )}

        <Clickable onClick={() => setIsModalOpen(true)} cursorStyle="pointer">
          <div
            className={`flex w-full flex-row justify-start overflow-hidden
            rounded  ${
              currentMatched ? "" : "bg-red-300 hover:bg-red-500"
            }`}
          >
            {matcherChips("", currentMatched, hoverState)}

            {!currentMatched ? (
              <div className="ml-auto flex self-center">
                <Label className="mr-1 whitespace-nowrap italic text-red-600">
                  Click to debug
                </Label>
                <Icon
                  className="mr-1 text-red-500"
                  iconName="error_outlined"
                  color="currentColor"
                  size="m"
                />
              </div>
            ) : null}
          </div>
        </Clickable>
        {(!hoverState || !isRemovable) && (
          <Clickable onClick={() => null}>
            <div className="self-center">
              <Icon
                className="ml-1 self-center text-white"
                iconName="remove"
                color="currentColor"
                size="m"
                alignment="baseline"
              />
            </div>
          </Clickable>
        )}
        {hoverState && isRemovable && (
          <Clickable onClick={() => setOpenRemoveMatcherModal(true)}>
            <div className="self-center">
              <Icon
                className="ml-1 self-center text-gray-400"
                iconName="remove"
                color="currentColor"
                size="m"
                alignment="baseline"
              />
            </div>
          </Clickable>
        )}

        <Modal
          isOpen={openRemoveMatcherModal}
          title="Remove Matcher"
          onRequestClose={() => setOpenRemoveMatcherModal(false)}
        >
          <ModalContainer>
            <div className="p-2 py-4">
              <Label className="ml-auto mr-auto flex">
                Remove <b className="px-1">{matchResult.field}</b> matcher?
              </Label>
              {matcherChips("flex justify-center pt-2", true, false)}
            </div>

            <ModalFooter className="-mt-3 border-none">
              <div className="flex w-full space-x-4">
                <Button
                  buttonType="secondary"
                  className="flex-1"
                  onClick={() => {
                    setOpenRemoveMatcherModal(false);
                  }}
                >
                  Wait nevermind
                </Button>
                <Button
                  id="reconcile-items-button"
                  buttonType="primary"
                  isSubmit
                  className="flex-1"
                  onClick={() => {
                    callback(
                      matcherId,
                      "",
                      "",
                      selectFieldReverseLabelMap[
                        currentSelectField as string
                      ] as string,
                      "",
                      true,
                      true,
                    );
                  }}
                >
                  Okay
                </Button>
              </div>
            </ModalFooter>
          </ModalContainer>
        </Modal>
      </div>
    </div>
  );
}

export default DatabaseReconciliationMatchResult;
```

---
## `DatabaseReconciliationStrategy.tsx.txt`
**Path:** `.`  
```
import React, { useRef, useState } from "react";
import ReactTooltip from "react-tooltip";
import { ClipLoader } from "react-spinners";
import { Field, Form, Formik, FormikProps } from "formik";
import { cn } from "~/common/utilities/cn";
import {
  MatchResult,
  MatchResultInput,
  Strategy,
  useReviewReconciliationStrategyMutation,
  useUpdateReconciliationStrategyMutation,
  useReconciliationStrategyResultLazyQuery,
  StrategyInput,
} from "../../generated/dashboard/graphqlSchema";
import {
  Accordion,
  AccordionButton,
  AccordionIcon,
  AccordionItem,
  AccordionPanel,
  Button,
  Clickable,
  FieldsRow,
  Icon,
  Label,
  Modal,
  ModalContainer,
  ModalFooter,
  SelectField,
  Toggle,
  Tooltip,
} from "../../common/ui-components";
import { FormikInputField } from "../../common/formik";
import colors from "../../common/styles/colors";
import DatabaseReconciliationMatchResult from
"./DatabaseReconciliationMatchResult";
import EntityTableView from "./EntityTableView";
import { useDispatchContext } from "../MessageProvider";
import { CursorPaginationInput } from "../types/CursorPaginationInput";

const PER_PAGE = 10;

const STYLE_MAPPING = {
  entityId: "table-entry-wide table-entry-hide-small",
};

const RESULT_MAPPING: Record<string, Record<string, string>> = {
  PaperItem: {
    __typename: "Transactable Type",
    id: "ID",
    amount: "Amount",
  },
  IncomingPaymentDetail: {
    __typename: "Transactable Type",
    id: "ID",
    prettyAmount: "Amount",
    prettyDirection: "Direction",
  },
  Return: {
    __typename: "Transactable Type",
    id: "ID",
    amount: "Amount",
  },
  Reversal: {
    __typename: "Transactable Type",
    id: "ID",
    paymentOrderAmount: "Amount",
  },
  ExpectedPayment: {
    __typename: "Transactable Type",
    id: "ID",
    prettyAmountRange: "Amount Range",
  },
  PaymentOrder: {
    __typename: "Transactable Type",
    id: "ID",
    prettyAmount: "Amount",
    prettyDirection: "Direction",
  },
};

interface DatabaseReconciliationStrategyProps {
  strategy: Strategy;
  transactionId: string;
}

function DatabaseReconciliationStrategy({
  strategy,
  transactionId,
}: DatabaseReconciliationStrategyProps) {
  interface FormValues {
    reconEnabledIf?: string | null | undefined;
    reconDisabledIf?: string | null | undefined;
  }

  const formikRef = useRef<FormikProps<FormValues>>(null);
  const needsApproval = strategy.status === "needs_review";
  const [showReconResults, setShowReconResults] = useState(false);
  const [strategyName, setStrategyName] = useState(strategy.name);
  const [transactableMatchResultState, setTransactableMatchResultState] =
    useState<MatchResult[]>(strategy.transactableMatchResults || []);
  const [transactionMatchResultState, setTransactionMatchResultState] =
    useState<MatchResult[]>(strategy.transactionMatchResults || []);
  const matchResults = transactableMatchResultState.concat(
    transactionMatchResultState,
  );

  const [
    transactableMatchResultInputState,
    setTransactableMatchResultInputState,
  ] = useState<MatchResultInput[]>(
    transactableMatchResultState.map((mr) => ({
      id: strategy.name + mr.matcherType + mr.field,
      matchResultType: mr.matchResultType,
      strategyName: strategy.name,
      field: mr.field,
      matcherType: mr.matcherType,
      matcher: mr.matcher,
      transactionField: mr.transactionField,
      parser: mr.parser,
      systemDefault: mr.systemDefault,
    })),
  );
  const [
    transactionMatchResultInputState,
    setTransactionMatchResultInputState,
  ] = useState<MatchResultInput[]>(
    transactionMatchResultState
      .filter((mr) => mr.field !== "reconciled")
      .map((mr) => ({
        id: strategy.name + mr.matcherType + mr.field,
        matchResultType: mr.matchResultType,
        strategyName: strategy.name,
        field: mr.field,
        matcherType: mr.matcherType,
        matcher: mr.matcher,
        transactionField: mr.transactionField,
        parser: mr.parser,
        systemDefault: mr.systemDefault,
      })),
  );
  const [
    paymentReferenceMatchResultState,
    setPaymentReferenceMatchResultState,
  ] = useState<MatchResult | null>(
    strategy.paymentReferenceMatchResult || null,
  );
  const [
    paymentReferenceMatchResultInputState,
    setPaymentReferenceMatchResultInputState,
  ] = useState<MatchResultInput | null>(
    strategy.paymentReferenceMatchResult
      ? {
          id: "payment_reference",
          matchResultType: "payment_reference",
          strategyName: strategy.name,
          field: strategy.paymentReferenceMatchResult.field,
          matcherType: strategy.paymentReferenceMatchResult.matcherType,
          matcher: strategy.paymentReferenceMatchResult.matcher,
          transactionField:
            strategy.paymentReferenceMatchResult?.transactionField,
          parser: strategy.paymentReferenceMatchResult.parser,
          systemDefault: false,
        }
      : null,
  );
  const [groupByState, setGroupByState] = useState<string[]>(strategy.groupBy);

  const [updatedMatchers, setUpdatedMatchers] = useState<string[]>([]);

  const [removedTransactableMatchers, setRemovedTransactableMatchers] =
    useState<string[]>([]);
  const [removedTransactionMatchers, setRemovedTransactionMatchers] = useState<
    string[]
  >([]);

  const matchResultCallback = (
    id: string,
    matcher: string,
    parser: string,
    transactionField: string,
    matchResultType: string,
    modified: boolean,
    tentative: boolean,
  ) => {
    if (tentative) {
      setTransactableMatchResultState(
        transactableMatchResultState.filter(
          (mr) => `${strategy.name}${mr.matcherType}${mr.field}` !== id,
        ),
      );

      setTransactionMatchResultState(
        transactionMatchResultState.filter(
          (mr) => `${strategy.name}${mr.matcherType}${mr.field}` !== id,
        ),
      );

      setTransactableMatchResultInputState(
        transactableMatchResultInputState.filter((mr) => mr.id !== id),
      );

      setTransactionMatchResultInputState(
        transactionMatchResultInputState.filter((mr) => mr.id !== id),
      );

      if (
        strategy.transactableMatchResults
          ?.map((mr) => `${strategy.name}${mr.matcherType}${mr.field}`)
          ?.includes(id)
      ) {
        setRemovedTransactableMatchers([...removedTransactableMatchers, id]);
      }

      if (
        strategy.transactionMatchResults
          ?.map((mr) => `${strategy.name}${mr.matcherType}${mr.field}`)
          ?.includes(id)
      ) {
        setRemovedTransactionMatchers([...removedTransactionMatchers, id]);
      }

      if (id.endsWith("payment_reference")) {
        setPaymentReferenceMatchResultState(null);
        setPaymentReferenceMatchResultInputState(null);
      }
    } else {
      setTransactableMatchResultInputState(
        transactableMatchResultInputState.map((mri) => {
          if (mri.id === id) {
            return {
              ...mri,
              matcher,
              parser,
              matchResultType,
            };
          }
          return mri;
        }),
      );
      setTransactionMatchResultInputState(
        transactionMatchResultInputState.map((mri) => {
          if (mri.id === id) {
            return { ...mri, matcher, matchResultType };
          }
          return mri;
        }),
      );

      if (id.endsWith("group_by")) {
        const groupBy = matcher
          .slice(1, -1)
          .split(", ")
          .map((e) => e.slice(1));
        setGroupByState(groupBy);
      }

      if (id.endsWith("payment_reference")) {
        setPaymentReferenceMatchResultInputState({
          id,
          matchResultType,
          strategyName: strategy.name,
          field: "payment_reference",
          matcherType: "payment_reference",
          matcher,
          transactionField,
          parser,
          systemDefault: false,
        });
      }
    }

    if (modified) {
      setUpdatedMatchers([...updatedMatchers.filter((m) => m !== id), id]);
    } else {
      setUpdatedMatchers(updatedMatchers.filter((m) => m !== id));
    }

    if (removedTransactableMatchers.includes(id)) {
      setRemovedTransactableMatchers(
        removedTransactableMatchers.filter((rid) => rid !== id),
      );
    }
    if (removedTransactionMatchers.includes(id)) {
      setRemovedTransactionMatchers(
        removedTransactionMatchers.filter((rid) => rid !== id),
      );
    }
  };

  const { dispatchError } = useDispatchContext();

  const [
    updateReconciliationStrategy,
    { data: updateStrategyData, loading: updateStrategyLoading },
  ] = useUpdateReconciliationStrategyMutation();

  const [reviewReconciliationStrategy] =
    useReviewReconciliationStrategyMutation();

  const [amountMismatchToggle, setAmountMismatchToggle] = useState(
    strategy.allowAmountMismatch,
  );
  const [ambiguousToggle, setAmbiguousToggle] = useState(
    strategy.allowAmbiguous,
  );
  const [customToggle, setCustomToggle] = useState(strategy.custom);
  const [priority, setPriority] = useState(strategy.priority);
  const [resetToggle, setResetToggle] = useState(false);
  const [showDiffModal, setShowDiffModal] = useState(false);
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [note, setNote] = useState<string | undefined>(undefined);

  const initialValues = {
    reconDisabledIf: strategy.reconDisabledIf,
    reconEnabledIf: strategy.reconEnabledIf,
  };

  const optionsHasChanged = () => {
    const reconEnabled =
      formikRef?.current?.values?.reconEnabledIf === undefined ||
      formikRef?.current?.values?.reconEnabledIf === ""
        ? null
        : formikRef?.current?.values?.reconEnabledIf;
    const reconDisabled =
      formikRef?.current?.values?.reconDisabledIf === undefined ||
      formikRef?.current?.values?.reconDisabledIf === ""
        ? null
        : formikRef?.current?.values?.reconDisabledIf;

    return (
      ambiguousToggle !== strategy.allowAmbiguous ||
      amountMismatchToggle !== strategy.allowAmountMismatch ||
      customToggle !== strategy.custom ||
      priority !== strategy.priority ||
      reconEnabled !== strategy.reconEnabledIf ||
      reconDisabled !== strategy.reconDisabledIf
    );
  };

  const strategyHasChanged = () =>
    updatedMatchers.length > 0 ||
    optionsHasChanged() ||
    (strategyName !== strategy.name && strategy.status !== "tentative");

  const resetStrategy = () => {
    setStrategyName(strategy.name);
    setTransactableMatchResultState(strategy.transactableMatchResults || []);
    setTransactionMatchResultState(strategy.transactionMatchResults || []);

    setTransactableMatchResultInputState(
      (strategy.transactableMatchResults || []).map((mr) => ({
        id: strategy.name + mr.matcherType + mr.field,
        matchResultType: mr.matchResultType,
        strategyName: strategy.name,
        field: mr.field,
        matcherType: mr.matcherType,
        matcher: mr.matcher,
        transactionField: mr.transactionField,
        parser: mr.parser,
        systemDefault: mr.systemDefault,
      })),
    );
    setTransactionMatchResultInputState(
      (strategy.transactionMatchResults || [])
        .filter((mr) => mr.field !== "reconciled")
        .map((mr) => ({
          id: strategy.name + mr.matcherType + mr.field,
          matchResultType: mr.matchResultType,
          strategyName: strategy.name,
          field: mr.field,
          matcherType: mr.matcherType,
          matcher: mr.matcher,
          transactionField: mr.transactionField,
          parser: mr.parser,
          systemDefault: mr.systemDefault,
        })),
    );
    setRemovedTransactableMatchers([]);
    setRemovedTransactionMatchers([]);

    setPaymentReferenceMatchResultState(
      strategy.paymentReferenceMatchResult || null,
    );
    setPaymentReferenceMatchResultInputState(
      strategy.paymentReferenceMatchResult
        ? {
            id: "payment_reference",
            matchResultType: "payment_reference",
            strategyName: strategy.name,
            field: strategy.paymentReferenceMatchResult.field,
            matcherType: strategy.paymentReferenceMatchResult.matcherType,
            matcher: strategy.paymentReferenceMatchResult.matcher,
            transactionField:
              strategy.paymentReferenceMatchResult?.transactionField,
            parser: strategy.paymentReferenceMatchResult.parser,
            systemDefault: false,
          }
        : null,
    );

    setGroupByState(strategy.groupBy);

    setAmountMismatchToggle(strategy.allowAmountMismatch);
    setAmbiguousToggle(strategy.allowAmbiguous);
    setCustomToggle(strategy.custom);
    setPriority(strategy.priority);
    void formikRef?.current?.setValues({
      reconEnabledIf: strategy.reconEnabledIf || "",
      reconDisabledIf: strategy.reconDisabledIf || "",
    });

    setUpdatedMatchers([]);
    setResetToggle(!resetToggle);
  };

  const [
    getReconciliationStrategyResults,
    {
      loading: resultsLoading,
      data: resultsData,
      error: resultsError,
      refetch: resultsRefetch,
    },
  ] = useReconciliationStrategyResultLazyQuery({
    variables: {
      first: PER_PAGE,
      transactionId,
      strategy: {
        name: strategyName,
        vendor: strategy.vendor,
        transactableType: strategy.transactableType,
        paymentType: strategy.paymentType,
        role: strategy.role,
        transactionMatchResultInputs: transactionMatchResultInputState,
        transactableMatchResultInputs: transactableMatchResultInputState,
        paymentReferenceMatchResultInput: paymentReferenceMatchResultInputState,
        allowAmountMismatch: amountMismatchToggle,
        allowAmbiguous: ambiguousToggle,
        custom: customToggle,
        groupBy: groupByState,
        priority,
        reconDisabledIf:
          formikRef?.current?.values?.reconDisabledIf === ""
            ? null
            : formikRef?.current?.values?.reconDisabledIf,
        reconEnabledIf:
          formikRef?.current?.values?.reconEnabledIf === ""
            ? null
            : formikRef?.current?.values?.reconEnabledIf,
      } as StrategyInput,
    },
  });

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
  }) => {
    const { cursorPaginationParams } = options;
    await resultsRefetch({
      ...cursorPaginationParams,
    });
  };

  const reconciliationResults =
    !resultsLoading && !resultsError && resultsData
      ? resultsData?.reconciliationStrategyResult?.edges || []
      : [];

  const [addTransactableMatcher, setAddTransactableMatcher] = useState(false);
  const [addTransactionMatcher, setAddTransactionMatcher] = useState(false);
  const [addPaymentReferenceMatcher, setAddPaymentReferenceMatcher] =
    useState(false);
  const [transactableHoverState, setTransactableHoverState] = useState(false);
  const [transactionHoverState, setTransactionHoverState] = useState(false);
  const [addPaymentReferenceHoverState, setAddPaymentReferenceHoverState] =
    useState(false);

  return (
    <div
      className={`mx-6 ${
        needsApproval || strategy.status !== "active"
          ? "border-4 border-purple-300a"
          : ""
      } ${!needsApproval || !strategy.parentStrategyId ? "mt-6" : ""}`}
    >
      <div>
        <div className="rounded-md border border-alpha-black-100 bg-white pb-4
        pt-2">
          <div className="flex px-6 py-1">
            <div className="mr-auto flex">
              <Icon iconName="money_vs" className="mr-2 min-w-5 self-center" />
              {strategyHasChanged() && (
                <Icon
                  className="mr-2 self-center text-blue-400"
                  iconName="circle"
                  color="currentColor"
                  size="s"
                />
              )}
              {needsApproval ? (
                <span className="w-full self-center text-nowrap text-base font-
                medium">
                  {strategyName}
                </span>
              ) : (
                <textarea
                  className="w-full resize-none self-center text-nowrap text-
                  base font-medium disabled:bg-white"
                  onChange={(e) => setStrategyName(e.target.value)}
                  value={
                    strategyName === "New Strategy" ? undefined : strategyName
                  }
                  placeholder="Enter strategy name"
                  rows={1}
                  cols={strategyName.length}
                />
              )}
              {needsApproval && (
                <Label className="ml-3 flex justify-center self-center text-
                nowrap border-2 border-purple-300a bg-gray-50 p-1 font-mono
                font-bold italic text-purple-300a">
                  Suggested {strategy.parentStrategyId ? "Change" : "Strategy"}
                </Label>
              )}
              {strategy.status === "tentative" && (
                <Label className="ml-4 flex justify-center self-center text-
                nowrap border-2 border-purple-300a bg-gray-50 p-1 font-mono
                font-bold italic text-purple-300a">
                  Tentative
                </Label>
              )}
            </div>

            <div className="flex">
              {strategyHasChanged() ? (
                <Clickable
                  onClick={() => {
                    resetStrategy();
                  }}
                >
                  <div className="mx-2 mb-2 flex rounded-sm border px-2">
                    <Icon
                      className="self-center text-gray-500"
                      iconName="sync"
                      color="currentColor"
                      size="s"
                    />
                    <Label className="flex min-w-24 self-center p-1 text-xs
                    hover:cursor-pointer">
                      Reset Changes
                    </Label>
                  </div>
                </Clickable>
              ) : null}

              {needsApproval && (
                <Label
                  className="ml-2 mr-2 flex flex-wrap self-center text-nowrap
                  pb-2 font-mono font-bold"
                  labelPrefix="Suggested By:"
                >
                  {strategy.createdByName}
                </Label>
              )}

              <div className="flex self-center pb-2 pr-2">
                {matchResults.every((mr) => mr.match) ? (
                  <Icon
                    className="float-right text-green-500"
                    iconName="checkmark_circle"
                    color="currentColor"
                    size="xl"
                  />
                ) : (
                  <Icon
                    className="float-right self-center text-red-500"
                    iconName="remove_circle"
                    color="currentColor"
                    size="xl"
                  />
                )}
              </div>
            </div>
          </div>
          <div className="border-mt-gray-200 mx-6 mr-6 border-t p-2" />

          {strategy.status === "tentative" && (
            <Label className="mb-1 flex w-full justify-center text-center
            italic">
              This tentative strategy has been auto-filled with matchers
              detected by our system. Feel free to edit below.
            </Label>
          )}

          <Formik
            initialValues={initialValues}
            enableReinitialize
            innerRef={formikRef}
            onSubmit={() => {}}
          >
            {() => (
              <Form>
                <div>
                  {needsApproval && strategy.note && (
                    <Label
                      className="mx-4 mb-2 w-full border bg-gray-25 p-2 italic"
                      labelPrefix="Note for reviewer:"
                    >
                      {strategy.note}
                    </Label>
                  )}
                  {transactableMatchResultState.filter(
                    (mr) => !mr.match || !mr.systemDefault,
                  ).length > 0 &&
                    !customToggle && (
                      <Label className="pb-2 pl-6 text-base">
                        {strategy.transactableType} Matchers
                      </Label>
                    )}
                  <div className="pl-3">
                    {!customToggle &&
                      transactableMatchResultState
                        .filter((mr) => !mr.match || !mr.systemDefault)
                        .map((matchResult) => (
                          <DatabaseReconciliationMatchResult
                            key={`${matchResult.field}${
                              matchResult.matcherType
                            }${resetToggle ? "true" : "false"}`}
                            matchResult={matchResult}
                            strategyName={strategy.name}
                            matcherType="transactables"
                            transactionId={transactionId}
                            callback={matchResultCallback}
                            modalOpen={
                              matchResult.suggestedMatcher === "-new matcher-"
                            }
                          />
                        ))}
                  </div>

                  {!addTransactableMatcher && !customToggle && (
                    <Clickable onClick={() => setAddTransactableMatcher(true)}>
                      <div
                        className="flex pb-1 pl-6"
                        onMouseEnter={() => setTransactableHoverState(true)}
                        onMouseLeave={() => setTransactableHoverState(false)}
                      >
                        <Icon
                          className="ml-2 text-gray-400"
                          iconName="add"
                          color="currentColor"
                          size="s"
                        />

                        {transactableHoverState && (
                          <Label className="ml-1 text-xs text-gray-500
                          hover:cursor-pointer">
                            Add Transactable Matcher
                          </Label>
                        )}
                      </div>
                    </Clickable>
                  )}

                  {addTransactableMatcher && (
                    <div className="flex">
                      <Clickable
                        onClick={() => setAddTransactableMatcher(false)}
                      >
                        <div className="justify-left self-center">
                          <Icon
                            className="ml-3 mr-2 flex self-center text-gray-400"
                            iconName="remove"
                            color="currentColor"
                            size="s"
                          />
                        </div>
                      </Clickable>
                      <div className="min-w-72">
                        <SelectField
                          handleChange={(e) => {
                            setAddTransactableMatcher(false);
                            let matchResultType;
                            let matcher;
                            if ((e as string).endsWith("_offset")) {
                              matchResultType = "date_offset";
                              matcher = "0..0";
                            } else if (
                              e === "short_id" ||
                              e === "short_numeric_id"
                            ) {
                              matchResultType = "short_id";
                              matcher = "vendor_description";
                            } else {
                              matchResultType =
                                e === "group_required" ? "is_true" : "is_null";
                              matcher = "";
                            }

                            setTransactableMatchResultState([
                              ...transactableMatchResultState,
                              {
                                field: e as string,
                                matcherType: "transactables",
                                matcher:
                                  matcher === null ? null : (matcher as string),
                                expected: "",
                                actual: "",
                                match: false,
                                transactionField: null,
                                parser: null,
                                system_default: false,
                                matchResultType:
                                  matchResultType === null
                                    ? null
                                    : (matchResultType as string),
                                suggestedMatcher: "-new matcher-",
                                systemDefault: false,
                              } as MatchResult,
                            ]);
                            setTransactableMatchResultInputState([
                              ...transactableMatchResultInputState,
                              {
                                id: `${strategy.name}transactables${
                                  e as string
                                }`,
                                strategyName: strategy.name,
                                field: e as string,
                                matcherType: "transactables",
                                matcher:
                                  matcher === null ? null : (matcher as string),
                                transactionField: null,
                                parser: null,
                                systemDefault: false,
                              } as MatchResultInput,
                            ]);
                          }}
                          id="select-id"
                          name="select"
                          selectValue={null}
                          placeholder="Select Matcher Type"
                          options={(
                            strategy.transactableMatchResultFields || []
                          )
                            .filter(
                              (f) =>
                                !transactableMatchResultState
                                  .map((mr) => mr.field)
                                  .includes(f),
                            )
                            .map((f) => ({ label: f, value: f }))}
                        />
                      </div>
                    </div>
                  )}

                  {transactionMatchResultState.filter(
                    (mr) => mr.field !== "reconciled",
                  ).length > 0 && (
                    <div className="flex pb-2 pl-6">
                      <Label className="text-base">Transaction Matchers</Label>
                      {removedTransactionMatchers.length > 0 && (
                        <Icon
                          className="ml-1 self-center text-blue-400"
                          iconName="circle"
                          color="currentColor"
                          size="s"
                        />
                      )}
                    </div>
                  )}
                  <div className="pl-3">
                    {transactionMatchResultState
                      .filter((mr) => mr.field !== "reconciled")
                      .map((matchResult) => (
                        <DatabaseReconciliationMatchResult
                          key={`${matchResult.field}${matchResult.matcherType}${
                            resetToggle ? "true" : "false"
                          }`}
                          matchResult={matchResult}
                          strategyName={strategy.name}
                          matcherType="transactions"
                          transactionId={transactionId}
                          callback={matchResultCallback}
                          modalOpen={
                            matchResult.suggestedMatcher === "-new matcher-"
                          }
                        />
                      ))}
                  </div>

                  {!addTransactionMatcher && (
                    <Clickable onClick={() => setAddTransactionMatcher(true)}>
                      <div
                        className="flex pl-6"
                        onMouseEnter={() => setTransactionHoverState(true)}
                        onMouseLeave={() => setTransactionHoverState(false)}
                      >
                        <Icon
                          className="ml-2 text-gray-400"
                          iconName="add"
                          color="currentColor"
                          size="s"
                        />

                        {transactionHoverState && (
                          <Label className="ml-1 text-xs text-gray-500
                          hover:cursor-pointer">
                            Add Transaction Matcher
                          </Label>
                        )}
                      </div>
                    </Clickable>
                  )}

                  {addTransactionMatcher && (
                    <div className="flex">
                      <Clickable
                        onClick={() => setAddTransactionMatcher(false)}
                      >
                        <div className="justify-left self-center">
                          <Icon
                            className="ml-3 mr-2 flex self-center text-gray-400"
                            iconName="remove"
                            color="currentColor"
                            size="s"
                          />
                        </div>
                      </Clickable>
                      <div className="min-w-72">
                        <SelectField
                          handleChange={(e) => {
                            setAddTransactionMatcher(false);

                            setTransactionMatchResultState([
                              ...transactionMatchResultState,
                              {
                                field: e as string,
                                matcherType: "transactions",
                                matcher: "",
                                expected: "",
                                actual: "",
                                match: false,
                                system_default: false,
                                matchResultType: "is_null",
                                suggestedMatcher: "-new matcher-",
                                systemDefault: false,
                              } as MatchResult,
                            ]);
                            setTransactionMatchResultInputState([
                              ...transactionMatchResultInputState,
                              {
                                id: `${strategy.name}transactions${
                                  e as string
                                }`,
                                strategyName: strategy.name,
                                field: e as string,
                                matcherType: "transactions",
                                matcher: "",
                                systemDefault: false,
                              } as MatchResultInput,
                            ]);
                          }}
                          id="select-id"
                          name="select"
                          selectValue={null}
                          placeholder="Select Matcher Type"
                          options={(strategy.transactionMatchResultFields || [])
                            .filter(
                              (f) =>
                                !transactionMatchResultState
                                  .map((mr) => mr.field)
                                  .includes(f),
                            )
                            .map((f) => ({ label: f, value: f }))}
                        />
                      </div>
                    </div>
                  )}

                  {strategy.groupByMatchResult && !customToggle && (
                    <div className="pt-2">
                      <div className="flex w-full">
                        <Label className="w-24 pb-2 pl-6 text-base">
                          Group By
                        </Label>

                        <div className="w-full">
                          <DatabaseReconciliationMatchResult
                            key={`GroupBy-${resetToggle ? "true" : "false"}`}
                            matchResult={strategy.groupByMatchResult}
                            strategyName={strategy.name}
                            matcherType="group_by"
                            transactionId={transactionId}
                            callback={matchResultCallback}
                            removable={false}
                          />
                        </div>
                      </div>
                    </div>
                  )}

                  <div>
                    {paymentReferenceMatchResultState && !customToggle && (
                      <div className="my-1 flex w-full">
                        <Label className="w-44 self-center pl-6 text-base">
                          Payment Reference
                        </Label>

                        <div className="w-full">
                          <DatabaseReconciliationMatchResult
                            key={`${paymentReferenceMatchResultState.field}${
                              paymentReferenceMatchResultState.matcherType
                            }${resetToggle ? "true" : "false"}`}
                            matchResult={paymentReferenceMatchResultState}
                            strategyName={strategy.name}
                            matcherType="payment_reference"
                            transactionId={transactionId}
                            callback={matchResultCallback}
                            modalOpen={
                              paymentReferenceMatchResultState.suggestedMatcher
                              ===
                              "-new matcher-"
                            }
                          />
                        </div>
                      </div>
                    )}
                    {!paymentReferenceMatchResultState &&
                      !addPaymentReferenceMatcher && (
                        <Clickable
                          onClick={() => {
                            setPaymentReferenceMatchResultState({
                              field: "payment_reference",
                              matcherType: "payment_reference",
                              matcher: "",
                              expected: "",
                              actual: "",
                              match: false,
                              system_default: false,
                              matchResultType: "payment_reference",
                              suggestedMatcher: "-new matcher-",
                            } as MatchResult);
                            setAddPaymentReferenceMatcher(false);
                          }}
                        >
                          <div
                            className="flex"
                            onMouseEnter={() =>
                              setAddPaymentReferenceHoverState(true)
                            }
                            onMouseLeave={() =>
                              setAddPaymentReferenceHoverState(false)
                            }
                          >
                            <Label className="pl-6 text-base">
                              Payment Reference
                            </Label>
                            {strategy.paymentReferenceMatchResult && (
                              <Icon
                                className="ml-1 self-center text-blue-400"
                                iconName="circle"
                                color="currentColor"
                                size="s"
                              />
                            )}
                            <Icon
                              className="ml-1 self-center text-gray-400"
                              iconName="add"
                              color="currentColor"
                              size="s"
                            />
                            {addPaymentReferenceHoverState && (
                              <Label className="ml-1 self-center text-xs text-
                              gray-500 hover:cursor-pointer">
                                Add Payment Reference
                              </Label>
                            )}
                          </div>
                        </Clickable>
                      )}
                  </div>
                </div>

                <div className="ml-2 mr-6">
                  <Accordion allowMultiple allowToggle>
                    <AccordionItem>
                      <AccordionButton className="hover:bg-gray-25">
                        <Label className="mr-1 text-base">Options</Label>
                        <Icon
                          className="mr-auto self-center"
                          iconName="circle"
                          color={
                            optionsHasChanged()
                              ? colors.blue["400"]
                              : colors.white
                          }
                          size="s"
                        />
                        {(ambiguousToggle ||
                          amountMismatchToggle ||
                          customToggle ||
                          priority) && (
                          <Label className="mr-2 italic text-gray-500">
                            {ambiguousToggle
                              ? `Ambiguous${
                                  amountMismatchToggle ||
                                  customToggle ||
                                  priority
                                    ? ", "
                                    : ""
                                }`
                              : ""}
                            {amountMismatchToggle
                              ? `Amount_Mismatch${
                                  customToggle || priority ? ", " : ""
                                }`
                              : ""}
                            {customToggle
                              ? `Custom${priority ? ", " : ""}`
                              : ""}
                            {priority ? `Priority: ${priority}` : ""}
                          </Label>
                        )}
                        <AccordionIcon />
                      </AccordionButton>
                      <AccordionPanel>
                        <FieldsRow columns={2}>
                          <Toggle
                            className="tailwind-class"
                            handleChange={() =>
                              setAmbiguousToggle(!ambiguousToggle)
                            }
                            checked={ambiguousToggle}
                            id="allow-ambiguous-toggle"
                            label="Ambiguous"
                            labelClassName="mr-6"
                            disabled={customToggle}
                          />
                          <div className="justify-right flex">
                            <Label className="justify-right mr-5 flex pr-2">
                              Priority
                            </Label>
                            <div className="min-w-20">
                              <SelectField
                                className="justify-right flex"
                                handleChange={(val) =>
                                  setPriority(val ? (val as number) : null)
                                }
                                options={[
                                  {
                                    label: "None",
                                    value: null,
                                  },
                                  ...[...Array(20).keys()].map((i) => ({
                                    label: i + 1,
                                    value: i + 1,
                                  })),
                                ]}
                                placeholder="None"
                                selectValue={priority}
                              />
                            </div>
                          </div>
                        </FieldsRow>
                        <FieldsRow columns={2}>
                          <Toggle
                            className="tailwind-class"
                            handleChange={() =>
                              setAmountMismatchToggle(!amountMismatchToggle)
                            }
                            checked={amountMismatchToggle}
                            id="allow-amount-mismatch-toggle"
                            label="Amount Mismatch"
                            labelClassName="mr-6"
                            disabled={customToggle}
                          />
                          <div className="flex">
                            <Label className="justify-left mr-1 pr-2">
                              Enabled If
                            </Label>
                            <Field
                              className="justify-right"
                              name="reconEnabledIf"
                              id="reconEnabledIf"
                              component={FormikInputField}
                            />
                          </div>
                        </FieldsRow>
                        <FieldsRow columns={2}>
                          <Toggle
                            className="tailwind-class"
                            handleChange={() => {
                              setCustomToggle(!customToggle);
                            }}
                            checked={customToggle}
                            id="custom-toggle"
                            label="Custom"
                            labelClassName="mr-6"
                          />
                          <div className="flex">
                            <Label className="justify-left pr-2">
                              Disabled If
                            </Label>
                            <Field
                              className="justify-right"
                              name="reconDisabledIf"
                              id="reconDisabledIf"
                              component={FormikInputField}
                            />
                          </div>
                        </FieldsRow>
                      </AccordionPanel>
                    </AccordionItem>
                  </Accordion>
                </div>

                <Modal
                  isOpen={showReconResults}
                  title="Run Reconciliation"
                  onRequestClose={() => setShowReconResults(false)}
                >
                  <ModalContainer>
                    <Label className="ml-auto mr-auto mt-2 flex pb-2 text-base
                    font-medium">
                      Reconciliation Results
                    </Label>

                    <div className="mx-2">
                      <EntityTableView
                        data={reconciliationResults?.map((edge) => edge.node)}
                        loading={resultsLoading}
                        dataMapping={
                          reconciliationResults[0]?.node?.__typename
                            ? RESULT_MAPPING[
                                reconciliationResults[0]?.node?.__typename
                              ]
                            : RESULT_MAPPING.PaymentOrder
                        }
                        styleMapping={STYLE_MAPPING}
                        cursorPagination={
                          resultsData?.reconciliationStrategyResult?.pageInfo
                        }
                        defaultPerPage={PER_PAGE}
                        onQueryArgChange={handleRefetch}
                        disableQueryURLParams
                      />
                    </div>

                    <ModalFooter>
                      <div className="flex w-full">
                        <Button
                          buttonType="secondary"
                          className="ml-auto mr-auto flex justify-center"
                          onClick={() => setShowReconResults(false)}
                        >
                          Close
                        </Button>
                      </div>
                    </ModalFooter>
                  </ModalContainer>
                </Modal>

                <Modal
                  className="m-4 flex w-full max-w-6xl"
                  isOpen={showDiffModal}
                  title="Strategy Diff"
                  onRequestClose={() => setShowDiffModal(false)}
                >
                  <ModalContainer>
                    <div className="bg-gray-25">
                      <Label className="ml-auto mr-auto self-center py-2 align-
                      middle text-base text-lg">
                        Diff Preview
                      </Label>
                      {updateStrategyData?.updateReconciliationStrategy && (
                        <div className="flex w-full flex-col bg-white p-2">
                          <div className="flex w-full">
                            {updateStrategyData?.updateReconciliationStrategy
                              ?.oldStrategy && (
                              <div>
                                <Label className="ml-auto mr-auto pb-2 text-base
                                font-medium">
                                  Old Strategy
                                </Label>
                                <div className="mt-auto flex w-full">
                                  <div className="flex flex-col rounded-md
                                  border py-1">
                                    {updateStrategyData.updateReconciliationStra
                                    tegy.oldStrategy.strategyConfig
                                      .split("\n")
                                      // prettier-ignore
                                      .map((line) =>
                                        // prettier-ignore
                                        <textarea
                                          className={cn(
                                            "text-md outline-non flex w-full
                                            resize-none whitespace-pre px-2
                                            placeholder-gray-600",
                                            updateStrategyData.updateReconciliat
                                            ionStrategy?.newStrategy?.strategyCo
                                            nfig
                                              .split("\n")
                                              .includes(line)
                                              ?
                                                "disabled:bg-white"
                                              : "disabled:bg-red-100"
                                          )}
                                          onChange={() => {}}
                                          disabled
                                          value={line}
                                          rows={1}
                                          cols={60}
                                        />,
                                      )}
                                  </div>
                                </div>
                              </div>
                            )}

                            <div
                              className={` ml-auto ${
                                updateStrategyData?.updateReconciliationStrategy
                                  ?.oldStrategy
                                  ? ""
                                  : "w-full"
                              }`}
                            >
                              <Label className="ml-auto mr-auto pb-2 text-base
                              font-medium">
                                New Strategy
                              </Label>
                              <div className="flex flex-col rounded-md border
                              py-1">
                                {updateStrategyData.updateReconciliationStrategy
                                .newStrategy?.strategyConfig
                                  .split("\n")
                                  .map((line) =>
                                    // prettier-ignore
                                    <textarea
                                      className={cn(
                                        "text-md outline-non flex w-full resize-
                                        none whitespace-pre px-2 placeholder-
                                        gray-600",
                                        updateStrategyData.updateReconciliationS
                                        trategy?.oldStrategy?.strategyConfig
                                          .split("\n")
                                          .includes(line)
                                          ? "disabled:bg-white"
                                          : "disabled:bg-green-100"
                                      )}
                                      onChange={() => {}}
                                      disabled
                                      value={line}
                                      rows={1}
                                      cols={60}
                                    />,
                                  )}
                              </div>
                            </div>
                          </div>
                          <Label className="ml-auto mr-auto mt-1 text-sm
                          italic">
                            Strategies are side-scrolling
                          </Label>
                          <div className="flex w-full pt-1">
                            <textarea
                              className="ml-auto mr-auto flex w-3/4 resize-none
                              rounded-md bg-gray-25 p-2 text-gray-600
                              placeholder-gray-600"
                              onChange={(e) => setNote(e.target.value)}
                              placeholder={`Leave a note for the reviewer about
                              this ${
                                needsApproval ? "review" : "change"
                              } (optional)`}
                              value={note}
                              rows={3}
                              cols={60}
                            />
                          </div>
                        </div>
                      )}

                      <ModalFooter>
                        <Button onClick={() => setShowDiffModal(false)}>
                          Close
                        </Button>

                        <Modal
                          className=""
                          isOpen={showConfirmModal}
                          title="Confirm Approval"
                          onRequestClose={() => setShowConfirmModal(false)}
                        >
                          <ModalContainer>
                            <Label className="ml-auto mr-auto justify-center p-4
                            text-lg font-bold font-semibold">
                              Are you sure you want to accept this change?
                            </Label>

                            <ModalFooter className="bg-gray-50">
                              <Button
                                onClick={() => setShowConfirmModal(false)}
                              >
                                Wait nevermind
                              </Button>

                              <Button
                                buttonType="primary"
                                onClick={() => {
                                  void reviewReconciliationStrategy({
                                    variables: {
                                      input: {
                                        strategyId: strategy.id as string,
                                        vendorId: strategy.vendor,
                                        note,
                                        approved: true,
                                        transactionId,
                                      },
                                    },
                                  });
                                  window.location.reload();
                                }}
                              >
                                Yeah looks beautiful
                              </Button>
                            </ModalFooter>
                          </ModalContainer>
                        </Modal>

                        <Modal
                          className=""
                          isOpen={showRejectModal}
                          title="Confirm Rejection"
                          onRequestClose={() => setShowRejectModal(false)}
                        >
                          <ModalContainer>
                            <Label className="ml-auto mr-auto justify-center p-4
                            text-lg font-bold font-semibold">
                              Are you sure you want to reject this change?
                            </Label>

                            <ModalFooter className="bg-gray-50">
                              <Button onClick={() => setShowRejectModal(false)}>
                                Wait nevermind
                              </Button>

                              <Button
                                buttonType="destructive"
                                onClick={() => {
                                  void reviewReconciliationStrategy({
                                    variables: {
                                      input: {
                                        strategyId: strategy.id as string,
                                        vendorId: strategy.vendor,
                                        note,
                                        approved: false,
                                        transactionId,
                                      },
                                    },
                                  });
                                  window.location.reload();
                                }}
                              >
                                Yeah reject it already
                              </Button>
                            </ModalFooter>
                          </ModalContainer>
                        </Modal>

                        {needsApproval &&
                          strategy.userCanApprove &&
                          !strategyHasChanged() && (
                            <>
                              <Button
                                className="ml-auto mr-3"
                                buttonType="destructive"
                                onClick={() => {
                                  setShowRejectModal(true);
                                }}
                              >
                                Reject Change
                              </Button>
                              <Button
                                onClick={() => {
                                  setShowConfirmModal(true);
                                }}
                                buttonType="primary"
                              >
                                Accept Change
                              </Button>
                            </>
                          )}
                        {(!needsApproval || strategyHasChanged()) && (
                          <Button
                            onClick={() => {
                              setShowDiffModal(false);
                              updateReconciliationStrategy({
                                variables: {
                                  input: {
                                    strategy: {
                                      name: strategyName || "blank_name",
                                      vendor: strategy.vendor,
                                      transactableType:
                                        strategy.transactableType,
                                      paymentType: strategy.paymentType,
                                      role: strategy.role,
                                      transactionMatchResultInputs:
                                        transactionMatchResultInputState,
                                      transactableMatchResultInputs:
                                        transactableMatchResultInputState,
                                      paymentReferenceMatchResultInput:
                                        customToggle
                                          ? null
                                          :
                                          paymentReferenceMatchResultInputState,
                                      allowAmountMismatch: amountMismatchToggle,
                                      allowAmbiguous: ambiguousToggle,
                                      custom: customToggle,
                                      groupBy: groupByState,
                                      priority,
                                      reconDisabledIf:
                                        formikRef?.current?.values
                                          ?.reconDisabledIf === ""
                                          ? null
                                          : formikRef?.current?.values
                                              ?.reconDisabledIf,
                                      reconEnabledIf:
                                        formikRef?.current?.values
                                          ?.reconEnabledIf === ""
                                          ? null
                                          : formikRef?.current?.values
                                              ?.reconEnabledIf,
                                      id: strategy.id as string,
                                      parentStrategyId:
                                        strategy.parentStrategyId,
                                      note,
                                    },
                                    preview: false,
                                    transactionId,
                                  },
                                },
                              })
                                .then((response) => {
                                  const errors =
                                    response?.data?.updateReconciliationStrategy
                                      ?.errors ?? [];
                                  if (errors.length === 0) {
                                    setShowDiffModal(true);
                                  }
                                })
                                .catch((error: Error) => {
                                  dispatchError(error.message);
                                });
                              window.location.reload();
                            }}
                          >
                            Submit for Review
                          </Button>
                        )}
                        {!strategy.userCanApprove && (
                          <div className="ml-2">
                            <Tooltip
                              className="flex"
                              data-tip="Only Recon team members can review
                              strategies"
                            />
                            <ReactTooltip
                              multiline
                              data-place="top"
                              data-type="dark"
                              data-effect="float"
                            />
                          </div>
                        )}
                      </ModalFooter>
                    </div>
                  </ModalContainer>
                </Modal>

                {updateStrategyData?.updateReconciliationStrategy?.errors
                  ?.length ? (
                  <div className="mx-4 mb-4 mt-2 flex rounded-md border border-
                  red-400 bg-red-200 px-3 py-1">
                    <Icon
                      className="mr-5 self-center text-red-400"
                      iconName="error_outlined"
                      color="currentColor"
                    />
                    <div className="flex flex-col">
                      {updateStrategyData.updateReconciliationStrategy.errors.ma
                      p(
                        (error) => (
                          <div className="flex flex-col">
                            <Label>- {error}</Label>
                          </div>
                        ),
                      )}
                    </div>
                    <Icon
                      className="ml-3 mr-3 self-center text-red-400"
                      iconName="error_outlined"
                      color="currentColor"
                    />
                  </div>
                ) : null}

                <div className="mt-2 flex">
                  <Button
                    className="ml-6 flex"
                    buttonType="primary"
                    onClick={() => {
                      void getReconciliationStrategyResults();
                      setShowReconResults(true);
                    }}
                  >
                    Test Reconciliation
                    <Icon
                      iconName="node_multiple"
                      color="currentColor"
                      className="text-white"
                    />
                  </Button>

                  {needsApproval &&
                  strategy.createdByCurrentUser &&
                  !strategyHasChanged() ? (
                    <div className="ml-auto flex">
                      <Modal
                        title="Delete Suggested Change"
                        isOpen={showDeleteModal}
                        onRequestClose={() => setShowDeleteModal(false)}
                      >
                        <ModalContainer>
                          <Label className="ml-auto mr-auto justify-center p-4
                          text-lg italic">
                            Are you sure you want to delete this Suggested
                            Change?
                          </Label>

                          <ModalFooter className="bg-gray-25">
                            <Button
                              className="mr-auto"
                              buttonType="secondary"
                              onClick={() => setShowDeleteModal(false)}
                            >
                              No leave it alone
                            </Button>

                            <Button
                              className="ml-auto"
                              buttonType="destructive"
                              onClick={() => {
                                void reviewReconciliationStrategy({
                                  variables: {
                                    input: {
                                      strategyId: strategy.id as string,
                                      vendorId: strategy.vendor,
                                      note: "Deleted By Creator",
                                      approved: false,
                                      transactionId,
                                    },
                                  },
                                });
                                window.location.reload();
                              }}
                            >
                              Obliterate It
                            </Button>
                          </ModalFooter>
                        </ModalContainer>
                      </Modal>
                      <Button
                        buttonType="destructive"
                        className="ml-auto mr-6 flex"
                        onClick={() => setShowDeleteModal(true)}
                      >
                        <Icon
                          iconName="clear_circle_outlined"
                          color="currentColor"
                          className="text-white"
                          size="s"
                        />
                        Delete My Suggested Change
                      </Button>
                    </div>
                  ) : (
                    <div className="ml-auto mr-6 flex">
                      {updateStrategyLoading && (
                        <ClipLoader
                          className="ml-auto mr-2 flex self-center"
                          size={22}
                          color={colors.gray["300"]}
                        />
                      )}
                      {updateStrategyData?.updateReconciliationStrategy?.errors
                        ?.length ? (
                        <div className="mr-2 flex self-center">
                          <Icon
                            iconName="error_outlined"
                            color="currentColor"
                            className="text-red-500"
                          />
                          <Label className="ml-1 self-center italic text-
                          red-500">
                            Error
                          </Label>
                        </div>
                      ) : null}
                      <Button
                        buttonType="primary"
                        disabled={
                          (!strategyHasChanged() &&
                            !needsApproval &&
                            !(strategy.status === "tentative")) ||
                          updateStrategyLoading
                        }
                        className=""
                        onClick={() => {
                          updateReconciliationStrategy({
                            variables: {
                              input: {
                                strategy: {
                                  name: strategyName || "blank_name",
                                  vendor: strategy.vendor,
                                  transactableType: strategy.transactableType,
                                  paymentType: strategy.paymentType,
                                  role: strategy.role,
                                  transactionMatchResultInputs:
                                    transactionMatchResultInputState,
                                  transactableMatchResultInputs:
                                    transactableMatchResultInputState,
                                  paymentReferenceMatchResultInput: customToggle
                                    ? null
                                    : paymentReferenceMatchResultInputState,
                                  allowAmountMismatch: amountMismatchToggle,
                                  allowAmbiguous: ambiguousToggle,
                                  custom: customToggle,
                                  groupBy: groupByState,
                                  priority,
                                  reconDisabledIf:
                                    formikRef?.current?.values
                                      ?.reconDisabledIf === ""
                                      ? null
                                      : formikRef?.current?.values
                                          ?.reconDisabledIf,
                                  reconEnabledIf:
                                    formikRef?.current?.values
                                      ?.reconEnabledIf === ""
                                      ? null
                                      : formikRef?.current?.values
                                          ?.reconEnabledIf,
                                  id: strategy.id as string,
                                  parentStrategyId: strategy.parentStrategyId,
                                  note,
                                },
                                preview: true,
                                transactionId,
                              },
                            },
                          })
                            .then((response) => {
                              const errors =
                                response?.data?.updateReconciliationStrategy
                                  ?.errors ?? [];
                              if (errors.length === 0) {
                                setShowDiffModal(true);
                              }
                            })
                            .catch((error: Error) => {
                              dispatchError(error.message);
                            });
                        }}
                      >
                        <Icon
                          iconName="visible"
                          color="currentColor"
                          className="text-white"
                        />
                        {needsApproval && !strategyHasChanged()
                          ? `Review ${
                              strategy.userCanApprove
                                ? "and Accept/Reject"
                                : "Change"
                            }`
                          : `${
                              needsApproval && strategy.createdByCurrentUser
                                ? "Update My Suggested Change"
                                : "Preview and Submit For Review"
                            }`}
                      </Button>
                    </div>
                  )}
                </div>
              </Form>
            )}
          </Formik>
        </div>
      </div>
    </div>
  );
}

export default DatabaseReconciliationStrategy;
```

---
## `DateOffsetReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import DatePicker from "~/common/ui-components/DatePicker/DatePicker";
import { Label, SelectField } from "../../common/ui-components";

interface DateOffsetReconciliationMatchResultProps {
  selectField: string | null | undefined;
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  matcher: string;
  startOffset: number | null | undefined;
  endOffset: number | null | undefined;
  startDate: string | null | undefined;
  endDate: string | null | undefined;
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null | undefined,
    endDate: string | null | undefined,
  ) => void;
}

function DateOffsetReconciliationMatchResult({
  selectField,
  selectFieldOptions,
  matcher,
  startOffset,
  endOffset,
  startDate,
  endDate,
  callback,
}: DateOffsetReconciliationMatchResultProps) {
  return (
    <div className="flex w-full">
      <div className="min-w-44">
        <div className="mt-6" />
        <SelectField
          className="justify-left flex"
          handleChange={(e) =>
            callback(e as string, matcher, null, null, null, startDate, endDate)
          }
          id="select-id"
          name="select-name"
          selectValue={selectField}
          options={selectFieldOptions}
        />
        <Label className="text-sm text-gray-500">
          Offset (In Business Days)
        </Label>
      </div>

      <div className="flex w-full">
        <div>
          <DatePicker
            label="Start Date"
            placeholder="YYYY-MM-DD"
            input={{
              onChange: (e) => {
                callback(selectField, matcher, null, null, null, e, endDate);
              },
              value: startDate || "",
            }}
          />
          <Label className="ml-14 text-sm text-gray-500">{startOffset}</Label>
        </div>

        <div>
          <DatePicker
            label="End Date"
            placeholder="YYYY-MM-DD"
            input={{
              onChange: (e) => {
                callback(selectField, matcher, null, null, null, startDate, e);
              },
              value: endDate || "",
            }}
          />
          <Label className="ml-14 text-sm text-gray-500">{endOffset}</Label>
        </div>
      </div>
    </div>
  );
}
export default DateOffsetReconciliationMatchResult;
```

---
## `DeleteOrganizationButton.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { Button, ConfirmModal } from "../../common/ui-components";
import { useAdminDeleteOrganizationMutation } from
"../../generated/dashboard/graphqlSchema";
import { useDispatchContext } from "../MessageProvider";

interface DeleteOrganizationButtonProps {
  organizationId: string;
  organizationName: string;
}

function DeleteOrganizationButton({
  organizationId,
  organizationName,
}: DeleteOrganizationButtonProps) {
  const { dispatchSuccess, dispatchError } = useDispatchContext();

  const [isModalOpen, setIsModalOpen] = useState(false);

  const [adminDeleteOrganizationMutation, { loading: isDeleting }] =
    useAdminDeleteOrganizationMutation();
  const handleDeleteOrganization = () => {
    adminDeleteOrganizationMutation({
      variables: { input: { organizationId } },
    })
      .then(({ data: res }) => {
        if (res?.adminDeleteOrganization?.errors.length) {
          dispatchError(res?.adminDeleteOrganization?.errors.toString());
        } else {
          window.location.href = "/admin/organizations";
          dispatchSuccess("Organization successfully deleted.");
        }
      })
      .catch((e: Error) => dispatchError(e.message))
      .finally(() => setIsModalOpen(false));
  };
  return (
    <>
      <ConfirmModal
        isOpen={isModalOpen}
        setIsOpen={setIsModalOpen}
        title={`Are you sure you want to delete ${
          organizationName ?? "this organization"
        }?`}
        confirmDisabled={isDeleting}
        onConfirm={handleDeleteOrganization}
        confirmType="delete"
      />
      <Button
        buttonType="destructive"
        onClick={() => setIsModalOpen(true)}
        disabled={isDeleting}
      >
        Delete {organizationName}
      </Button>
    </>
  );
}

export default DeleteOrganizationButton;
```

---
## `DetailsTable.tsx.txt`
**Path:** `.`  
```
import React, { ReactNode } from "react";
import ReactJson from "react-json-view";
import { get } from "lodash";
import invariant from "ts-invariant";
import { ActionItemProps } from "~/common/ui-components/ActionItem/ActionItem";
import { TagColors } from "~/common/ui-components/Tag/Tag";
import { Icons } from "~/common/ui-components/Icon/Icon";
import { cn } from "~/common/utilities/cn";
import {
  AssociationOption,
  AssociationListOption,
  DisplayColumn,
  DisplayColumnOptions__AssociatedEntityLabelFieldTypeEnum,
  useAuditableTextFieldLazyQuery,
  useAuditableJsonFieldLazyQuery,
  PaymentSubtypeEnum,
} from "../../generated/dashboard/graphqlSchema";
import { DisplayColumnTypeEnum } from
"../../generated/dashboard/types/displayColumnTypeEnum";
import {
  ActionItem,
  Amount,
  CopyableText,
  Countdown,
  DateTime,
  Drawer,
  Icon,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
  Pill,
  Popover,
  PopoverPanel,
  PopoverTrigger,
  StatusIndicator,
  Tag,
} from "../../common/ui-components";
import { StatusIndicatorStatuses } from "../../common/ui-
components/StatusIndicator/StatusIndicator";
import { getDrawerContent } from "../../common/utilities/getDrawerContent";
import {
  RESOURCES,
  ResourcesEnum,
} from "../../generated/dashboard/types/resources";
import AuditableTextField from "./auditable_fields/AuditableTextField";
import AuditableJsonField from "./auditable_fields/AuditableJsonField";
import { formatPaymentSubtype } from
"../../common/utilities/formatPaymentSubtype";
import { createPolymorphicAssociation } from
"../utilities/createPolymorphicAssociation";

type Action = {
  handler: () => void;
  label: string;
  type: ActionItemProps["type"];
};

type AdditionalSection = {
  header: string;
  content: React.ReactNode;
};

type RecordData = {
  id: string;
  [key: string]: unknown;
};

function auditableText(
  record: RecordData,
  fieldName: string,
  defaultTextField: string | null,
) {
  return (
    <AuditableTextField
      graphqlQuery={useAuditableTextFieldLazyQuery}
      queryVariables={{
        id: record.id,

        resourceName: record.__typename as string,
        fieldName,
      }}
      defaultText={
        defaultTextField ? (record[defaultTextField] as string) : undefined
      }
      fieldName="auditableTextField"
    />
  );
}

function auditableJSON(record: RecordData, fieldName: string) {
  return (
    <AuditableJsonField
      graphqlQuery={useAuditableJsonFieldLazyQuery}
      queryVariables={{
        id: record.id,

        resourceName: record.__typename as string,
        fieldName,
      }}
      fieldName="auditableJsonField"
    />
  );
}

function associatedEntityLabel(
  record: RecordData,
  displayColumnId: string,
  displayTypeOptions: AssociationOption | AssociationListOption,
) {
  if (
    displayTypeOptions.associatedEntityLabelFieldType ===
      DisplayColumnOptions__AssociatedEntityLabelFieldTypeEnum.Object ||
    displayTypeOptions.__typename === "AssociationListOption"
  ) {
    return get(record, [
      displayTypeOptions.associatedEntityLabelField,
    ]) as string;
  }

  return get(record, [
    displayColumnId,
    displayTypeOptions.associatedEntityLabelField,
  ]) as string;
}

function idColumn({ id, path }: RecordData) {
  const includeLink = path && path !== window.location.pathname;
  return (
    <CopyableText text={id}>
      {includeLink ? <a href={path as string}>{id}</a> : id}
    </CopyableText>
  );
}

function association(
  record: RecordData,
  displayColumnId: string,
  displayTypeOptions: AssociationOption | AssociationListOption,
) {
  const isAssociationList =
    displayTypeOptions.__typename === "AssociationListOption";
  if (displayTypeOptions?.drawerEnabled) {
    return (
      <Drawer
        key={displayColumnId}
        trigger={
          <Pill className="associated-entity z-10" showTooltip>
            {associatedEntityLabel(record, displayColumnId, displayTypeOptions)}
          </Pill>
        }
        path={
          get(
            record,
            isAssociationList ? "path" : [displayColumnId, "path"],
          ) as string
        }
      >
        {getDrawerContent(
          get(
            record,
            isAssociationList ? "typename" : [displayColumnId, "typename"],
          ) as string,
          get(
            record,
            isAssociationList ? "id" : [displayColumnId, "id"],
          ) as string,
        )}
      </Drawer>
    );
  }

  if (displayTypeOptions?.linkEnabled) {
    return (
      <a href={get(record, [displayColumnId, "path"]) as string}>
        {associatedEntityLabel(record, displayColumnId, displayTypeOptions)}
      </a>
    );
  }

  // Otherwise simply render the label of the association
  return displayTypeOptions
    ? associatedEntityLabel(record, displayColumnId, displayTypeOptions)
    : null;
}

/**
 * Computes the value from the graphql response based on the column display
 type.
 * Different values are rendered depending on the type defined on the display
 column
 */
function computeValue(
  displayColumn: DisplayColumn,
  record: RecordData,
  actions: Array<Action>,
): React.ReactNode {
  if (record?.[displayColumn.id] == null) {
    return null;
  }
  let content: React.ReactNode = null;

  switch (displayColumn.type) {
    case DisplayColumnTypeEnum.DisplayColumnTypesAssociation:
      // Render a Drawer for associations if the option is enabled
      invariant(
        displayColumn.displayTypeOptions?.__typename === "AssociationOption",
      );
      content = association(
        record,
        displayColumn.id,
        displayColumn.displayTypeOptions,
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAssociationList:
      // Render a Drawer for associations if the option is enabled
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AssociationListOption",
      );
      content = (get(record, [displayColumn.id]) as RecordData[]).map(
        (entity) =>
          association(
            entity,
            displayColumn.id,
            displayColumn.displayTypeOptions as AssociationListOption,
          ),
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesPolymorphicAssociation:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "PolymorphicAssociationOption",
      );
      content = createPolymorphicAssociation(
        record,
        displayColumn.displayTypeOptions.associationPrefix,
        displayColumn.id,
        displayColumn.displayTypeOptions.drawerEnabled ?? false,
        displayColumn.displayTypeOptions.stackedDrawerEnabled ?? false,
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAuditableText:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AuditableTextOption" || displayColumn.displayTypeOptions == null,
      );
      if (displayColumn.displayTypeOptions?.fieldAsDefaultText) {
        content = auditableText(
          record,
          displayColumn.displayTypeOptions.fullField as string,
          displayColumn.id,
        );
      } else {
        content = auditableText(record, displayColumn.id, null);
      }
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAuditableJSON:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "AuditableJSONOption",
      );
      content = auditableJSON(
        record,
        displayColumn.displayTypeOptions.auditableFieldName,
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesLongText:
      if (!displayColumn.displayTypeOptions) {
        content = (
          <div className="text-xs">{record[displayColumn.id] as string}</div>
        );
      } else {
        invariant(
          displayColumn?.displayTypeOptions?.__typename === "LongTextOption",
        );
        content = (
          <div
            className={cn(
              {
                "whitespace-pre-wrap":
                  displayColumn?.displayTypeOptions?.preserveWhitespace,
              },
              "text-xs",
            )}
          >
            {record[displayColumn.id] as string}
          </div>
        );
      }
      break;
    case DisplayColumnTypeEnum.SharedTypesScalarsDateTimeType:
      content = <DateTime timestamp={record[displayColumn.id] as string} />;
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesToggled:
      content = record[displayColumn.id] ? "Enabled" : "Disabled";
      break;
    case DisplayColumnTypeEnum.GraphQlTypesBoolean:
      content = record[displayColumn.id] ? "True" : "False";
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicator:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "StatusIndicatorOption",
      );
      content = (
        <StatusIndicator
          currentStatus={
            displayColumn.displayTypeOptions?.statusIndicatorCurrentStatusField
              ? (record[
                  displayColumn.displayTypeOptions
                    .statusIndicatorCurrentStatusField
                ] as StatusIndicatorStatuses)
              : "incomplete"
          }
          statusDescriptor={
            displayColumn.displayTypeOptions?.statusIndicatorDescriptorField
              ? (record[
                  displayColumn.displayTypeOptions
                    .statusIndicatorDescriptorField
                ] as string)
              : ""
          }
          verbose
        />
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesCountdown:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "CountdownOption",
      );
      content = (
        <Countdown
          type={
            (displayColumn.displayTypeOptions.countdownType as
              | "relative"
              | "timestamp") ?? "timestamp"
          }
          timestamp={record[displayColumn.id] as string}
        />
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesTag:
      invariant(displayColumn.displayTypeOptions?.__typename === "TagOption");
      content = (
        <Tag
          size="small"
          color={
            displayColumn.displayTypeOptions.tagColorField
              ? (record[
                  displayColumn.displayTypeOptions.tagColorField
                ] as TagColors)
              : undefined
          }
          icon={
            displayColumn.displayTypeOptions.tagIconField &&
            record[displayColumn.displayTypeOptions.tagIconField]
              ? {
                  iconName: record[
                    displayColumn.displayTypeOptions.tagIconField
                  ] as Icons,
                  size: "s",
                }
              : undefined
          }
        >
          {record[displayColumn.id] as string}
        </Tag>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesTagList: {
      invariant(
        displayColumn.displayTypeOptions?.__typename === "TagListOption",
      );

      const colors = displayColumn.displayTypeOptions?.tagColorsField
        ? (record[
            displayColumn.displayTypeOptions?.tagColorsField
          ] as TagColors[])
        : undefined;

      const icons = displayColumn.displayTypeOptions?.tagIconsField
        ? (record[displayColumn.displayTypeOptions?.tagIconsField] as Icons[])
        : undefined;

      content = (
        <div className="flex flex-wrap gap-y-2">
          {((record[displayColumn.id] || []) as Array<string>).map(
            (element, idx) => (
              <Tag
                key={`tag-list-item-${element}-${idx}`}
                className="mr-2"
                size="small"
                color={colors && colors[idx]}
                icon={icons && { iconName: icons[idx] }}
              >
                {element}
              </Tag>
            ),
          )}
        </div>
      );
      break;
    }
    case DisplayColumnTypeEnum.DisplayColumnTypesLink:
      invariant(displayColumn.displayTypeOptions?.__typename === "LinkOption");
      content = (
        <a
          target={displayColumn.displayTypeOptions.openNewTab ? "_blank" : ""}
          rel={
            displayColumn.displayTypeOptions.openNewTab
              ? "noopener noreferrer"
              : ""
          }
          href={record[displayColumn.id] as string}
        >
          {
            get(record, [
              displayColumn.displayTypeOptions.displayNameField,
            ]) as string
          }
        </a>
      );
      break;
    case DisplayColumnTypeEnum.GraphQlTypesInt:
      content = (record[displayColumn.id] as number).toString();
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesId:
    case DisplayColumnTypeEnum.GraphQlTypesId:
      content = idColumn(record);
      break;
    case DisplayColumnTypeEnum.TypesPaymentOrderPaymentSubtypeEnumType:
      content = formatPaymentSubtype(
        record[displayColumn.id] as PaymentSubtypeEnum,
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAmount:
      content = <Amount>{record[displayColumn.id] as string}</Amount>;
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAmountDifference:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AmountDifferenceOption",
      );
      content = (
        <Amount
          difference={
            get(record, [
              displayColumn.displayTypeOptions
                .highlightAmountDifferenceField as string,
            ]) === true
          }
        >
          {record[displayColumn.id] as string}
        </Amount>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesJSON:
      invariant(displayColumn.displayTypeOptions?.__typename === "JSONOption");
      content = (
        <ReactJson
          src={
            record[displayColumn.id]
              ? (JSON.parse(record[displayColumn.id] as string) as Record<
                  string,
                  unknown
                >)
              : {}
          }
          name={null}
          displayObjectSize={false}
          displayDataTypes={false}
          collapsed={!!displayColumn.displayTypeOptions?.collapsed}
          sortKeys
        />
      );
      break;
    case DisplayColumnTypeEnum.SharedTypesScalarsJSONType:
      content = (
        <ReactJson
          src={
            record[displayColumn.id]
              ? (JSON.parse(record[displayColumn.id] as string) as Record<
                  string,
                  unknown
                >)
              : {}
          }
          name={null}
          displayObjectSize={false}
          displayDataTypes={false}
          sortKeys
        />
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesOrderedList:
      content = (
        <ol>
          {(record[displayColumn.id] as Array<string>).map((element) => (
            <li className="mb-1 mt-1 overflow-hidden overflow-ellipsis break-
            words">
              {element}
            </li>
          ))}
        </ol>
      );
      break;
    default:
      if (displayColumn.viewOptions?.detailsTable?.copyable) {
        content = (
          <CopyableText text={record[displayColumn.id]}>
            {record[displayColumn.id] as string}
          </CopyableText>
        );
      } else {
        content = (
          <div className="break-words">
            {record[displayColumn.id] as string}
          </div>
        );
      }
      break;
  }
  return (
    <div className="flex gap-1">
      {content}
      <div id={`${displayColumn.id}_actions_toggle`}>
        {actions.length ? (
          <Popover>
            <PopoverTrigger buttonHeight="small" buttonType="link">
              <Icon iconName="more_horizontal" />
            </PopoverTrigger>
            <PopoverPanel
              anchorOrigin={{
                horizontal: "right",
              }}
            >
              {actions.map((action: Action) => (
                <ActionItem type={action.type} onClick={() => action.handler()}>
                  {action.label}
                </ActionItem>
              ))}
            </PopoverPanel>
          </Popover>
        ) : null}
      </div>
    </div>
  );
}

/**
 * Converts the graphql response data into a object containing values for
 * all the display columns. This object will be fed directly into <KeyValueTable
 />
 */
function formatData(
  data: ResponseType,
  graphqlField: string,
  displayColumns: Array<DisplayColumn>,
  actions?: Record<string, Array<Action>>,
) {
  return {
    ...displayColumns.reduce(
      (acc, displayColumn) => ({
        ...acc,
        [displayColumn.id]: computeValue(
          displayColumn,
          data[graphqlField],
          actions && actions[displayColumn.id] ? actions[displayColumn.id] : [],
        ),
      }),
      {},
    ),
  };
}

type ResponseType = {
  displayColumns: Array<DisplayColumn>;
} & { [key: string]: RecordData };

interface DetailsTableProps {
  actions?: Record<string, Array<Action>>;
  /** When `true`, adds a card surface to the table. Defaults to `true`. */
  bordered?: boolean;
  customDataMapping?: Record<string, ReactNode>;
  constantQueryVariables?: Record<string, unknown>;
  expandable?: boolean;
  graphqlQuery: unknown;
  id: string;
  resource: ResourcesEnum;
  additionalSections?: Array<AdditionalSection>;
}

type QueryFunctionType = (queryArgs: Record<string, unknown>) => {
  data?: Record<string, unknown>;
  loading: boolean;
  error?: string;
  refetch: (args: Record<string, unknown>) => unknown;
};

function DetailsTable({
  actions,
  bordered = true,
  customDataMapping,
  constantQueryVariables = {},
  expandable = false,
  graphqlQuery,
  id,
  resource,
  additionalSections = [],
}: DetailsTableProps) {
  const { data, loading, error } = (graphqlQuery as QueryFunctionType)({
    variables: {
      id,
      ...constantQueryVariables,
    },
    fetchPolicy: "no-cache",
  });

  const graphqlField = RESOURCES[resource].graphql_fields?.details_table;
  invariant(
    graphqlField,
    `The resource you passed to <DetailsTable /> (${resource}) has no
    corresponding graphql field for this component. Did you forget to update
    resources.rb?`,
  );
  const waitingForData = loading || !data || error;
  const displayColumns = waitingForData
    ? []
    : (data as ResponseType).displayColumns;

  const record = waitingForData
    ? []
    : formatData(data as ResponseType, graphqlField, displayColumns, actions);

  const defaultColumns = displayColumns.filter(
    (col) => col.viewOptions.detailsTable?.default,
  );

  const primaryColumns = displayColumns.filter(
    (col) => col.viewOptions.detailsTable?.primaryColumn,
  );

  const dataMapping =
    customDataMapping ||
    [
      // Place primary and default columns first.
      ...primaryColumns,
      ...defaultColumns,
      ...displayColumns.filter((col) => !col.viewOptions.detailsTable?.default),
    ].reduce<Record<string, string>>((acc, displayColumn) => {
      if (
        displayColumn.viewOptions.detailsTable?.hideIfNull &&
        !record[displayColumn.id]
      ) {
        return acc;
      }
      return { ...acc, [displayColumn.id]: displayColumn.label };
    }, {});

  return (
    <div id="payment-order-details-panel">
      {(loading || !record) && (
        <KeyValueTableSkeletonLoader
          altRowClassNames="detail-panel-row"
          altTableClassNames="detail-panel p-6"
        />
      )}
      {!loading && record && (
        <>
          <KeyValueTable
            data={record}
            dataMapping={dataMapping}
            primaryColumns={primaryColumns.map((col) => col.id)}
            expandable={expandable}
            // Default & primary columns are visible by design.
            minRowsWhenExpandable={defaultColumns.length}
            altRowClassNames="detail-panel-row"
            altTableClassNames={cn(
              "flex flex-col items-start gap-3 bg-white",
              bordered && "p-6 border-alpha-black-100 border rounded-md",
              additionalSections.length > 0 &&
                "!pb-0 !border-b-0 !rounded-b-none",
            )}
          />
          <div id="additional-sections">
            {additionalSections.map((additionalSection) => (
              <div
                className="detail-panel flex-wrap gap-3 !rounded-t-none
                !border-t-0 !px-6 !pb-6"
                key={additionalSection.header}
              >
                <div className="break-normal font-medium">
                  {additionalSection.header}
                </div>
                {additionalSection.content}
              </div>
            ))}
          </div>
        </>
      )}
    </div>
  );
}
export default DetailsTable;
```

---
## `Draggables.tsx.txt`
**Path:** `.`  
```
import React, { useEffect, useState } from "react";
import { ApolloQueryResult } from "@apollo/client";
import { isEqual } from "lodash";
import { DragDropContext, DropResult, Droppable } from "react-beautiful-dnd";
import useErrorBanner from "~/common/utilities/useErrorBanner";
import { useDispatchContext } from "../MessageProvider";

export type DraggableMutation = (id: string, sortableId: number) => void;
export type DraggableRefetch = (
  variables?: Record<string, unknown>,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
) => Promise<ApolloQueryResult<any>>;
export interface DraggableProps {
  draggableId: string;
  index: number;
  trigger?: DraggablesProp;
}

export interface DraggablesProp {
  key: string;
  props: DraggableProps;
}

export interface SortableProp {
  node: {
    id: string;
    sortableId?: number;
    priority?: number;
  };
}

interface DragDropContextWrapperProps {
  draggableRefetch?: DraggableRefetch;
  draggableMutation: DraggableMutation;
  renderDataRows: () => React.JSX.Element | JSX.Element[];
}

const updatedDataIdSortableId = (arr: DraggablesProp[]) => {
  const obj = {};
  arr.forEach((node: { props: DraggableProps }) => {
    if (node && node.props) {
      // Account for trigger prop for drawer wrapped components
      const draggableId =
        node.props.draggableId || node.props.trigger?.props.draggableId;
      const index = node.props.index ?? node.props.trigger?.props.index;
      if (draggableId !== undefined) {
        obj[draggableId] = index;
      }
    }
  });
  return obj;
};

const refetchedDataSortableId = (arr: SortableProp[]) => {
  const obj = {};
  arr.forEach((edge) => {
    obj[edge.node.id] =
      edge.node.sortableId !== undefined
        ? edge.node.sortableId
        : edge.node.priority;
  });
  return obj;
};

const handleOnDragChange = (
  draggableRefetch: (
    variables?: Record<string, unknown>,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ) => Promise<ApolloQueryResult<any>>,
  setIsDraggableRefetchedDataSynced: React.Dispatch<
    React.SetStateAction<boolean>
  >,
  dataRowItems: DraggablesProp[],
  dispatchError: (errorMessage: string) => void,
) => {
  draggableRefetch?.()
    .then((response) => {
      const firstDataKey = Object.values(
        response.data as {
          [key: string]: {
            edges: SortableProp[];
          };
        },
      )[0];
      const edges = firstDataKey?.edges;
      if (edges) {
        setIsDraggableRefetchedDataSynced(
          isEqual(
            refetchedDataSortableId(edges),
            updatedDataIdSortableId(dataRowItems),
          ),
        );
      }
    })
    .catch((error: Error) => dispatchError(error.message));
};

const handleOnDragEnd = (
  result: DropResult,
  draggableMutation: (id: string, sortableId: number) => void,
  isDraggableRefetchedDataSynced,
  dataRowItems: DraggablesProp[],
  setDataRowItems: React.Dispatch<
    React.SetStateAction<React.ReactNode | React.ReactNode[]>
  >,
) => {
  if (draggableMutation) {
    const { destination, source } = result;
    if (!destination) return;

    if (isDraggableRefetchedDataSynced) {
      if (
        destination.droppableId === source.droppableId &&
        destination.index === source.index
      )
        return;

      const itemsArray = Array.isArray(dataRowItems)
        ? dataRowItems
        : [dataRowItems];

      const items = itemsArray.filter(React.isValidElement);

      const [reorderedItem] = items.splice(source.index, 1);
      items.splice(destination.index, 0, reorderedItem);

      const updatedItems = items.map((item, newIndex) => {
        if (
          React.isValidElement(item) &&
          typeof item?.props === "object" &&
          item?.props !== null
        ) {
          // Handling item.props.trigger for drawer wrapped components
          const elementToClone = React.isValidElement(item.props.trigger)
            ? item.props.trigger
            : item;
          return React.cloneElement(elementToClone, {
            ...elementToClone.props,
            index: newIndex,
          } as DraggableProps);
        }
        return item;
      });

      setDataRowItems(updatedItems);

      draggableMutation(result.draggableId, destination.index);
    }
  }
};

export function DragDropContextWrapper({
  draggableRefetch,
  draggableMutation,
  renderDataRows,
}: DragDropContextWrapperProps) {
  const [isDraggableRefetchedDataSynced, setIsDraggableRefetchedDataSynced] =
    useState(true);

  // Ensures draggable data stays in sync and is not altered by multiple parties
  at one time
  const flashError = useErrorBanner();

  useEffect(() => {
    if (!isDraggableRefetchedDataSynced) {
      flashError("Data is out of sync. Please refresh the page and try again.");
    }
  }, [isDraggableRefetchedDataSynced, flashError]);

  const [dataRowItems, setDataRowItems] = useState<
    React.ReactNode | React.ReactNode[]
  >(renderDataRows());

  const { dispatchError } = useDispatchContext();

  return (
    <DragDropContext
      onBeforeDragStart={() => {
        if (draggableRefetch) {
          handleOnDragChange(
            draggableRefetch,
            setIsDraggableRefetchedDataSynced,
            dataRowItems as DraggablesProp[],
            dispatchError,
          );
        }
      }}
      onDragUpdate={() => {
        if (draggableRefetch) {
          handleOnDragChange(
            draggableRefetch,
            setIsDraggableRefetchedDataSynced,
            dataRowItems as DraggablesProp[],
            dispatchError,
          );
        }
      }}
      onDragEnd={(result) => {
        handleOnDragEnd(
          result,
          draggableMutation,
          isDraggableRefetchedDataSynced,
          dataRowItems as DraggablesProp[],
          setDataRowItems,
        );
      }}
    >
      <Droppable droppableId="approvals">
        {(provided) => (
          <div
            className="rb_index-table-row rb_table-row"
            {...provided.droppableProps}
            ref={provided.innerRef}
          >
            {dataRowItems}
            {provided.placeholder}
          </div>
        )}
      </Droppable>
    </DragDropContext>
  );
}
```

---
## `EditVirtualAccountModal.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  getIn,
  Field,
  Form,
  Formik,
  FormikErrors,
  FormikTouched,
} from "formik";
import * as Yup from "yup";
import { Heading, ConfirmModal, Label } from "../../common/ui-components";
import { FormikErrorMessage, FormikInputField } from "../../common/formik";
import FormikKeyValueInput, {
  FieldTypeEnum,
} from "../../common/formik/FormikKeyValueInput";
import FormikCounterpartyAsyncSelect from
"../../common/formik/FormikCounterpartyAsyncSelect";
import trackEvent from "../../common/utilities/trackEvent";
import { VIRTUAL_ACCOUNT_EVENTS } from "../../common/constants/analytics";
import {
  useUpdateVirtualAccountMutation,
  VirtualAccountViewQuery,
} from "../../generated/dashboard/graphqlSchema";
import { VIRTUAL_ACCOUNT } from "../../generated/dashboard/types/resources";
import { formatMetadata } from
"../containers/virtual_account_form/virtualAccountUtils";
import { useDispatchContext } from "../MessageProvider";

interface MetadataValue {
  key: string;
  value: string;
}

interface FormValues {
  name: string;
  counterparty?: { label: string; value: string } | null;
  metadata?: Array<MetadataValue>;
}

const fieldInvalid = (
  errors: FormikErrors<FormValues>,
  touched: FormikTouched<FormValues>,
  fieldName: string,
) => (getIn(errors, fieldName) && getIn(touched, fieldName)) as boolean;

function EditVirtualAccountForm() {
  return (
    <Form>
      <div className="mb-3 mt-3">
        <div className="flex flex-row justify-between pb-2">
          <Label id="name" className="text-sm font-normal text-gray-800">
            Name
          </Label>
        </div>
        <Field
          id="name"
          name="name"
          placeholder="Enter account name"
          component={FormikInputField}
        />
        <FormikErrorMessage name="name" />
      </div>
      <div className="mt-3">
        <div className="flex flex-row items-center justify-between pb-2">
          <Label
            id="counterparty"
            className="text-sm font-normal text-gray-800"
          >
            Counterparty
          </Label>
          <span className="pl-2 text-xs font-normal text-text-muted">
            Optional
          </span>
        </div>
        <FormikCounterpartyAsyncSelect />
      </div>
      <div className="mt-3">
        <FormikKeyValueInput
          fieldType={FieldTypeEnum.Metadata}
          fieldInvalid={fieldInvalid}
          resource={VIRTUAL_ACCOUNT}
        />
      </div>
    </Form>
  );
}

interface EditVirtualAccountModalProps {
  setIsOpen: (isOpen: boolean) => void;
  virtualAccount: NonNullable<VirtualAccountViewQuery["virtualAccount"]>;
}

export default function EditVirtualAccountModal({
  setIsOpen,
  virtualAccount,
}: EditVirtualAccountModalProps) {
  const [updateVirtualAccount] = useUpdateVirtualAccountMutation();
  const { dispatchError, dispatchSuccess } = useDispatchContext();
  const { id, name, counterparty } = virtualAccount;

  const processMetadata = (values: FormValues) => {
    const formattedMetadata: Record<string, string> = formatMetadata(
      values.metadata || [],
    );

    /*
     * If user is trying to delete a key-value pair, add the pair back into
     * the mutation input but with a blank value (format expected by
     * MetadataService for metadata deletion)
     */
    const existingMetadata: Array<MetadataValue> = JSON.parse(
      virtualAccount.metadata,
    ) as Array<MetadataValue>;

    existingMetadata.forEach((pair: { key: string; value: string }) => {
      if (!formattedMetadata[pair.key]) {
        formattedMetadata[pair.key] = "";
      }
    });

    return formattedMetadata;
  };

  const handleSubmit = async (values: FormValues) => {
    const processedMetadata = processMetadata(values);

    const result = await updateVirtualAccount({
      variables: {
        input: {
          id: id || "",
          name: values.name,
          counterpartyId: values.counterparty?.value,
          metadata: JSON.stringify(processedMetadata),
        },
      },
    });

    if (result?.data?.updateVirtualAccount) {
      const { virtualAccount: updatedVirtualAccount, errors } =
        result.data.updateVirtualAccount;
      setIsOpen(false);

      trackEvent(
        null,
        VIRTUAL_ACCOUNT_EVENTS.UPDATE_VIRTUAL_ACCOUNT_FORM_SUBMITTED,
      );

      if (updatedVirtualAccount) {
        dispatchSuccess("Details saved successfully.");
        return;
      }
      if (errors) {
        dispatchError(errors[0]);
      }
    }
  };

  const validate = Yup.object({
    name: Yup.string().required("Required"),
  });

  return (
    <Formik
      initialValues={{
        name,
        counterparty: counterparty
          ? {
              label: counterparty?.name,
              value: counterparty?.id,
            }
          : null,
        metadata: JSON.parse(virtualAccount.metadata) as Array<MetadataValue>,
      }}
      onSubmit={handleSubmit}
      validationSchema={validate}
    >
      {(form) => (
        <ConfirmModal
          title="Edit virtual account"
          isOpen
          onRequestClose={() => setIsOpen(false)}
          setIsOpen={() => setIsOpen(false)}
          confirmText={form.isSubmitting ? "Submitting..." : "Save"}
          confirmDisabled={form.isSubmitting}
          confirmType="confirm"
          onConfirm={() => {
            form.handleSubmit();
          }}
        >
          <Heading level="h1" size="l">
            {name}
          </Heading>
          <EditVirtualAccountForm />
        </ConfirmModal>
      )}
    </Formik>
  );
}
```

---
## `EnableScimOrganizationButton.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ReactTooltip from "react-tooltip";
import { Button } from "../../common/ui-components";

interface EnableScimOrganizationButtonProps {
  domainName: string;
  scimEnabled: boolean;
  onClick: () => void;
}

function EnableScimOrganizationButton({
  domainName,
  scimEnabled,
  onClick,
}: EnableScimOrganizationButtonProps) {
  return (
    <>
      {scimEnabled && (
        <Button buttonType="primary" disabled>
          SCIM Enabled for this Organization
        </Button>
      )}
      {!scimEnabled && (
        <Button buttonType="primary" disabled={!domainName} onClick={onClick}>
          {!domainName ? (
            <span data-tip="Organization domain is required to enable SCIM">
              Enable SCIM for this Organization
              <ReactTooltip className="whitespace-pre-wrap" multiline />
            </span>
          ) : (
            "Enable SCIM for this Organization"
          )}
        </Button>
      )}
    </>
  );
}

export default EnableScimOrganizationButton;
```

---
## `EndpointDetailsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import moment from "moment";
import { EndpointDetailsViewQuery } from
"../../generated/dashboard/graphqlSchema";
import {
  DateTime,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../common/ui-components";
import ContentDownloadButton from "./ContentDownloadButton";
import toShortId from "../../common/utilities/toShortId";

const MAPPING = {
  id: "ID",
  username: "Username",
  organizationName: "Organization Name",
  description: "Description",
  protocol: "Protocol",
  host: "Host",
  port: "Port",
  cleanAfterRead: "Clean After Read?",
  publicKey: "Public Key", // copyable, wrapped, codeblock
  clientCertificate: "Client Certificate",
  encryptionStrategy: "Encryption Strategy",
  decryptionStrategy: "Decryption Strategy",
  publicEncryptionKey: "Public Encryption Key",
  signingStrategy: "Signing Strategy",
  publicSigningKey: "Public Signing Key",
  signingCertificate: "Signing Certificate",
  createdAt: "Created At",
};

type Endpoint = EndpointDetailsViewQuery["endpoint"];

interface EndpointDetailsViewProps {
  endpoint?: Endpoint;
}

interface ToFilenameArgs {
  endpoint: Endpoint;
  descriptor: string;
  extension: string;
}
function toFilename({ endpoint, descriptor, extension }: ToFilenameArgs) {
  const orgName = endpoint.organizationName?.replace(/\s/g, "_") ?? "";
  const date = moment().format("YYYY-MM-DD");
  const shortId = toShortId(endpoint.id);
  const name = [orgName, shortId, date, descriptor]
    .filter((n) => !!n)
    .join("_");
  return `${name}.${extension}`;
}

function formatEndpoint(endpoint: Endpoint) {
  return {
    ...endpoint,
    publicKey: endpoint.publicKey && (
      <ContentDownloadButton
        filename={toFilename({ endpoint, descriptor: "rsa", extension: "pub" })}
        content={endpoint.publicKey}
      >
        Download SSH Key
      </ContentDownloadButton>
    ),
    signingCertificate: endpoint.signingCertificate && (
      <ContentDownloadButton
        filename={toFilename({
          endpoint,
          descriptor: "signing_cert",
          extension: "pem",
        })}
        content={endpoint.signingCertificate}
      >
        Download Signing Certificate
      </ContentDownloadButton>
    ),
    clientCertificate: endpoint.clientCertificate && (
      <ContentDownloadButton
        filename={toFilename({
          endpoint,
          descriptor: "client_cert",
          extension: "pem",
        })}
        content={endpoint.clientCertificate}
      >
        Download Client Certificate
      </ContentDownloadButton>
    ),
    publicSigningKey: endpoint.publicSigningKey && (
      <ContentDownloadButton
        filename={toFilename({ endpoint, descriptor: "pgp", extension: "pub" })}
        content={endpoint.publicSigningKey}
      >
        Download Public Signing Key
      </ContentDownloadButton>
    ),
    createdAt: <DateTime timestamp={endpoint.createdAt} />,
    cleanAfterRead: endpoint.cleanAfterRead ? "True" : "False",
  };
}

function EndpointDetailsView({ endpoint }: EndpointDetailsViewProps) {
  return endpoint ? (
    <>
      <KeyValueTable
        key={endpoint.id}
        data={formatEndpoint(endpoint) ?? []}
        dataMapping={MAPPING}
      />
      <div className="mt-4" />
    </>
  ) : (
    <KeyValueTableSkeletonLoader dataMapping={MAPPING} />
  );
}

export default EndpointDetailsView;
```

---
## `EndpointTreeView.tsx.txt`
**Path:** `.`  
```
import React, { useCallback, useEffect, useState } from "react";
import ReactTooltip from "react-tooltip";
import ReactJson from "react-json-view";
import { ClipLoader } from "react-spinners";
import debounce from "lodash/debounce";
import { stringify } from "qs";
import { useEndpointTreeQuery } from "../../generated/dashboard/graphqlSchema";
import { parse } from "../../common/utilities/queryString";
import { Input, Tooltip } from "../../common/ui-components";

const DEFAULT_DEBOUNCE_MS = 900;

type QueryArgs = {
  path?: string;
  pattern?: string;
};

interface EndpointTreeViewProps {
  endpointId: string;
}

function EndpointTreeView({ endpointId }: EndpointTreeViewProps) {
  const params = parse(window.location.search);
  const [pathSearchValue, setPathSearchValue] = useState(params.path as string);
  const [patternSearchValue, setPatternSearchValue] = useState(
    params.pattern as string,
  );
  const [isFirstQuery, setIsFirstQuery] = useState(true);

  const { data, error, loading, refetch } = useEndpointTreeQuery({
    // necessary for `loading` to be updated on refetch
    notifyOnNetworkStatusChange: true,
    variables: { endpointId, ...params },
  });

  const handleRefetch = async (query: QueryArgs) => {
    await refetch({ ...query });
    window.history.replaceState(
      null,
      "",
      `?${stringify({ ...params, ...query })}`,
    );
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncer = useCallback(
    debounce(handleRefetch, DEFAULT_DEBOUNCE_MS),
    [],
  );

  useEffect(
    () => {
      if (isFirstQuery) {
        // refetch every time **except** after the first query (to avoid a
        double-query on first render)
        setIsFirstQuery(false);
      } else {
        void debouncer({ path: pathSearchValue, pattern: patternSearchValue });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [pathSearchValue, patternSearchValue],
  );

  return (
    <div>
      <div className="mb-6 flex gap-6">
        <div>
          <div className="form-label-container">
            <div className="form-label">
              Directory
              <Tooltip
                className="tooltip-holder"
                data-tip="The directory in which you'd like to search for files"
              />
              <ReactTooltip
                multiline
                data-place="top"
                data-type="dark"
                data-effect="float"
              />
            </div>
          </div>
          <Input
            disabled={error != null}
            prefixIconName="search"
            placeholder="/foo/bar"
            value={pathSearchValue}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setPathSearchValue(e.target.value)
            }
            name="path"
          />
        </div>
        <Input
          disabled={error != null}
          prefixIconName="search"
          placeholder="\.txt$"
          value={patternSearchValue}
          label="File Pattern"
          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
            setPatternSearchValue(e.target.value)
          }
          name="pattern"
        />
      </div>
      {!loading && !error ? (
        <ReactJson
          src={
            JSON.parse(data?.endpointTree as string) as Record<string, unknown>
          }
          name={null}
          displayDataTypes={false}
          indentWidth={2}
        />
      ) : (
        !error && <ClipLoader />
      )}
    </div>
  );
}

export default EndpointTreeView;
```

---
## `EntityEventTableView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { useEntityEventTableQuery } from
"../../generated/dashboard/graphqlSchema";
import { DateTime, IndexTable } from "../../common/ui-components";

const DATAMAPPING = {
  eventName: "Event",
  createdAt: "Timestamp",
  entityId: "Entity ID",
};

function EntityEventTableView({
  entityId,
  resource,
}: {
  entityId: string;
  resource: string;
}) {
  const { loading, data, error } = useEntityEventTableQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      entityId,
      resource,
    },
  });
  const events =
    loading || !data || error
      ? []
      : data.events.edges.map(({ node }) => ({
          ...node,
          eventName: `${node.resource}.${node.name}`,
          createdAt: <DateTime timestamp={node.createdAt} />,
        }));
  return <IndexTable dataMapping={DATAMAPPING} data={events} />;
}

export default EntityEventTableView;
```

---
## `EntityTableView.tsx.txt`
**Path:** `.`  
```
import React, { ReactNode, useState, useEffect } from "react";
import * as Sentry from "@sentry/browser";
import { isEmpty, omit, omitBy } from "lodash";
import { cn } from "~/common/utilities/cn";
import { ResourcesEnum } from "~/generated/dashboard/types/resources";
import {
  CombinedQuery,
  EntityTableViewQuery,
  PAGINATION_NEXT,
  PAGINATION_PREVIOUS,
  parseQuery,
  replaceSearchParams,
} from "~/common/utilities/queryString";
import {
  ExportObjectEnum,
  DisplayColumn,
  PageInfo,
  View,
} from "../../generated/dashboard/graphqlSchema";
import EntityTableViewCustomColumns from "./EntityTableViewCustomColumns";
import SearchContainer, {
  SearchContainerProps,
} from "../containers/SearchContainer";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import {
  Heading,
  IndexTable,
  IndexTableSkeletonLoader,
  PaginationRow2,
} from "../../common/ui-components";
import ExportDataButton from "./ExportDataButton";
import { Column } from "./ColumnSelectorDropdown";
import {
  NestingDataActions,
  IndexTableProps,
} from "../../common/ui-components/IndexTable/IndexTable";
import { useMountEffect } from "../../common/utilities/useMountEffect";
import { defaultColumnsAsDataMapping } from
"../../common/utilities/defaultColumnsDataMapping";
import Stack from "../../common/ui-components/Stack/Stack";
import { DraggableMutation } from "./Draggables";

export const INITIAL_PAGINATION = {
  total: 0,
  page: 1,
  perPage: 25,
};

export enum RenderSource {
  ListView = "list_view",
}

export type PaginationParams = {
  page: number;
  perPage: number;
};

type PaginationDirection = "previous" | "next";

export interface SharedEntityTableViewProps<D extends Record<string, unknown>>
  extends Omit<IndexTableProps<D>, "rowHighlightFunction">,
    Omit<SearchContainerProps, "updateQuery" | "setAppliedFiltersCount"> {
  /** Sets the content immediately below the table. */
  belowTableContent?: React.ReactNode;
  /** Sets the content immediately above the table. */
  children?: ReactNode;
  /** Query string parameters which are not controlled by this component.
   *
   * These parameters are ignored when determining if the current query is empty
   (i.e., no filters are applied). */
  constantQueryParams?: Array<string>;
  /** Renders pagination if `hasNextPage` or `hasPreviousPage` is `true`.
  Defaults to `false`. */
  cursorPagination?: PageInfo;
  /** Sets the default number of records per page in paginated ListViews.
   *
   * Defaults to `25`.
   */
  defaultPerPage?: number;
  /** When `true`, prevents the URL query string from being updated when the
  filters or pagination is changed.  */
  disableQueryURLParams?: boolean;
  /** Callback that runs onDragEnd that takes in an `id` and `sortableId`.
   * When callback is passed in, draggables are enabled and icon appears to the
   left of the item.
   */
  draggableMutation?: DraggableMutation | false;
  /** When `true`, renders a button to enable data export ot the user. */
  enableExportData?: boolean;
  /** Renders a button to the upper-right of `<SearchContainer>`, right of
  `newBulkEntityButton`. */
  newEntityButton?: React.ReactNode;
  /**
   * Callback function that gets called when the user hits the sort button on a
   sortable column.
   */
  onSortChange?: (columnName: string) => void;
  /** When function returns `true`, applies an italic font to table row.
   *
   * Used to illustrate ephemeral states such as a row showing a pending
   transction, or a deleted API key, for example.
   */
  rowHighlightFunction?: (dataRow: { [K in keyof D]: D[K] }) => boolean;
  /** When `true`, shows pagination even if disabled. */
  showDisabledPagination?: boolean;
  /** When `true`, renders search container. */
  showSearchContainer?: boolean;
  /** Renders the table subtitle. */
  subtitle?: ReactNode;
  /** Renders the table title. */
  title?: ReactNode;
  /** Sets content below entity buttons. */
  rightHeaderContent?: React.ReactNode;
  /** Used to indicate what is the parent component which is rendering
  EntityTableView */
  renderSource?: RenderSource;
  /** Sets the initial query for the filters */
  initialQuery?: Record<string, unknown>;
  /** Flag to enable the new filter UI */
  enableNewFilters?: boolean;
  /** Used to indicate when the list of available filters is loading. */
  filtersLoading?: boolean;
  /** Mapping function to convert the legacy filter format to the new format */
  legacyQueryToFilters?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  /** Mapping function to convert the new filter format to the old format (for
  CSV exports) */
  filtersToLegacyFormat?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  /** View object for persisting view documents */
  view?: View;
  setSelectedRowCallback?: (ids: string[]) => void;
  setSelectEverythingCallback?: (selectEverything: boolean) => void;
  initialSelectedRows?: string[];
  filterIdsToRemove?: string[];
  /** Scoped name to further namespace URL params */
  scopedParamName?: string;
  overrideRowLinkClickHandler?: (url: string) => void;
}

type EntityTableViewProps<
  D extends Record<string, unknown>,
  Q extends Record<string, unknown>,
> = {
  /** When `true`, allows user to customize which columns are displayed in the
  table. */
  customizableColumns?: boolean;
  /** Sets the data for the table cells. Each item should have an id. */
  data: Array<D>;
  /** On load more or top level filter changes, this query executes. */
  onNestedQueryArgChange?: (
    query: Q,
    id: string,
    action: NestingDataActions,
  ) => Promise<void>;
  /** On pagination or filter change, this query executes. */
  onQueryArgChange: (
    options: {
      cursorPaginationParams: CursorPaginationInput;
      query: Q;
      emptyQuery?: boolean;
      paginationParams?: PaginationParams;
    },
    debounceQuery?: boolean,
  ) => Promise<void>;
  /** Overrides resource when passed in for "Export CSV" button. */
  nestingResource?: ResourcesEnum;
};

// If going next, return pagination for first 25 after endCursor
// If going previous, return pagination for last 25 before startCursor
export const cursorPaginationParams = (
  cursorPagination: PageInfo | null,
  query: EntityTableViewQuery,
  pagination: { page: number; perPage: number },
  paginationDirection?: PaginationDirection,
): CursorPaginationInput => {
  const after =
    paginationDirection === PAGINATION_NEXT
      ? cursorPagination?.endCursor || query.endCursor
      : undefined;
  const before =
    paginationDirection === PAGINATION_PREVIOUS
      ? cursorPagination?.startCursor || query.startCursor
      : undefined;
  const last =
    paginationDirection === PAGINATION_PREVIOUS
      ? pagination.perPage
      : undefined;
  const first =
    paginationDirection !== PAGINATION_PREVIOUS
      ? pagination.perPage
      : undefined;

  return {
    after,
    before,
    last,
    first,
  };
};

export const isEmptyQuery = (
  query: EntityTableViewQuery,
  baseQueryValues: Array<string>,
) => {
  const searchParams = omit(query, baseQueryValues);
  const nonemptySearchParams = omitBy(
    searchParams,
    (value) => typeof value === "string" && value === "",
  );
  return Object.values(nonemptySearchParams).filter(Boolean).length === 0;
};

function EntityTableView<
  D extends Record<string, unknown>,
  Q extends Record<string, unknown>,
>({
  actionExcludedRows,
  actions,
  additionalSearchComponents = [],
  belowTableContent,
  children,
  className = "",
  constantQueryParams: additionalQueryValues = [],
  cursorPagination = { hasNextPage: false, hasPreviousPage: false },
  customizableColumns = false,
  data,
  dataMapping,
  defaultPerPage = INITIAL_PAGINATION.perPage,
  defaultSearchComponents = [],
  disableActionButtons,
  disableActionsHoverMessage,
  disableBulkActions = false,
  disableMetadata,
  disableQueryURLParams,
  displayColumns,
  draggableMutation = false,
  draggableRefetch,
  emptyDataRowText,
  enableActions,
  enableExportData,
  expandedData,
  exportDataParams,
  favorites,
  favoritesEnabled = false,
  filters,
  fullWidth,
  inCard = false,
  hasMoreNestedData,
  horizontalDefaultSearchComponents = false,
  initialShowSearchArea,
  isNestedDataLoading,
  itemsSelectedString,
  loading,
  metadataMapping,
  nestedData,
  nestingClickBehavior,
  nestingResource,
  newEntityButton,
  onColumnSelectionChange,
  onSortChange,
  onNestedQueryArgChange,
  onQueryArgChange,
  renderCustomActions,
  renderCustomActionsHeader,
  renderDrawerContent,
  renderHeader = true,
  resource,
  rightHeaderContent,
  rowHighlightFunction,
  scrollX,
  stickyHeader,
  selectAllItemsString,
  selectedColumns,
  selectedMetadataColumns,
  showDisabledPagination = true,
  showSearchContainer = true,
  stacked = false,
  styleMapping,
  subtitle,
  summaryRows = false,
  title,
  totalCount,
  initialQuery = {},
  renderSource,
  enableNewFilters,
  filtersLoading,
  legacyQueryToFilters,
  filtersToLegacyFormat,
  setSelectedRowCallback,
  setSelectEverythingCallback,
  initialSelectedRows,
  filterIdsToRemove,
  scopedParamName,
  hideAllCheckboxes,
  overrideRowLinkClickHandler,
  overflowStyleMapping,
}: EntityTableViewProps<D, Q> &
  SharedEntityTableViewProps<D> & {
    dataMapping: Record<string, React.ReactNode>;
    displayColumns?: Array<DisplayColumn | Column>;
  }) {
  const initialParse = parseQuery(scopedParamName);
  const [pagination, setPagination] = useState({
    page: initialParse.page ? initialParse.page : INITIAL_PAGINATION.page,
    perPage: initialParse.perPage ? initialParse.perPage : defaultPerPage,
  });
  const [query, setQuery] = useState<CombinedQuery<Record<string, unknown>>>({
    ...initialParse,
    ...(isEmptyQuery(initialParse, additionalQueryValues) ? initialQuery : {}),
  });

  const sortableColumns = displayColumns
    ?.filter((column) => "sortColumn" in column && column.sortColumn !== "")
    .reduce((accumulator: string[], column) => [...accumulator, column.id], []);

  const columnIdToModel = displayColumns?.reduce(
    (acc: Record<string, string>, column) => {
      if ("sortColumn" in column && column.sortColumn) {
        acc[column.id] = column.sortColumn;
      }
      return acc;
    },
    {},
  );

  const [appliedFiltersCount, setAppliedFiltersCount] = useState<number>(0);

  // This component doesn't always unmount/remount
  //   (ListView has react optimizations that doesn't remount on tab switches
  but just changes props)
  // This forces on rerenders to reset all states managed by this component.
  // Stringify the objects to compare by value and prevent infinite rerenders
  const stringifiedParams = JSON.stringify(initialParse);
  const stringifiedInitialQuery = JSON.stringify(initialQuery);
  useEffect(() => {
    setPagination({
      page: initialParse.page ? initialParse.page : INITIAL_PAGINATION.page,
      perPage: initialParse.perPage ? initialParse.perPage : defaultPerPage,
    });
    setQuery({
      ...(isEmptyQuery(initialParse, additionalQueryValues)
        ? initialQuery
        : {}),
      ...parseQuery(scopedParamName),
    });
    // Dependencies are exhaustive, but eslint doesn't understand about
    stringified objects.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    initialParse.page,
    initialParse.perPage,
    stringifiedParams,
    defaultPerPage,
    stringifiedInitialQuery,
    scopedParamName,
  ]);

  useMountEffect(() => {
    if (renderSource === RenderSource.ListView) {
      return;
    }
    // Run once on initial render if url contains query params
    if (!isEmptyQuery(query, additionalQueryValues)) {
      onQueryArgChange({
        cursorPaginationParams: cursorPaginationParams(
          cursorPagination,
          query,
          pagination,
          query.paginationDirection,
        ),
        query: omitBy(
          query,
          (value) => typeof value === "string" && value === "",
        ) as Q,
        emptyQuery: isEmptyQuery(query, additionalQueryValues),
        paginationParams: pagination,
      }).catch((err) => {
        Sentry.captureException(err);
      });
    }
  });

  const onPerPageClick = (perPage: number) => {
    const newPagination = {
      ...pagination,
      page: INITIAL_PAGINATION.page,
      perPage,
    };
    // pagination page and perPage are saved in URL for range calculations
    const newQuery = {
      ...query,
      page: INITIAL_PAGINATION.page,
      perPage,
    };

    if (!disableQueryURLParams) {
      replaceSearchParams(newQuery, scopedParamName);
    }

    setQuery(newQuery);
    setPagination(newPagination);
    onQueryArgChange({
      cursorPaginationParams: {
        after: undefined,
        before: undefined,
        last: undefined,
        first: perPage,
      },
      query: omitBy(
        query,
        (value) => typeof value === "string" && value === "",
      ) as Q,
      emptyQuery: isEmptyQuery(newQuery, additionalQueryValues),
      paginationParams: pagination,
    }).catch((err) => {
      Sentry.captureException(err);
    });
  };

  const onPaginationClick = (page: number) => {
    const paginationDirection: PaginationDirection =
      pagination.page > page ? PAGINATION_PREVIOUS : PAGINATION_NEXT;
    const newPagination = { ...pagination, page };
    // pagination page and perPage are saved in URL for range calculations
    const newQuery = {
      ...query,
      paginationDirection,
      page,
      perPage: pagination.perPage,
      startCursor: cursorPagination.startCursor || undefined,
      endCursor: cursorPagination.endCursor || undefined,
    };

    if (!disableQueryURLParams) {
      replaceSearchParams(newQuery, scopedParamName);
    }

    setQuery(newQuery);
    setPagination(newPagination);
    onQueryArgChange({
      cursorPaginationParams: cursorPaginationParams(
        cursorPagination,
        query,
        pagination,
        paginationDirection,
      ),
      query: omitBy(
        query,
        (value) => typeof value === "string" && value === "",
      ) as Q,
      emptyQuery: isEmptyQuery(newQuery, additionalQueryValues),
      paginationParams: newPagination,
    }).catch((err) => {
      Sentry.captureException(err);
    });
  };

  const updateQueryAndPagination = (
    input: Record<string, unknown>,
    debounceQuery?: boolean,
  ) => {
    const newQuery = {
      ...query,
      ...input,
      ...INITIAL_PAGINATION,
      paginationDirection: undefined,
      startCursor: undefined,
      endCursor: undefined,
    };

    if (!disableQueryURLParams) {
      replaceSearchParams(newQuery, scopedParamName);
    }

    setQuery(newQuery);
    setPagination(INITIAL_PAGINATION);
    onQueryArgChange(
      {
        cursorPaginationParams: {
          after: undefined,
          before: undefined,
          last: undefined,
          first: 25,
        },
        query: omitBy(
          newQuery,
          (value) => typeof value === "string" && value === "",
        ) as Q,
        emptyQuery: isEmptyQuery(newQuery, additionalQueryValues),
        paginationParams: pagination,
      },
      debounceQuery,
    ).catch((err) => {
      Sentry.captureException(err);
    });
  };

  const updateNestedData = (id: string, action: NestingDataActions) => {
    const newQuery = {
      ...query,
    };

    if (onNestedQueryArgChange)
      void onNestedQueryArgChange(newQuery as Q, id, action);
  };

  let container;

  if (loading) {
    const headers: Array<React.ReactNode> = [];
    const headerStyles: Array<string | null> = [];
    Object.keys(dataMapping).forEach((key) => {
      headers.push(dataMapping[key]);
      headerStyles.push(styleMapping ? styleMapping[key] : null);
    });

    container = (
      <IndexTableSkeletonLoader
        headers={headers}
        numRows={Math.floor(INITIAL_PAGINATION.perPage / 2)}
        headerStyles={headerStyles}
      />
    );
  } else {
    container = (
      <IndexTable
        actionExcludedRows={actionExcludedRows}
        actions={actions}
        className={className}
        columnIdToModel={columnIdToModel}
        data={data}
        dataMapping={dataMapping}
        disableActionButtons={disableActionButtons}
        disableActionsHoverMessage={disableActionsHoverMessage}
        disableBulkActions={disableBulkActions}
        disableDraggableRows={appliedFiltersCount > 0}
        draggableMutation={draggableMutation}
        draggableRefetch={draggableRefetch}
        emptyDataRowText={emptyDataRowText}
        enableActions={enableActions}
        expandedData={expandedData}
        favoritesEnabled={favoritesEnabled}
        favorites={favorites}
        fullWidth={fullWidth}
        inCard={inCard}
        hasFilters={filters && true}
        hasMoreNestedData={hasMoreNestedData}
        hideAllCheckboxes={hideAllCheckboxes}
        isNestedDataLoading={isNestedDataLoading}
        itemsSelectedString={itemsSelectedString}
        metadataMapping={metadataMapping}
        nestedData={nestedData}
        nestingClickBehavior={nestingClickBehavior}
        onSortChange={onSortChange}
        orderBy={query.orderBy}
        resource={resource}
        renderCustomActions={renderCustomActions}
        renderCustomActionsHeader={renderCustomActionsHeader}
        renderDrawerContent={renderDrawerContent}
        renderHeader={renderHeader}
        rowHighlightFunction={rowHighlightFunction}
        scrollX={scrollX}
        stickyHeader={stickyHeader}
        selectAllItemsString={selectAllItemsString}
        sortableColumns={sortableColumns}
        stacked={stacked}
        styleMapping={styleMapping}
        summaryRows={summaryRows}
        totalCount={totalCount}
        updateNestedData={updateNestedData}
        updateQuery={updateQueryAndPagination}
        setSelectedRowCallback={setSelectedRowCallback}
        setSelectEverythingCallback={setSelectEverythingCallback}
        initialSelectedRows={initialSelectedRows}
        overrideRowLinkClickHandler={overrideRowLinkClickHandler}
        overflowStyleMapping={overflowStyleMapping}
      />
    );
  }

  const shouldShowSearchContainer =
    (additionalSearchComponents.length ||
      defaultSearchComponents.length ||
      filters?.length ||
      customizableColumns) &&
    showSearchContainer;

  const hasFirstTitle =
    defaultSearchComponents.length &&
    (defaultSearchComponents[0].includeTopFilterMargin ||
      defaultSearchComponents[0].label);

  const exportDataButton = enableExportData && resource && (
    <div className={cn("mb-4 justify-self-end", { "mt-2": hasFirstTitle })}>
      <ExportDataButton
        exportableType={
          (nestingResource as ExportObjectEnum) ||
          (resource as ExportObjectEnum)
        }
        exportDataParams={exportDataParams}
        scopedParamName={scopedParamName}
      />
    </div>
  );

  return (
    <Stack
      className={cn(
        "grid-cols-1 gap-4",
        (showDisabledPagination ||
          cursorPagination.hasPreviousPage ||
          cursorPagination.hasNextPage) &&
          "grid-rows-[minmax(100px,_1fr)_32px] has-[>*:nth-child(3)]:grid-
          rows-[auto_minmax(100px,_1fr)_32px]",
      )}
    >
      {(title || subtitle || newEntityButton) && (
        <div className="flex items-center justify-between gap-6">
          {(title || subtitle) && (
            <Stack>
              {title && (
                <Heading level="h2" size="l">
                  {title}
                </Heading>
              )}
              {subtitle && (
                <div className="max-w-md text-sm text-gray-600">{subtitle}</div>
              )}
            </Stack>
          )}
          <div className="flex flex-wrap">
            {newEntityButton && <div>{newEntityButton}</div>}
          </div>
        </div>
      )}
      <div className="col-span-1">
        {shouldShowSearchContainer && (
          <SearchContainer
            additionalSearchComponents={additionalSearchComponents}
            alwaysVisible={false}
            customizableColumns={customizableColumns}
            defaultSearchComponents={defaultSearchComponents}
            disableMetadata={disableMetadata}
            displayColumns={displayColumns}
            enableExportData={enableExportData}
            exportDataParams={exportDataParams}
            filters={filters}
            fullWidth={fullWidth}
            horizontalDefaultSearchComponents={
              horizontalDefaultSearchComponents
            }
            initialShowSearchArea={
              initialShowSearchArea !== undefined
                ? initialShowSearchArea
                : !isEmptyQuery(query, additionalQueryValues)
            }
            loading={loading}
            onColumnSelectionChange={onColumnSelectionChange}
            query={query}
            resource={resource}
            selectedColumns={selectedColumns}
            selectedMetadataColumns={selectedMetadataColumns}
            setAppliedFiltersCount={setAppliedFiltersCount}
            updateQuery={updateQueryAndPagination}
            enableNewFilters={enableNewFilters}
            filtersLoading={filtersLoading}
            legacyQueryToFilters={legacyQueryToFilters}
            filtersToLegacyFormat={filtersToLegacyFormat}
            filterIdsToRemove={filterIdsToRemove}
          >
            <div className="flex flex-row gap-3">
              {!!rightHeaderContent && rightHeaderContent}
              {exportDataButton}
            </div>
          </SearchContainer>
        )}
        {!shouldShowSearchContainer && exportDataButton}
        {children}
        {container}
        {belowTableContent}
      </div>

      {(showDisabledPagination ||
        cursorPagination.hasPreviousPage ||
        cursorPagination.hasNextPage) && (
        <PaginationRow2
          {...pagination}
          disabled={loading}
          onClick={onPaginationClick}
          pageLowerBound={
            pagination.perPage * (pagination.page - 1) +
            (data.length > 0 ? 1 : 0)
          }
          pageUpperBound={
            Math.min(data.length, pagination.perPage) +
            pagination.perPage * (pagination.page - 1)
          }
          hasPrevPage={cursorPagination.hasPreviousPage}
          hasNextPage={cursorPagination.hasNextPage}
          onPerPageClick={onPerPageClick}
        />
      )}
    </Stack>
  );
}

/**
 * Creates a table with filters and pagination. Builds the UI of `<ListView>`.
 *
 * [View in the MINT Documentation â](https://mt.style/?path=/docs/system-ui-
 tables-entitytableview--docs)
 */
function ColumnSelectorWrapper<
  D extends Record<string, unknown>,
  Q extends Record<string, unknown>,
>({
  customizableColumns,
  displayColumns,
  dataMapping = {},
  view,
  usingPersistedViews,
  ...props
}: EntityTableViewProps<D, Q> &
  SharedEntityTableViewProps<D> & {
    dataMapping?: Record<string, React.ReactNode>;
    displayColumns?: Array<DisplayColumn>;
    view?: View;
    usingPersistedViews?: boolean;
  }) {
  // We want to avoid passing in a null `view` into
  EntityTableViewCustomColumns.
  // This greatly simplifies the process of setting the default selected
  columns.
  return customizableColumns &&
    ((usingPersistedViews && view) || !usingPersistedViews) ? (
    <EntityTableViewCustomColumns
      displayColumns={displayColumns}
      dataMapping={dataMapping}
      view={view}
      usingPersistedViews={usingPersistedViews || false}
      scopedParamName={props.scopedParamName}
    >
      {({
        selectedColumns,
        selectedMetadataColumns,
        dataMapping: computedDataMapping,
        displayColumns: computedDisplayColumns,
        metadataMapping,
        onColumnSelectionChange,
      }) => (
        <EntityTableView
          {...props}
          displayColumns={computedDisplayColumns}
          selectedColumns={selectedColumns}
          selectedMetadataColumns={selectedMetadataColumns}
          dataMapping={computedDataMapping}
          metadataMapping={metadataMapping}
          onColumnSelectionChange={onColumnSelectionChange}
          customizableColumns={customizableColumns}
          view={view}
        />
      )}
    </EntityTableViewCustomColumns>
  ) : (
    <EntityTableView
      {...props}
      customizableColumns={customizableColumns}
      dataMapping={
        isEmpty(dataMapping)
          ? defaultColumnsAsDataMapping(displayColumns)
          : dataMapping
      }
    />
  );
}

export default ColumnSelectorWrapper;
```

---
## `EntityTableViewCustomColumns.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import invariant from "ts-invariant";
import useViewDocument from
"~/common/utilities/persisted_views/useViewDocument";
import { DisplayColumnTypeEnum } from
"~/generated/dashboard/types/displayColumnTypeEnum";
import { parse, replaceSearchParams } from "../../common/utilities/queryString";
import {
  DisplayColumn,
  View,
  ViewDocumentTypeEnum,
} from "../../generated/dashboard/graphqlSchema";
import { Column } from "./ColumnSelectorDropdown";

const computeDataMapping = (
  dataMapping: Record<string, string | React.ReactNode>,
  defaultColumns: Array<string>,
  selectedColumns: Array<string> = [],
  selectedMetadataColumns: Array<string> = [],
) => {
  if (selectedColumns.length === 0 && selectedMetadataColumns.length === 0) {
    return Object.keys(dataMapping).reduce(
      (acc, columnId) =>
        defaultColumns.includes(columnId)
          ? { ...acc, [columnId]: dataMapping[columnId] }
          : acc,
      {},
    );
  }

  return Object.keys(dataMapping).reduce((acc, columnId) => {
    if (selectedColumns.find((column) => column === columnId)) {
      return {
        ...acc,
        [columnId]: dataMapping[columnId],
      };
    }
    return acc;
  }, {});
};

const computeDisplayColumns = (
  simpleDataMapping: Record<string, React.ReactNode>,
  displayColumns: Array<DisplayColumn>,
) => {
  if (displayColumns.length) {
    return displayColumns;
  }

  return Object.keys(simpleDataMapping).reduce<Array<Column>>((acc, key) => {
    invariant(
      typeof simpleDataMapping[key] === "string",
      "The column selector does not support data mappings which contain react
      nodes.",
    );
    return [
      ...acc,
      {
        id: key,
        label: simpleDataMapping[key] as string,
      },
    ];
  }, []);
};

function parseQuery(scopedParamName?: string): {
  selectedColumns: Array<string>;
  selectedMetadataColumns: Array<string>;
} {
  const { selectedColumns, selectedMetadataColumns } = scopedParamName
    ? parse(
        // if scopedParamName supplied, further parse the specific paramName
        parameters
        (parse(window.location.search)[scopedParamName] as
          | string
          | undefined) || "",
      )
    : parse(window.location.search);

  return {
    selectedColumns: Array.isArray(selectedColumns)
      ? (selectedColumns as Array<string>)
      : [],
    selectedMetadataColumns: Array.isArray(selectedMetadataColumns)
      ? (selectedMetadataColumns as Array<string>)
      : [],
  };
}

type CustomColumnArgs = {
  selectedColumns?: Array<string>;
  selectedMetadataColumns?: Array<string>;
  onColumnSelectionChange?: (change: ColumnSelectionType) => void;
  dataMapping: Record<string, React.ReactNode>;
  displayColumns: Array<Column>;
  metadataMapping: Record<string, string>;
};

type ColumnSelectionType = Record<string, Array<string>>;

interface EntityTableViewCustomColumnsProps {
  dataMapping?: Record<string, React.ReactNode>;
  displayColumns?: Array<DisplayColumn>;
  children: (args: CustomColumnArgs) => React.ReactElement<React.ReactNode>;
  view?: View;
  usingPersistedViews: boolean;
  scopedParamName?: string;
}

/**
 * The sole purpose of this component is managing the state of the currently
 selected columns.
 * It can accept either `dataMapping` or `displayColumns` as the list of
 selectable columns.
 *
 * Ideally, `displayColumns` should be the only interface once we proliferate
 the use of `ListView`.
 */
function EntityTableViewCustomColumns({
  displayColumns = [],
  dataMapping: simpleDataMapping = {},
  view,
  usingPersistedViews,
  children,
  scopedParamName,
}: EntityTableViewCustomColumnsProps) {
  const {
    selectedColumns: initialSelectedColumnsFromQuery,
    selectedMetadataColumns: initialSelectedMetadataColumnsFromQuery,
  } = parseQuery(scopedParamName);

  const { viewDocument, updateViewDocument } = useViewDocument(
    view,
    ViewDocumentTypeEnum.CustomColumns,
  );

  let initialSelectedColumns: Array<string> = [];
  let initialSelectedMetadataColumns: Array<string> = [];

  if (
    initialSelectedColumnsFromQuery.length ||
    initialSelectedMetadataColumnsFromQuery.length
  ) {
    initialSelectedColumns = initialSelectedColumnsFromQuery;
    initialSelectedMetadataColumns = initialSelectedMetadataColumnsFromQuery;
  } else if (usingPersistedViews && viewDocument) {
    const parsedDocument = JSON.parse(
      viewDocument.document,
    ) as ColumnSelectionType;

    initialSelectedColumns = parsedDocument.selectedColumns;
    initialSelectedMetadataColumns = parsedDocument.selectedMetadataColumns;
  }

  const [selectedColumns, setSelectedColumns] = useState<string[]>(
    initialSelectedColumns,
  );
  const [selectedMetadataColumns, setSelectedMetadataColumns] = useState<
    string[]
  >(initialSelectedMetadataColumns);

  // going to add the ability for overridingColumns
  // going to add the scoping by certain paramaters
  const handleColumnSelectionChange = (change: ColumnSelectionType) => {
    replaceSearchParams(change, scopedParamName);

    if (usingPersistedViews) {
      void updateViewDocument(JSON.stringify(change));
    }

    setSelectedColumns(change.selectedColumns);
    setSelectedMetadataColumns(change.selectedMetadataColumns);
  };

  const defaultColumns = displayColumns.length
    ? displayColumns
        .filter((column) => column.viewOptions.listView?.default)
        .map(({ id }) => id)
    : Object.keys(simpleDataMapping);

  const dataMapping = displayColumns.length
    ? displayColumns.reduce<Record<string, string>>((acc, displayColumn) => {
        let { label } = displayColumn;
        const customLabel = displayColumn.viewOptions.listView?.label;

        if (
          displayColumn.type ===
            DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicator &&
          displayColumn.displayTypeOptions?.__typename ===
            "StatusIndicatorOption" &&
          !displayColumn.displayTypeOptions?.statusIndicatorVerboseField &&
          !customLabel
        ) {
          label = "";
        } else if (typeof customLabel === "string") {
          label = customLabel;
        }
        return { ...acc, [displayColumn.id]: label };
      }, {})
    : simpleDataMapping;

  return children({
    selectedColumns:
      selectedColumns.length === 0 ? defaultColumns : selectedColumns,
    // Filter out empty metadata keys to remove them from persisted views
    selectedMetadataColumns: selectedMetadataColumns.filter(
      (e) => e.length > 0,
    ),
    displayColumns: computeDisplayColumns(simpleDataMapping, displayColumns),
    dataMapping: computeDataMapping(
      dataMapping,
      defaultColumns,
      selectedColumns,
      selectedMetadataColumns,
    ),
    metadataMapping: (selectedMetadataColumns || []).reduce(
      (acc, column) => ({ ...acc, [column]: column }),
      {},
    ),
    onColumnSelectionChange: handleColumnSelectionChange,
  });
}

export default EntityTableViewCustomColumns;
```

---
## `ExpectedPaymentBulkImport.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import useLiveConfiguration from "~/common/utilities/useLiveConfiguration";
import {
  useBulkCreateExpectedPaymentsMutation,
  useBulkValidateExpectedPaymentsMutation,
} from "../../generated/dashboard/graphqlSchema";
import { BulkResourceType } from "./FlatfileBulkUploadButton";
import BulkImportHeader from "./BulkImportHeader";
import InternalAccountIdsList from "./InternalAccountIdsList";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import { getExpectedPaymentBlueprint } from
"./bulk_imports/blueprints/expectedPaymentBlueprint";

function ExpectedPaymentBulkImport(): JSX.Element {
  const [bulkCreateExpectedPayments] = useBulkCreateExpectedPaymentsMutation();
  const [bulkValidateExpectedPayments] =
    useBulkValidateExpectedPaymentsMutation();
  const [useLegacyMatchFilters] = useLiveConfiguration({
    featureName: "reconciliation/legacy_match_filters",
  });

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateExpectedPayments({
      variables: {
        input: {
          expectedPayments: resultsData,
          flatfileSheetId,
          flatfileSpaceId,
        },
      },
    });
    const { bulkImportId } = data?.bulkCreateExpectedPayments ?? {};
    if (bulkImportId) {
      return { success: true, bulkImportId };
    }
    return { success: false, bulkImportId: "" };
  };

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateExpectedPayments({
      variables: {
        input: {
          expectedPayments: resultsData,
        },
      },
    });
    return response.data?.bulkValidateExpectedPayments?.recordErrors;
  };
  const expectedPaymentBlueprint = getExpectedPaymentBlueprint(
    typeof useLegacyMatchFilters === "boolean" ? useLegacyMatchFilters : false,
  );

  return (
    <PageHeader
      crumbs={[
        {
          name: "Expected Payments",
          path: "/expected_payments",
        },
      ]}
      title="Bulk Imports"
    >
      <BulkImportHeader
        bulkImportType="Expected Payment"
        validate={validate}
        submit={submit}
        expectedFields={expectedPaymentBlueprint.sheets?.[0].fields || []}
        blueprint={expectedPaymentBlueprint}
        resource={BulkResourceType.ExpectedPayments}
      />
      <InternalAccountIdsList />
    </PageHeader>
  );
}

export default ExpectedPaymentBulkImport;
```

---
## `ExportDataButton.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { FetchResult } from "@apollo/client";
import { omit } from "lodash";
import { cn } from "~/common/utilities/cn";
import { parseQuery } from "~/common/utilities/queryString";
import {
  ExportDataToFileMutation,
  ExportFileEnum,
  ExportObjectEnum,
  useExportDataToFileMutation,
} from "~/generated/dashboard/graphqlSchema";
import {
  ActionItem,
  Button,
  Icon,
  Popover,
  PopoverTrigger,
  PopoverPanel,
  ButtonProps,
} from "../../common/ui-components";
import { QUERY_KEYS_TO_OMIT } from "../constants";
import { useDispatchContext } from "../MessageProvider";
import useQueryParams from "./filter/useQueryParams";

const HISTORICAL_EXPORT_TYPES: Record<string, string> = {};
HISTORICAL_EXPORT_TYPES[ExportObjectEnum.AuditRecord] = "Audit Record";
HISTORICAL_EXPORT_TYPES[ExportObjectEnum.RequestLog] = "Request Log";

export type ExportFileType = "csv";
export type ExportButtonType = "normal" | "subtle";

interface ExportCSVButtonProps {
  buttonHeight?: ButtonProps["buttonHeight"];
  buttonType?: ExportButtonType;
  disabled?: boolean;
  label?: string;
  onClick?: () => void;
}

export function ExportCSVButton({
  buttonHeight,
  buttonType,
  disabled,
  label,
  onClick,
}: ExportCSVButtonProps) {
  return (
    <Button
      onClick={onClick}
      disabled={disabled}
      buttonHeight={buttonHeight}
      className={
        buttonHeight === "extra-small" ? "pb-0.5 pl-3 pt-0.5" : undefined
      }
    >
      <Icon
        iconName="download_to"
        className="text-gray-700"
        size={
          buttonType === "subtle" || buttonHeight === "extra-small" ? "s" : "m"
        }
      />
      {buttonType === "subtle" ? "" : label || "Download"}
    </Button>
  );
}

type ExportDataParamsType = {
  params?: Record<string, unknown>;
  dropdownLabel?: string;
  overrideExportableType?: ExportObjectEnum;
};

export type ExportDataParams =
  | Array<ExportDataParamsType>
  | ExportDataParamsType;

export interface ExportDataButtonProps {
  exportableType: ExportObjectEnum;
  exportDataParams?: ExportDataParams;
  buttonType?: ExportButtonType;
  buttonHeight?: ButtonProps["buttonHeight"];
  filterName?: string;
  filtersToLegacyFormat?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  scopedParamName?: string;
  iconOnly?: boolean;
}

function ExportDataButton({
  exportableType,
  exportDataParams,
  buttonType = "normal",
  buttonHeight,
  filterName,
  filtersToLegacyFormat,
  scopedParamName,
  iconOnly,
}: ExportDataButtonProps) {
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  const [disabled, setDisabled] = useState<boolean>(false);

  const [exportDataToFile] = useExportDataToFileMutation();
  const [getFilters] = useQueryParams();

  function initiateExport(
    params?: Record<string, unknown>,
    overrideExportableType?: ExportObjectEnum,
  ) {
    setDisabled(true);

    let sanitizedParams = omit(
      { ...params, ...parseQuery(scopedParamName) },
      QUERY_KEYS_TO_OMIT,
    );
    if (filterName && filtersToLegacyFormat) {
      sanitizedParams = {
        ...sanitizedParams,
        ...filtersToLegacyFormat(getFilters(filterName)),
      };
    }

    const exportExportableType = overrideExportableType || exportableType;

    exportDataToFile({
      variables: {
        input: {
          input: {
            objectType: exportExportableType,
            fileType: ExportFileEnum.Csv, // CSV is currently the only supported
            file type.
            filters: JSON.stringify(sanitizedParams),
          },
        },
      },
    })
      .then(
        (
          result: FetchResult<
            ExportDataToFileMutation,
            Record<string, unknown>,
            Record<string, unknown>
          >,
        ) => {
          if (result.data?.exportDataToFile?.errors?.length === 0) {
            dispatchSuccess(
              "Your CSV export is being processed and will arrive in your email
              shortly.",
            );
            return;
          }

          const errorMessage = result.data?.exportDataToFile?.errors[0];
          dispatchError(errorMessage || "An error occurred.");
        },
      )
      .catch(() => {
        dispatchError("An error occurred.");
      })
      .finally(() => setDisabled(false));
  }

  if (!Array.isArray(exportDataParams)) {
    return (
      <ExportCSVButton
        onClick={() => initiateExport(exportDataParams?.params)}
        disabled={disabled}
        buttonType={buttonType}
        label="Export CSV"
        buttonHeight={buttonHeight}
      />
    );
  }

  return (
    <Popover>
      <PopoverTrigger
        buttonHeight={buttonHeight}
        iconOnly={iconOnly}
        className={cn({
          "rounded-md border border-gray-100 hover:bg-gray-25":
            buttonType === "subtle",
        })}
        disabled={disabled}
      >
        <Icon
          iconName="download_to"
          className="text-gray-700"
          size={buttonHeight === "extra-small" ? "s" : undefined}
        />
        {!iconOnly && "Export CSV"}
      </PopoverTrigger>
      <PopoverPanel anchorOrigin={{ horizontal: "right" }}>
        <>
          {exportDataParams.map(
            ({ params, dropdownLabel, overrideExportableType }) => (
              <ActionItem
                key={exportableType.toString()}
                onClick={() => initiateExport(params, overrideExportableType)}
                disabled={disabled}
              >
                {dropdownLabel || exportableType}
              </ActionItem>
            ),
          )}
        </>
      </PopoverPanel>
    </Popover>
  );
}

export default ExportDataButton;
```

---
## `ExternalAccountForm.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { ClipLoader } from "react-spinners";
import { submit, reduxForm, getFormValues, SubmitHandler } from "redux-form";
import CounterpartyAccountFormSection from "./CounterpartyAccountFormSection";
import { Button, ConfirmModal } from "../../common/ui-components";

interface ExternalAccountFormProps {
  setIsUpdatingBankAccounts: (isUpdating: boolean) => void;
  errorMessage?: string;
  name?: string;
}
interface ReduxProps {
  submitting: boolean;
  handleSubmit: SubmitHandler<
    Record<string, unknown>,
    ExternalAccountFormProps,
    string
  >;
}

function ExternalAccountForm({
  setIsUpdatingBankAccounts,
  handleSubmit,
  submitting,
  errorMessage,
  name,
}: ExternalAccountFormProps & ReduxProps) {
  const dispatch = useDispatch();

  const accounts = useSelector((state) => {
    const values: { accounts?: Record<string, unknown> } =
      getFormValues("counterparty")(state);
    if (values) {
      return values.accounts;
    }
    return {};
  });

  const [showConfirmModal, setShowConfirmModal] = useState<boolean>(false);

  return (
    <form autoComplete="off" onSubmit={handleSubmit}>
      <div className="form-section">
        <CounterpartyAccountFormSection
          counterpartyName={name}
          accounts={accounts}
          formName="counterparty"
          isEdit
        />
      </div>

      <div className="form-group form-group-submit flex flex-row">
        <Button
          id="save-bank-account-details-btn"
          buttonType="primary"
          onClick={(): void => {
            setShowConfirmModal(true);
          }}
          disabled={submitting}
        >
          Save
        </Button>
        <Button
          className="ml-4"
          onClick={() => setIsUpdatingBankAccounts(false)}
          disabled={submitting}
        >
          Cancel
        </Button>

        {submitting ? (
          <ClipLoader
            // Our usage if ClipLoader does not match the current types
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            loaderStyle={{ verticalAlign: "middle", marginLeft: "1rem" }}
          />
        ) : undefined}
        {errorMessage && <span className="error-message">{errorMessage}</span>}
      </div>
      <ConfirmModal
        isOpen={showConfirmModal}
        setIsOpen={setShowConfirmModal}
        title="Confirm Save"
        onConfirm={() => {
          dispatch(submit("counterparty"));
        }}
        confirmText="Save"
        confirmDisabled={submitting}
        cancelDisabled={submitting}
      >
        <div>
          Please confirm that you would like to save any changes to these bank
          accounts. Updates will not be reflected on any active Payment Orders.
          Any changes to approved Bank Accounts may require reapproval subject
          to existing approval rules on External Accounts.
        </div>
      </ConfirmModal>
    </form>
  );
}

export default reduxForm<Record<string, unknown>, ExternalAccountFormProps>({
  form: "counterparty",
})(ExternalAccountForm);
```

---
## `FileTransferBatchTotalsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  useFileTransferBatchTotalsQuery,
  BatchTypeEnum,
  BatchSubtotal,
} from "../../generated/dashboard/graphqlSchema";
import {
  IndexTable,
  IndexTableSkeletonLoader,
} from "../../common/ui-components";

const MAPPING = {
  currency: "Currency",
  direction: "Direction",
  amount: "Amount",
  count: "Count",
};

interface FileTransferBatchTotalsViewProps {
  batchId: string;
  batchType: BatchTypeEnum;
}

function formatBatchTotals(batchTotals: BatchSubtotal[]) {
  return batchTotals.map((batchSubtotal: BatchSubtotal) => ({
    ...batchSubtotal,
    count: <> {batchSubtotal.count} </>,
  }));
}

function FileTransferBatchTotalsView({
  batchId,
  batchType,
}: FileTransferBatchTotalsViewProps) {
  const { loading, data, error } = useFileTransferBatchTotalsQuery({
    skip: !batchId || !batchType,
    variables: { batchId, batchType },
  });

  const batchTotals =
    loading || !data || error ? [] : data?.fileTransferCalculateBatchTotals;

  return loading || !data ? (
    <div className="mt-4">
      <IndexTableSkeletonLoader headers={Object.keys(MAPPING)} numRows={4} />
    </div>
  ) : (
    <IndexTable data={formatBatchTotals(batchTotals)} dataMapping={MAPPING} />
  );
}

export default FileTransferBatchTotalsView;
```

---
## `FileTransferDetailsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  FileTransferDetailsViewQuery,
  useFileTransferDetailsViewQuery,
} from "../../generated/dashboard/graphqlSchema";
import {
  CopyableText,
  DateTime,
  Icon,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../common/ui-components";

const MAPPING = {
  id: "ID",
  fileName: "File Name",
  filePath: "Full Path",
  direction: "Direction",
  transferredAt: "Transferred At",
  fileCreatedAt: "Created At",
  processed: "Uploaded Successfully",
  batchType: "Batch Type",
  vendorName: "Vendor",
};

interface FileTransferDetailsViewProps {
  fileTransferId: string;
}

function formatFileTransfer(
  fileTransferData: FileTransferDetailsViewQuery["fileTransfer"],
): Record<string, unknown> {
  return {
    ...fileTransferData,
    fileCreatedAt: fileTransferData.fileCreatedAt ? (
      <DateTime timestamp={fileTransferData.fileCreatedAt} />
    ) : null,
    transferredAt: fileTransferData.transferredAt ? (
      <DateTime timestamp={fileTransferData.transferredAt} />
    ) : null,
    processed: fileTransferData.processed ? (
      <Icon
        iconName="checkmark_circle"
        color="currentColor"
        className="text-green-500"
      />
    ) : (
      <Icon
        iconName="remove_circle"
        color="currentColor"
        className="text-yellow-300"
      />
    ),
    // do the copyable text ourselves, otherwise KeyValueTable will render as a
    link
    fileName: (
      <CopyableText text={fileTransferData.fileName}>
        {fileTransferData.fileName}
      </CopyableText>
    ),
  };
}

function FileTransferDetailsView({
  fileTransferId,
}: FileTransferDetailsViewProps) {
  const { loading, data, error } = useFileTransferDetailsViewQuery({
    variables: { fileTransferId },
  });
  const fileTransfer = data?.fileTransfer;
  if (error) {
    return null;
  }
  return loading || !fileTransfer ? (
    <div className="mt-4">
      <KeyValueTableSkeletonLoader dataMapping={MAPPING} />
    </div>
  ) : (
    <KeyValueTable
      key={fileTransferId}
      data={formatFileTransfer(fileTransfer)}
      dataMapping={MAPPING}
      copyableData={["id", "filePath"]}
    />
  );
}

export default FileTransferDetailsView;
```

---
## `FileTransferLink.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button, ButtonClickEventTypes } from "../../common/ui-components";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";

export interface FileTransferLinkProps {
  organizationId: string;
  endpointId: string;
}

function FileTransferLink({
  organizationId,
  endpointId,
}: FileTransferLinkProps) {
  return (
    <Button
      buttonType="primary"
      onClick={(e: ButtonClickEventTypes) => {
        e.stopPropagation();
        handleLinkClick(
          `/admin/organizations/${organizationId}/file_transfers?endpointId=${en
          dpointId}`,
          e,
        );
      }}
      key={endpointId}
    >
      View Files
    </Button>
  );
}

export default FileTransferLink;
```

---
## `FlatfileBulkUploadButton.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { camelCase, startCase } from "lodash";
import { useSpace } from "@flatfile/react";
import {
  Property as FlatfileProperty,
  RecordsWithLinks,
  CreateWorkbookConfig,
  CellValueUnion,
} from "@flatfile/api/api";
import { FlatfileListener } from "@flatfile/listener";
import { RecordRejections } from "@flatfile/util-response-rejection";
import * as Sentry from "@sentry/browser";
import colors from "../../common/styles/colors";
import {
  BulkValidationError,
  ValidationError,
} from "../../generated/dashboard/graphqlSchema";
import { ActionItem, Button } from "../../common/ui-components";
import getFlatfileListener from "./bulk_imports/listener";
import Gon from "../../common/utilities/gon";

export enum BulkResourceType {
  ExpectedPayments = "expected_payments",
  PaymentOrders = "payment_orders",
  Counterparties = "counterparties",
  InternalAccounts = "internal_accounts",
  AccountCapabilities = "account_capabilities",
  AccountACHSettings = "account_ach_settings",
  Invoices = "invoices",
}
const UNEXPECTED_ERROR =
  "Sorry, an unexpected error occurred. Please contact us at
  support@moderntreasury.com if this error persists.";

const resourceButtonName = (resourceType: BulkResourceType) => {
  let resourceName: string;

  switch (resourceType) {
    case BulkResourceType.AccountACHSettings:
      resourceName = "Account ACH Settings";
      break;
    default:
      resourceName = startCase(resourceType.replace("_", " "));
  }
  return `Import ${resourceName}`;
};

const ReusableFlatfileSpace = ({
  setShowSpace,
  spaceId,
  accessToken,
}: {
  setShowSpace: (showSpace: boolean) => void;
  spaceId: string;
  accessToken: string;
}) => {
  const {
    flatfile: { environmentId },
  }: { flatfile: { environmentId: string; publishableKey: string } } = Gon.gon;

  const space = useSpace({
    space: { id: spaceId, accessToken },
    environmentId,
    closeSpace: {
      operation: "submitActionFg",
      onClose: () => setShowSpace(false),
    },
  });
  return space;
};

const FlatfileSpace = ({
  setShowSpace,
  flatfileListener,
  blueprint,
}: {
  setShowSpace: (showSpace: boolean) => void;
  flatfileListener: FlatfileListener;
  blueprint:
    | Pick<CreateWorkbookConfig, "name" | "sheets" | "actions">
    | undefined;
}) => {
  const {
    flatfile: { environmentId, publishableKey },
  }: { flatfile: { environmentId: string; publishableKey: string } } = Gon.gon;

  const space = useSpace({
    name: "Bulk Import",
    publishableKey,
    environmentId,
    themeConfig: {
      root: {
        buttonBorderRadius: "4px",
        actionColor: colors.green["500"],
        dangerColor: colors.red["500"],
        primaryColor: colors.green["500"],
      },
    },
    workbook: blueprint,
    listener: flatfileListener,
    closeSpace: {
      operation: "submitActionFg",
      onClose: () => setShowSpace(false),
    },
  });
  return space;
};

export interface FlatfileBulkUploadButtonProps {
  onSubmit?: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => Promise<Record<string, string | boolean>>;
  onValidate?: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => Promise<Array<BulkValidationError> | undefined | null>;
  expectedFields: FlatfileProperty[];
  blueprint?:
    | Pick<CreateWorkbookConfig, "name" | "sheets" | "actions">
    | undefined;
  resource: BulkResourceType;
  spaceId?: string;
  accessToken?: string;
  launchFromActionsList?: boolean;
}

function FlatfileBulkUploadButton({
  onSubmit,
  onValidate,
  expectedFields,
  blueprint,
  spaceId,
  accessToken,
  resource,
  launchFromActionsList,
}: FlatfileBulkUploadButtonProps): JSX.Element {
  const fieldKeySet = new Set<string>(expectedFields.map((field) => field.key));

  // Returns an array of validation errors to set the entire file to be red.
  const unexpectedErrors = (numRows: number) =>
    Array(numRows)
      .fill(0)
      .map((_, index) => {
        const validationError: BulkValidationError = {
          errors: [],
          recordIndex: index,
        };
        const entireRecordError: Array<ValidationError> = [];
        expectedFields
          .map((field) => field.key)
          .forEach((key: string) => {
            entireRecordError.push({
              fieldName: key,
              messages: [UNEXPECTED_ERROR],
            });
          });
        validationError.errors = entireRecordError;
        return validationError;
      });

  const queryValidation = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    if (onValidate !== undefined) {
      try {
        return await onValidate(resultsData);
      } catch (error) {
        Sentry.captureException(error);
        return unexpectedErrors(resultsData.length);
      }
    } else {
      return unexpectedErrors(1);
    }
  };

  /**
   * Queries for validations against the parsed file results. If there are any
   errors,
   * it formats our BulkValidationErrors into an Array of
   ResponseRejectionRecords
   * for each record that has an error.
   *
   * @param resultsData
   * @param sheetRecords
   * @returns list of records with validation errors
   */
  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    sheetRecords: RecordsWithLinks,
  ): Promise<RecordRejections[]> => {
    const validations = await queryValidation(resultsData);

    if (validations) {
      const expectedFieldKeys = expectedFields.map((field) => field.key);
      const inputtedFieldKeys = Object.keys(resultsData[0]);
      const flatfileRejectedRecords: RecordRejections[] = [];

      // validations = MT mutation validation results
      validations.forEach((val) => {
        // get the record ID from the sheet data to associate with the mutation
        validation results
        // brittle since it finds it by using array index
        const recordId = sheetRecords[val.recordIndex]?.id;
        // Transforms BulkValidationError into Flatfile's ResponseRejection
        interface.
        // https://flatfile.com/docs/plugins/utils/response-
        rejection#responserejection-interface
        const flatfileRecordFieldErrors: {
          field: string;
          message: string;
        }[] = [];
        val.errors.forEach((error) => {
          // Field names are snake_cased from backend.
          const fieldName = camelCase(error.fieldName);
          if (
            expectedFieldKeys.includes(fieldName) &&
            inputtedFieldKeys.includes(fieldName)
          ) {
            flatfileRecordFieldErrors.push({
              field: fieldName,
              message: error.messages.join(", "),
            });
          } else {
            // Highlight all cells in row if field name not found
            expectedFieldKeys.forEach((fieldKey) => {
              if (
                !flatfileRecordFieldErrors.some(
                  (fieldError) => fieldError.field === fieldKey,
                )
              ) {
                flatfileRecordFieldErrors.push({
                  field: fieldKey,
                  message: error.messages.join(", "),
                });
              }
            });
          }
        });
        if (flatfileRecordFieldErrors.length > 0) {
          flatfileRejectedRecords.push({
            id: recordId,
            values: flatfileRecordFieldErrors,
          });
        }
      });
      return flatfileRejectedRecords;
    }
    return [];
  };

  const [showSpace, setShowSpace] = useState<boolean>(false);
  const uploadButtonName = resourceButtonName(resource);
  const onClick = () => setShowSpace(!showSpace);

  return (
    <div>
      {launchFromActionsList ? (
        <ActionItem onClick={onClick}>{uploadButtonName} </ActionItem>
      ) : (
        <Button buttonType="primary" onClick={onClick}>
          {uploadButtonName}
        </Button>
      )}
      {showSpace &&
        (spaceId ? (
          <ReusableFlatfileSpace
            setShowSpace={setShowSpace}
            spaceId={spaceId}
            accessToken={accessToken || ""}
          />
        ) : (
          onSubmit !== undefined && (
            <FlatfileSpace
              setShowSpace={setShowSpace}
              flatfileListener={getFlatfileListener(
                resource,
                fieldKeySet,
                validate,
                onSubmit,
              )}
              blueprint={blueprint}
            />
          )
        ))}
    </div>
  );
}

export default FlatfileBulkUploadButton;
```

---
## `FromTransactionReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Label,
  SelectField,
  Autosuggest,
  Icon,
  Clickable,
} from "../../common/ui-components";

interface FromTransactionReconciliationMatchResultProps {
  selectField: string | null | undefined;
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  suggestedMatcher: string | null | undefined;
  matcher: string | null;
  transactionField: string | null | undefined;
  transactionFieldString: string | null | undefined;
  parser: string | null | undefined;
  showParser: boolean;
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

function FromTransactionReconciliationMatchResult({
  selectField,
  selectFieldOptions,
  matcher,
  parser,
  showParser,
  transactionField,
  transactionFieldString,
  suggestedMatcher,
  callback,
}: FromTransactionReconciliationMatchResultProps) {
  const transactionFieldOptions = [
    {
      label: "vendor_description",
      value: "vendor_description",
    },
    {
      label: "vendor_id",
      value: "vendor_id",
    },
    {
      label: "unique_vendor_id",
      value: "unique_vendor_id",
    },
    {
      label: "vendor_customer_id",
      value: "vendor_customer_id",
    },
  ];

  return (
    <div className="flex w-full flex-col">
      {selectField === "From Transaction" ? (
        <div className="max-w-40">
          <SelectField
            className="justify-right flex"
            handleChange={(e) => {
              callback(
                e as string,
                matcher,
                parser,
                showParser,
                null,
                null,
                null,
              );
            }}
            id="select-id2"
            name="select-name2"
            selectValue={selectField}
            options={selectFieldOptions}
          />
        </div>
      ) : null}

      <div className="flex w-full flex-col">
        <div className="flex w-full justify-center">
          <Label className="flex self-center pb-4 pr-1">
            Transaction Field
          </Label>
          <div className="min-w-48">
            <SelectField
              className="justify-right flex"
              handleChange={(e) => {
                callback(
                  selectField,
                  e as string,
                  parser,
                  showParser,
                  null,
                  null,
                  null,
                );
              }}
              id="select-id2"
              name="select-name2"
              selectValue={matcher}
              options={transactionFieldOptions}
            />
          </div>
        </div>
        <div className="flex justify-center">
          <Label className="flex pb-2 text-xs text-gray-500">
            {transactionFieldString}
          </Label>
        </div>
      </div>

      <div className="flex w-full">
        {showParser ? (
          <div className="flex w-full flex-col">
            <div className="flex w-full">
              <Label className="justify-left flex self-center pr-1">
                Parser:
              </Label>
              <Label className="self-center px-1">/</Label>
              <Autosuggest
                className="justify-right w-full"
                onChange={(e) => {
                  callback(
                    selectField,
                    matcher,
                    e.target.value,
                    showParser,
                    transactionField,
                    null,
                    null,
                  );
                }}
                onSuggestionSelect={(e, suggestion) => {
                  callback(
                    selectField,
                    matcher,
                    suggestion.suggestionValue,
                    showParser,
                    transactionField,
                    null,
                    null,
                  );
                }}
                value={parser || ""}
                suggestions={
                  suggestedMatcher
                    ? [
                        {
                          label: `Suggested: ${suggestedMatcher}`,
                          value: suggestedMatcher,
                        },
                      ]
                    : [
                        {
                          label: "No Suggestion",
                          value: "(.*)",
                        },
                      ]
                }
                placeholder="Enter a value"
              />
              <Label className="self-center px-1">/</Label>
            </div>

            <div className="flex w-full">
              <Clickable
                onClick={() => {
                  callback(
                    selectField,
                    matcher,
                    null,
                    false,
                    transactionField,
                    null,
                    null,
                  );
                }}
              >
                <div className="mr-auto flex flex-row pb-6 pt-2">
                  <Icon
                    className="self-center text-red-500"
                    iconName="remove"
                    size="xs"
                    color="currentColor"
                  />
                  <Label className="flex self-center pl-1 text-xs text-red-500">
                    Remove Parser
                  </Label>
                </div>
              </Clickable>
            </div>
          </div>
        ) : (
          <div className="flex w-full">
            <Clickable
              onClick={() => {
                callback(
                  selectField,
                  matcher,
                  parser,
                  true,
                  transactionField,
                  null,
                  null,
                );
              }}
            >
              <div className="mr-auto flex flex-row pb-2 pt-1">
                <Icon
                  className="self-center text-blue-500"
                  iconName="add"
                  size="xs"
                  color="currentColor"
                />
                <Label className="flex self-center pl-1 text-xs text-blue-500">
                  Add Parser
                </Label>
              </div>
            </Clickable>
          </div>
        )}
      </div>
    </div>
  );
}
export default FromTransactionReconciliationMatchResult;
```

---
## `GhostAsOrganizationButton.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button } from "../../common/ui-components";
import { useUpdateGhostMutation } from
"../../generated/dashboard/graphqlSchema";
import useErrorBanner from "../../common/utilities/useErrorBanner";

const GHOSTING_ERROR =
  "Sorry but ghosting failed. Ensure you have Engineering On-Call (AWS) access
  and try logging in again.";

export enum GhostRedirectUrl {
  Home = "/",
  OperationsHub = "/operations",
}

interface GhostAsOrganizationButtonProps {
  organizationId: string;
  buttonText: string;
  redirectUrl?: GhostRedirectUrl;
  tooltipText?: string;
}

function GhostAsOrganizationButton({
  organizationId,
  buttonText,
  redirectUrl = GhostRedirectUrl.Home,
  tooltipText,
}: GhostAsOrganizationButtonProps) {
  const flashError = useErrorBanner();
  const [updateGhost] = useUpdateGhostMutation();

  const ghostAsOrganization = () => {
    updateGhost({
      variables: {
        input: {
          id: organizationId,
          ghosting: true,
        },
      },
    })
      .then((response) => {
        const { errors = [] } = response.data?.updateGhost || {};
        if (errors.length) {
          flashError(errors.toString());
        } else {
          window.location.href = redirectUrl;
        }
      })
      .catch(() => flashError(GHOSTING_ERROR));
  };

  return (
    <Button
      buttonType="primary"
      title={tooltipText}
      onClick={(e) => {
        e.stopPropagation();
        ghostAsOrganization();
      }}
    >
      {buttonText}
    </Button>
  );
}

export default GhostAsOrganizationButton;
```

---
## `GroupByReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Label, SelectField } from "~/common/ui-components";
import EntityTableView from "./EntityTableView";

type SelectFieldActionNameType =
  | "select-option"
  | "remove-value"
  | "pop-value"
  | "clear";

const STYLE_MAPPING = {
  entityId: "table-entry-wide table-entry-hide-small",
};

interface GroupByReconciliationMatchResultProps {
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  matcher: string | null;
  groupBy: string[] | null | undefined;
  groupByGroups: string[][] | null | undefined;
  suggestedMatcher: string | null | undefined;
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

function GroupByReconciliationMatchResult({
  selectFieldOptions,
  matcher,
  groupBy,
  groupByGroups,
  suggestedMatcher,
  callback,
}: GroupByReconciliationMatchResultProps) {
  const groupByParams =
    matcher
      ?.slice(1, -1)
      ?.split(", ")
      ?.map((param) => param.slice(1)) || [];

  const columns = groupBy?.concat(["count"]);
  const columnNames = Object.fromEntries(columns?.map((c) => [c, c]) || []);
  const dataMap = groupByGroups?.map((gb) =>
    Object.fromEntries(gb?.map((g, i) => [columns?.[i] || "", g]) || []),
  );
  const suggestion = suggestedMatcher
    ?.slice(1, -1)
    ?.split(", ")
    .map((s) => s.slice(1, -1));
  const columnsToRemove = columns?.filter(
    (c) => c !== "count" && !suggestion?.includes(c),
  );

  function handleMultiSelectChange(
    value: string,
    field: { label: string; value: string },
    actionName: SelectFieldActionNameType,
  ) {
    switch (actionName) {
      case "select-option":
        callback(
          "Group By",
          groupByParams && groupByParams[0] !== ""
            ? `[:${groupByParams.concat(field.value).join(", :")}]`
            : `[:${field.value}]`,
          null,
          null,
          null,
          null,
          null,
        );
        break;
      case "clear":
        callback("Group By", "[]", null, null, null, null, null);
        break;
      case "remove-value":
        callback(
          "Group By",
          groupByParams.length > 1
            ? `[:${groupByParams
                .filter((val) => val !== field.value)
                .join(", :")}]`
            : "[]",
          null,
          null,
          null,
          null,
          null,
        );
        break;
      default:
    }
  }

  return (
    <div className="mb-2 flex w-full flex-col">
      <SelectField
        isMulti
        isClearable={false}
        options={selectFieldOptions}
        selectValue={groupByParams}
        handleChange={handleMultiSelectChange}
      />
      {groupBy &&
        groupBy.length > 1 &&
        columnsToRemove &&
        columnsToRemove.length > 0 && (
          <Label className="mb-2 text-sm italic text-gray-500">
            Suggested: Remove {columnsToRemove.join(", ")}
          </Label>
        )}

      {columns && dataMap && (
        <EntityTableView
          data={dataMap}
          loading={!columns && !dataMap}
          dataMapping={columnNames}
          styleMapping={STYLE_MAPPING}
          onQueryArgChange={async () =>
            new Promise<void>((resolve) => {
              resolve();
            })
          }
        />
      )}

      {(!groupBy || groupBy.length === 0) && (
        <Label className="ml-auto mr-auto flex text-center text-sm italic text-
        gray-500">
          At least one grouping attribute must be selected. Select from the
          dropdown.
        </Label>
      )}
      {dataMap && dataMap.length > 1 && (
        <Label className="ml-auto mr-auto mt-2 flex text-center text-sm italic
        text-red-500">
          Your grouping criteria splits the selected payments into multiple
          groups. Try grouping on different columns.
        </Label>
      )}
    </div>
  );
}

export default GroupByReconciliationMatchResult;
```

---
## `IPAllowlistForm.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { Button, Icon } from "../../common/ui-components";

export function IPAllowlistForm({
  enabled,
  ipAllowlist,
  setIpAllowlist,
}: {
  enabled: boolean;
  ipAllowlist: string[];
  setIpAllowlist: (data: string[]) => void;
}) {
  function onIPAllowlistChange(
    e: React.ChangeEvent<HTMLInputElement>,
    index: number,
  ) {
    const {
      target: { value },
    } = e;

    const newData = [...ipAllowlist];
    newData.splice(index, 1, value);

    setIpAllowlist(newData);
  }

  return (
    <div className="form-subsection bg-gray-50">
      <h3>
        <span>Allowed IPs</span>
        <div className="header-hint">
          Note that if you set this, only requests from this IP will be accepted
        </div>
      </h3>
      {ipAllowlist.map((value, index) => (
        <div
          className="subsection-row subsection-row-with-action"
          key={`$ipAllowlist-${index.toString()}`}
        >
          <ReduxInputField
            input={{
              name: `$ipAllowlist[${index}]`,
              onChange: (e) => onIPAllowlistChange(e, index),
              value,
            }}
            disabled={!enabled}
          />
          {enabled && (
            <Button
              onClick={() => {
                if (ipAllowlist.length === 1) {
                  setIpAllowlist([]);
                } else {
                  const newData = [...ipAllowlist];
                  newData.splice(index, 1);
                  setIpAllowlist([...newData]);
                }
              }}
            >
              <Icon
                iconName="clear"
                size="xs"
                color="currentColor"
                className="text-gray-300"
              />
            </Button>
          )}
        </div>
      ))}
      {enabled && (
        <Button
          id="add-ip-btn"
          onClick={() => setIpAllowlist([...ipAllowlist, ""])}
        >
          <Icon iconName="add" />
          <span>Add</span>
        </Button>
      )}
    </div>
  );
}
```

---
## `InfoBadge.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { HiddenEasterEgg } from "react-hidden-easter-egg";
import { useInfoBadgeQuery } from "../../generated/dashboard/graphqlSchema";

function InfoBadgeComponent(version: string, cell: string) {
  const badgeColor = parseInt(version, 10) % 2 === 0 ? "green" : "purple";
  return (
    <div className="fixed bottom-8 right-20 z-40">
      <div id="demoVersionBadge">
        <span
          className="flex items-center rounded-sm p-2 pb-1 pt-1 text-xs font-
          bold text-white"
          style={{ backgroundColor: badgeColor }}
        >
          {`Version: ${version} | Cell: ${cell}`}
        </span>
      </div>
    </div>
  );
}

function InfoBadge() {
  const { data } = useInfoBadgeQuery();

  const version = data?.appInfo?.version;
  const stackName = data?.appInfo?.stackName;
  const cell = data?.appInfo?.currentCell || "unknown";
  const mtUser =
    data?.currentUser?.email &&
    data.currentUser.email.includes("@moderntreasury.com");

  if (mtUser && version) {
    if (stackName === "production") {
      const badge = InfoBadgeComponent(version, cell);
      return (
        <HiddenEasterEgg
          resetEggMs={10000}
          code={["ArrowUp", "ArrowUp", "m", "t"]}
        >
          {badge}
        </HiddenEasterEgg>
      );
    }
    if (stackName === "demo") {
      return InfoBadgeComponent(version, cell);
    }
  }
  return null;
}

export default InfoBadge;
```

---
## `InternalAccountBulkUploadActionItem.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateInternalAccountsMutation,
  useBulkValidateInternalAccountsMutation,
} from "~/generated/dashboard/graphqlSchema";
import FlatfileBulkUploadButton, {
  BulkResourceType,
} from "~/app/components/FlatfileBulkUploadButton";
import {
  internalAccountBlueprint,
  internalAccountBlueprintFields,
} from "./bulk_imports/blueprints/internalAccountBlueprint";

export const INTERNAL_ACCOUNT_CSV_HEADERS = internalAccountBlueprintFields.map(
  (field) => field.key,
);

interface InternalAccountBulkUploadActionItemProps {
  connectionId: string;
}

function InternalAccountBulkUploadActionItem({
  connectionId,
}: InternalAccountBulkUploadActionItemProps) {
  const [bulkValidateInternalAccounts] =
    useBulkValidateInternalAccountsMutation();
  const [bulkCreateInternalAccounts] = useBulkCreateInternalAccountsMutation();

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateInternalAccounts({
      variables: {
        input: {
          connectionId,
          internalAccounts: resultsData,
        },
      },
    });
    return response.data?.bulkValidateInternalAccounts?.recordErrors;
  };

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateInternalAccounts({
      variables: {
        input: {
          connectionId,
          flatfileSheetId,
          flatfileSpaceId,
          internalAccounts: resultsData,
        },
      },
    });

    const { id } = data?.bulkCreateInternalAccounts?.connectionBulkImport ?? {};
    if (id) {
      return {
        success: true,
        path: `/operations/connection_bulk_imports/${id}`,
      };
    }
    return { success: false, path: "/" };
  };

  return (
    <div>
      <FlatfileBulkUploadButton
        resource={BulkResourceType.InternalAccounts}
        blueprint={internalAccountBlueprint}
        expectedFields={internalAccountBlueprintFields}
        onValidate={validate}
        onSubmit={submit}
        launchFromActionsList
      />
    </div>
  );
}

export default InternalAccountBulkUploadActionItem;
```

---
## `InternalAccountIdsList.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ReactTooltip from "react-tooltip";
import { useInternalAccountsQuery } from
"../../generated/dashboard/graphqlSchema";
import { Label, Tooltip } from "../../common/ui-components";
import Stack from "../../common/ui-components/Stack/Stack";

function InternalAccountIdsList() {
  const tooltipMessage =
    "This is for your reference to find the IDs of your Internal Accounts.";
  const tooltip = (
    <>
      <Tooltip className="tooltip-holder" data-tip={tooltipMessage} />
      <ReactTooltip
        multiline
        data-place="top"
        data-type="dark"
        data-effect="float"
      />
    </>
  );

  const { data } = useInternalAccountsQuery({
    notifyOnNetworkStatusChange: true,
  });

  const internalAccounts = data?.internalAccountsUnpaginated || [];

  return (
    <Stack className="gap-4">
      <h3>
        <span className="text-base font-medium">Internal Account IDs</span>
        {tooltipMessage && tooltip}
      </h3>
      {internalAccounts.map((internalAccount) => (
        <Stack key={internalAccount.id} className="gap-8">
          <Stack className="gap-2">
            <Label className="font-medium">{internalAccount.longName}</Label>
            <span className="text-xs text-gray-600">{internalAccount.id}</span>
          </Stack>
        </Stack>
      ))}
    </Stack>
  );
}

export default InternalAccountIdsList;
```

---
## `InternalTool.tsx.txt`
**Path:** `.`  
```
import React, { ReactNode } from "react";
import { Button, Drawer } from "../../common/ui-components";
import DrawerState from "../../common/ui-components/Drawer/DrawerState";
import { useInternalToolsVisibilityQuery } from
"../../generated/dashboard/graphqlSchema";

function InternalTool({ children }: { children?: ReactNode }) {
  const showTools =
    useInternalToolsVisibilityQuery().data?.internalToolsVisibility;

  if (showTools) {
    const internalToolsButton = (
      <Button className="w-21 fixed bottom-[27px] right-[72px] z-40 h-10
      rounded-full border border-gray-200 bg-white shadow">
        Internal Tools
      </Button>
    );
    if (DrawerState.isDrawerOpen) {
      DrawerState.hideDrawer();
    }
    return <Drawer trigger={internalToolsButton}>{children}</Drawer>;
  }
  return null;
}

export default InternalTool;
```

---
## `InviteCounterpartyModal.tsx.txt`
**Path:** `.`  
```
import React, { useEffect, useMemo, useState } from "react";
import { ClipLoader } from "react-spinners";
import ReactTooltip from "react-tooltip";
import { INVITATION_FIELDS } from "../../common/constants";
import ReduxCheckbox from "../../common/deprecated_redux/ReduxCheckbox";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import ReduxSelectBar from "../../common/deprecated_redux/ReduxSelectBar";
import {
  Alert,
  FieldGroup,
  Label,
  ConfirmModal,
  SelectField,
  Tooltip,
} from "../../common/ui-components";
import {
  CustomDomain__VerificationStatusEnum,
  useCustomEmailDomainViewQuery,
} from "../../generated/dashboard/graphqlSchema";
import { MT_MAIL_DOMAIN_ID } from
"../containers/custom_domain/CustomEmailDomainActionItem";
import { DispatchMessageFnType, useDispatchContext } from "../MessageProvider";

interface InviteCounterpartyModalProps {
  onInvite: (
    counterpartyId: string,
    invitationForm: Record<string, unknown>,
    dispatchSuccess: DispatchMessageFnType["dispatchSuccess"],
    dispatchError: DispatchMessageFnType["dispatchError"],
  ) => Promise<boolean>;
  counterpartyId: string;
  isOpen: boolean;
  setIsOpen: (value: boolean) => void;
  canManageCustomEmailDomains: boolean;
}

function InviteCounterpartyModal({
  onInvite,
  counterpartyId,
  isOpen,
  setIsOpen,
  canManageCustomEmailDomains,
}: InviteCounterpartyModalProps) {
  const [submitting, setSubmitting] = useState(false);
  const [stateErrorMessage, setStateErrorMessage] = useState<string>();
  const { dispatchError, dispatchSuccess } = useDispatchContext();
  const [invitationForm, setInvitationForm] = useState({
    fields: {
      [INVITATION_FIELDS.nameOnAccount]: true,
      [INVITATION_FIELDS.accountType]: true,
      [INVITATION_FIELDS.accountNumber]: true,
      [INVITATION_FIELDS.routingNumber]: true,
      [INVITATION_FIELDS.address]: true,
    },
    direction: "credit",
    customRedirect: "",
    send_from_domain_id: "",
  });

  const { data, loading, error: cedError } = useCustomEmailDomainViewQuery();

  const defaultSendingDomainNode =
    loading || cedError || !data
      ? null
      : data?.customEmailDomains?.edges.find((edge) => edge.node.default)?.node;

  useEffect(() => {
    setInvitationForm({
      ...invitationForm,
      send_from_domain_id: defaultSendingDomainNode?.id ?? MT_MAIL_DOMAIN_ID,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [defaultSendingDomainNode]);

  const verifiedCustomEmailDomainsOptions = useMemo(
    () =>
      loading || cedError || !data
        ? []
        : data.customEmailDomains?.edges
            .filter(
              (edge) =>
                edge.node.verificationStatus ===
                CustomDomain__VerificationStatusEnum.Verified,
            )
            .map(({ node }) => ({
              value: node.id,
              label: node.domain,
            })),
    [loading, cedError, data],
  );

  const {
    fields: {
      name,
      nameOnAccount,
      accountType,
      accountNumber,
      ibanNumber,
      clabeNumber,
      walletAddress,
      panNumber,
      routingNumber,
      abaWireRoutingNumber,
      swiftCode,
      auBsb,
      caCpa,
      cnaps,
      dkInterbankClearingCode,
      gbSortCode,
      hkInterbankClearingCode,
      huInterbankClearingCode,
      idSknbiCode,
      inIfsc,
      jpZenginCode,
      seBankgiroClearingCode,
      brCodigo,
      myBranchCode,
      nzNationalClearingCode,
      address,
      taxpayerIdentifier,
    },
    direction,
    customRedirect,
  } = invitationForm;

  function handleInvite() {
    setSubmitting(true);
    onInvite(counterpartyId, invitationForm, dispatchSuccess, dispatchError)
      .then(() => setIsOpen(false))
      .catch((error: Error) => {
        try {
          const {
            errors: { message },
          } = JSON.parse(error.message) as { errors: { message: string } };
          setStateErrorMessage(message);
        } catch (e) {
          setStateErrorMessage("An error occurred");
        }
      })
      .finally(() => setSubmitting(false));
  }

  return (
    <ConfirmModal
      title="Send Invitation"
      isOpen={isOpen}
      setIsOpen={() => setIsOpen(false)}
      confirmText="Invite"
      onConfirm={handleInvite}
      confirmDisabled={submitting}
      bodyClassName="max-h-[75vh] overflow-y-auto"
    >
      {stateErrorMessage && (
        <div className="pb-4">
          <Alert onClear={() => setStateErrorMessage("")} alertType="danger">
            {stateErrorMessage}
          </Alert>
        </div>
      )}

      <form className="form-create">
        <div>
          <div className="form-row form-row-full flex">
            <FieldGroup>
              <Label id="pay_charge_counterparty">
                Do you plan to pay or charge the counterparty?
              </Label>
              <ReduxSelectBar
                name="pay_charge_counterparty"
                required
                selectOptions={[
                  { text: "Pay", value: "credit" },
                  { text: "Charge", value: "debit" },
                ]}
                input={{
                  onChange: (val) =>
                    setInvitationForm({
                      ...invitationForm,
                      direction: val as string,
                    }),
                  value: direction,
                }}
              />
            </FieldGroup>
          </div>

          <div className="form-row form-row-full flex">
            <div className="form-group">
              <Label>What information do you need to collect?</Label>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="name"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: { ...invitationForm.fields, name: !name },
                        }),
                      checked: !!name,
                    }}
                  />
                  <Label id="name">Counterparty Name</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="nameOnAccount"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            nameOnAccount: !nameOnAccount,
                          },
                        }),
                      checked: !!nameOnAccount,
                    }}
                  />
                  <Label id="nameOnAccount">Name on Account</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="accountType"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            accountType: !accountType,
                          },
                        }),
                      checked: !!accountType,
                    }}
                  />
                  <Label id="accountType">Account Type</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="accountNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            accountNumber: !accountNumber,
                          },
                        }),
                      checked: !!accountNumber,
                    }}
                  />
                  <Label id="accountNumber">Account Number</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="ibanNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            ibanNumber: !ibanNumber,
                          },
                        }),
                      checked: !!ibanNumber,
                    }}
                  />
                  <Label id="ibanNumber">IBAN Number</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="clabeNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            clabeNumber: !clabeNumber,
                          },
                        }),
                      checked: !!clabeNumber,
                    }}
                  />
                  <Label id="clabeNumber">CLABE Number</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="walletAddress"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            walletAddress: !walletAddress,
                          },
                        }),
                      checked: !!walletAddress,
                    }}
                  />
                  <Label id="walletAddress">Wallet Address</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="panNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            panNumber: !panNumber,
                          },
                        }),
                      checked: !!panNumber,
                    }}
                  />
                  <Label id="panNumber">PAN</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="routingNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            routingNumber: !routingNumber,
                          },
                        }),
                      checked: !!routingNumber,
                    }}
                  />
                  <Label id="routingNumber">ABA Routing Number</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="abaWireRoutingNumber"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            abaWireRoutingNumber: !abaWireRoutingNumber,
                          },
                        }),
                      checked: !!abaWireRoutingNumber,
                    }}
                  />
                  <Label id="abaWireRoutingNumber">
                    ABA Wire Routing Number
                  </Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="swiftCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            swiftCode: !swiftCode,
                          },
                        }),
                      checked: !!swiftCode,
                    }}
                  />
                  <Label id="swiftCode">SWIFT Code</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="auBsb"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: { ...invitationForm.fields, auBsb: !auBsb },
                        }),
                      checked: !!auBsb,
                    }}
                  />
                  <Label id="auBsb">Australian BSB</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="caCpa"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: { ...invitationForm.fields, caCpa: !caCpa },
                        }),
                      checked: !!caCpa,
                    }}
                  />
                  <Label id="caCpa">Canadian Routing Number</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="cnaps"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: { ...invitationForm.fields, cnaps: !cnaps },
                        }),
                      checked: !!cnaps,
                    }}
                  />
                  <Label id="cnaps">CNAPS Code</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="gbSortCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            gbSortCode: !gbSortCode,
                          },
                        }),
                      checked: !!gbSortCode,
                    }}
                  />
                  <Label id="gbSortCode">GB Sort Code</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="inIfsc"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: { ...invitationForm.fields, inIfsc: !inIfsc },
                        }),
                      checked: !!inIfsc,
                    }}
                  />
                  <Label id="inIfsc">IFSC Code</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="jpZenginCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            jpZenginCode: !jpZenginCode,
                          },
                        }),
                      checked: !!jpZenginCode,
                    }}
                  />
                  <Label id="jpZenginCode">Zengin Code</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="seBankgiroClearingCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            seBankgiroClearingCode: !seBankgiroClearingCode,
                          },
                        }),
                      checked: !!seBankgiroClearingCode,
                    }}
                  />
                  <Label id="seBankgiroClearingCode">
                    Swedish Clearing Number
                  </Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="brCodigo"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            brCodigo: !brCodigo,
                          },
                        }),
                      checked: !!brCodigo,
                    }}
                  />
                  <Label id="brCodigo">Brazilian Codigo</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="myBranchCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            myBranchCode: !myBranchCode,
                          },
                        }),
                      checked: !!myBranchCode,
                    }}
                  />
                  <Label id="myBranchCode">Malaysian Branch Code</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="nzNationalClearingCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            nzNationalClearingCode: !nzNationalClearingCode,
                          },
                        }),
                      checked: !!nzNationalClearingCode,
                    }}
                  />
                  <Label id="nzNationalClearingCode">New Zealand NCC</Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="hkInterbankClearingCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            hkInterbankClearingCode: !hkInterbankClearingCode,
                          },
                        }),
                      checked: !!hkInterbankClearingCode,
                    }}
                  />
                  <Label id="hkInterbankClearingCode">
                    HK Interbank Clearing Code
                  </Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="dkInterbankClearingCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            dkInterbankClearingCode: !dkInterbankClearingCode,
                          },
                        }),
                      checked: !!dkInterbankClearingCode,
                    }}
                  />
                  <Label id="dkInterbankClearingCode">
                    DK Interbank Clearing Code
                  </Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="huInterbankClearingCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            huInterbankClearingCode: !huInterbankClearingCode,
                          },
                        }),
                      checked: !!huInterbankClearingCode,
                    }}
                  />
                  <Label id="huInterbankClearingCode">
                    HU Interbank Clearing Code
                  </Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="idSknbiCode"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            idSknbiCode: !idSknbiCode,
                          },
                        }),
                      checked: !!idSknbiCode,
                    }}
                  />
                  <Label id="hkInterbankClearingCode">
                    HK Interbank Clearing Code
                  </Label>
                </FieldGroup>
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="address"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            address: !address,
                          },
                        }),
                      checked: !!address,
                    }}
                  />
                  <Label id="address">Address</Label>
                </FieldGroup>
              </div>
              <div className="form-row flex">
                <FieldGroup direction="left-to-right">
                  <ReduxCheckbox
                    id="taxpayerIdentifier"
                    input={{
                      onChange: () =>
                        setInvitationForm({
                          ...invitationForm,
                          fields: {
                            ...invitationForm.fields,
                            taxpayerIdentifier: !taxpayerIdentifier,
                          },
                        }),
                      checked: !!taxpayerIdentifier,
                    }}
                  />
                  <Label id="taxpayerIdentifier">
                    Taxpayer Identification Number
                  </Label>
                </FieldGroup>
              </div>
            </div>
          </div>

          <div className="form-row form-row-full flex">
            <ReduxInputField
              optionalLabel="Optional"
              label="Custom Redirect URL"
              input={{
                onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
                  setInvitationForm({
                    ...invitationForm,
                    customRedirect: e.target.value,
                  }),
                value: customRedirect,
                name: "customRedirect",
              }}
            />
          </div>
          <div className="form-row form-row-full flex">
            <FieldGroup>
              <Label id="sendFromDomain">Send from domain</Label>
              <p className="text-xs">
                Emails sent to this counterparty will be sent from this domain.
                <a href="https://docs.moderntreasury.com/docs/custom-email-
                domains">
                  &nbsp; Learn more.
                </a>
                {!canManageCustomEmailDomains && (
                  <>
                    <Tooltip
                      className="ml-1"
                      data-for="send-from-domain-tip"
                      data-tip="You don't have permission to change the senders
                      domain"
                    />
                    <ReactTooltip id="send-from-domain-tip" multiline />
                  </>
                )}
              </p>
              <SelectField
                id="sendFromDomain"
                selectValue={invitationForm.send_from_domain_id}
                disabled={!canManageCustomEmailDomains}
                placeholder={
                  defaultSendingDomainNode?.domain ?? MT_MAIL_DOMAIN_ID
                }
                options={verifiedCustomEmailDomainsOptions}
                handleChange={(value: string) =>
                  setInvitationForm({
                    ...invitationForm,
                    send_from_domain_id: value,
                  })
                }
                required
              />
            </FieldGroup>
          </div>
        </div>

        <div className="form-group">
          {submitting && (
            <ClipLoader
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore
              loaderStyle={{ verticalAlign: "middle", marginLeft: "1rem" }}
            />
          )}
        </div>
      </form>
    </ConfirmModal>
  );
}

export default InviteCounterpartyModal;
```

---
## `InvoiceBulkImport.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreateInvoicesMutation,
  useBulkValidateInvoiceImportMutation,
} from "~/generated/dashboard/graphqlSchema";
import { BulkResourceType } from "./FlatfileBulkUploadButton";
import BulkImportHeader from "./BulkImportHeader";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import {
  invoiceBlueprint,
  invoiceBlueprintFields,
} from "./bulk_imports/blueprints/invoiceBlueprint";

function InvoiceBulkImport(): JSX.Element {
  const [bulkCreateInvoices] = useBulkCreateInvoicesMutation();
  const [bulkValidateInvoiceImport] = useBulkValidateInvoiceImportMutation();

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreateInvoices({
      variables: {
        input: {
          invoices: resultsData,
          flatfileSheetId,
          flatfileSpaceId,
        },
      },
    });
    const { bulkImportId } = data?.bulkCreateInvoices ?? {};
    if (bulkImportId) {
      return { success: true, bulkImportId };
    }
    return { success: false, bulkImportId: "" };
  };

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidateInvoiceImport({
      variables: {
        input: {
          invoiceLineItemRows: resultsData,
        },
      },
    });
    return response.data?.bulkValidateInvoiceImport?.recordErrors;
  };
  return (
    <PageHeader
      crumbs={[
        {
          name: "Invoices",
          path: "/invoicing/invoices",
        },
      ]}
      title="Bulk Imports"
    >
      <BulkImportHeader
        bulkImportType="Invoice"
        validate={validate}
        submit={submit}
        expectedFields={invoiceBlueprintFields}
        blueprint={invoiceBlueprint}
        resource={BulkResourceType.Invoices}
      />
    </PageHeader>
  );
}

export default InvoiceBulkImport;
```

---
## `KeyValueInput.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Field, FieldArray, FieldProps, Formik, FormikProps } from "formik";
import { v4 as uuidv4 } from "uuid";
import * as Yup from "yup";
import { cn } from "~/common/utilities/cn";
import {
  Autosuggest,
  Button,
  FieldGroup,
  Icon,
  Input,
  Label,
  Stack,
} from "../../common/ui-components";

interface Props {
  /** When true, allows users to submit an empty keyValuePair form */
  allowNoEntries?: boolean;
  /** When true, both keys and values must be non empty for the pair to be added
  as form data */
  completedValuesAndKeys?: boolean;
  /** When true, the component is disabled */
  disabled?: boolean;
  /** When true, hides the Label from field */
  hideLabel?: boolean;
  /** Initial k,v pairs to display */
  initialValues?: Record<string, string>;
  /** Uses inline icon for adding new keyValuePair fields rather than default
  button */
  inlineAddButton?: boolean;
  /** When true, the key and value input fields appear on different rows */
  multiLines?: boolean;
  /** When true, an empty k,v pair appears underneath the k,v pairs from initial
  values */
  noInitialEmptyEntry?: boolean;
  /** Function that fires when user types a character. */
  onChange: (keyValuePair: Record<string, string>) => void;
  /** When true, the keyValuePair key/value pair will always be removed when x
  is pressed.
   * Otherwise, the pair is only removed if the key is not in the initial values
   */
  alwaysDeleteOnRemove?: boolean;
  /** The label  assigned to field */
  label?: string;
  /** Function executed on key press */
  onKeyChange?: (key: string) => void;
  /** Suggested Metadata Key */
  suggestions?: string[];
}

type FormData = Array<{
  deleted?: boolean;
  id: string;
  key: string;
  value: string;
}>;

const rowCompleted = (values: { keyValuePair: FormData }, index: number) =>
  values.keyValuePair[index].key && values.keyValuePair[index].value;

export function checkKeyValuePairs(
  keyValuePair: Record<string, string>,
  initialKeyValuePair?: Record<string, string>,
) {
  return Object.keys(keyValuePair).every((key) => {
    if (keyValuePair[key] !== "") {
      return true;
    }

    // Case when one key is deleted but that same key name is used in another
    key-value pair
    // e.g. Delete key "test" but rename another key to "test"
    // The delete will set { test: "", test: "new value"}
    // We should ingnore the { test: "" }
    if (
      keyValuePair[key] === "" &&
      initialKeyValuePair &&
      initialKeyValuePair[key] !== ""
    ) {
      return true;
    }

    return false;
  });
}

export const validation = (initialKeyValuePair: Record<string, string>) =>
  Yup.object()
    .nullable()
    .test("ensure_to_have_text", "", (d, { createError }) => {
      if (
        d &&
        !checkKeyValuePairs(d as Record<string, string>, initialKeyValuePair)
      ) {
        return createError({
          message: "Please enter a key and value on all keyValuePair fields",
        });
      }
      return true;
    });

function InlineAddButton({
  push,
  disabled,
}: {
  push: (obj: unknown) => void;
  disabled?: boolean;
}) {
  return (
    <Button
      disabled={disabled}
      iconOnly
      id="add_key_value_pairs"
      onClick={() => push({ key: "", value: "", id: uuidv4() })}
    >
      <Icon iconName="add" size="s" />
    </Button>
  );
}

function KeyValueInput({
  allowNoEntries = true,
  completedValuesAndKeys = true,
  disabled,
  hideLabel,
  initialValues = {},
  inlineAddButton = false,
  multiLines = false,
  noInitialEmptyEntry = false,
  alwaysDeleteOnRemove = false,
  onChange,
  label = "Metadata",
  onKeyChange,
  suggestions,
}: Props) {
  const defaultHandleKeyChange = async (
    values: { keyValuePair: FormData },
    index: number,
    submitForm: FormikProps<{ keyValuePair: FormData }>["submitForm"],
  ) => {
    if (!completedValuesAndKeys || rowCompleted(values, index)) {
      await submitForm();
    }

    if (onKeyChange) {
      void onKeyChange(values.keyValuePair[index].key);
    }
  };

  const initialKeyValuePairs = Object.keys(initialValues).reduce<FormData>(
    (acc, key) => [...acc, { key, value: initialValues[key], id: uuidv4() }],
    [],
  );
  return (
    <FieldGroup>
      <Formik
        initialValues={
          noInitialEmptyEntry
            ? { keyValuePair: initialKeyValuePairs }
            : {
                keyValuePair: initialKeyValuePairs.concat([
                  { key: "", value: "", id: uuidv4() },
                ]),
              }
        }
        onSubmit={(values: { keyValuePair: FormData }) => {
          const newValues = values.keyValuePair.reduce((acc, value) => {
            let newValue = value;
            const allValues = values.keyValuePair.filter(
              (v) => v.key === value.key,
            );
            // This is the case when one deletes a key and renames another key
            to the deleted key name
            // We want to use the updated key name and value
            if (allValues.length > 1) {
              newValue = allValues.find((v) => !v.deleted) || newValue;
            }
            if (completedValuesAndKeys) {
              if (newValue.key && newValue.value) {
                return { ...acc, [newValue.key]: newValue.value };
              }
              return acc;
            }
            return { ...acc, [newValue.key]: newValue.value };
          }, {});
          if (!alwaysDeleteOnRemove) {
            initialKeyValuePairs.forEach((initialValue) => {
              // This means the original key was replaced with another key
              if (!(initialValue.key in newValues)) {
                newValues[initialValue.key] = "";
              }
            });
          }
          onChange(newValues);
        }}
      >
        {({
          values,
          setFieldValue,
          submitForm,
        }: FormikProps<{ keyValuePair: FormData }>) => (
          <>
            {!hideLabel && <Label>{label}</Label>}
            <FieldArray name="keyValuePair">
              {({ push, replace, remove }) => (
                <Stack className="gap-4">
                  {values.keyValuePair.map((keyValuePair, index) =>
                    values.keyValuePair[index]?.deleted ? null : (
                      <div
                        className={cn(
                          "flex",
                          multiLines ? "flex-col" : "items-end gap-x-4",
                        )}
                        key={keyValuePair.id}
                      >
                        <FieldGroup>
                          <Field name={`keyValuePair.${index}.key`}>
                            {({ field: fieldProps }: FieldProps<string>) => (
                              <div
                                className={cn(
                                  multiLines ? "w-full" : "flex items-end",
                                )}
                              >
                                <Autosuggest
                                  required
                                  placeholder={
                                    disabled ? fieldProps.value : "Key"
                                  }
                                  className={cn(
                                    multiLines ? "mb-4" : "min-w-[207px]",
                                  )}
                                  field={fieldProps.name}
                                  disabled={disabled}
                                  suggestions={
                                    suggestions?.map((k) => ({
                                      label: k,
                                      value: k,
                                    })) || []
                                  }
                                  onChange={(e) => {
                                    fieldProps.onChange(e);
                                    defaultHandleKeyChange(
                                      values,
                                      index,
                                      submitForm,
                                    ).catch(() => {});
                                  }}
                                  onSuggestionSelect={(e, suggestion) => {
                                    void setFieldValue(
                                      `keyValuePair.${index}.key`,
                                      suggestion.suggestionValue,
                                    );
                                    defaultHandleKeyChange(
                                      values,
                                      index,
                                      submitForm,
                                    ).catch(() => {});
                                  }}
                                  onFocus={() => {
                                    if (onKeyChange) {
                                      void onKeyChange(
                                        values.keyValuePair[index].key,
                                      );
                                    }
                                  }}
                                  value={disabled ? "" : fieldProps.value}
                                />
                              </div>
                            )}
                          </Field>
                        </FieldGroup>
                        <FieldGroup>
                          <Field name={`keyValuePair.${index}.value`}>
                            {({ field: fieldProps }: FieldProps<string>) => (
                              <div
                                className={cn(
                                  multiLines ? "w-full" : "flex items-end",
                                )}
                              >
                                <Input
                                  required
                                  placeholder={
                                    disabled ? fieldProps.value : "Value"
                                  }
                                  disabled={disabled}
                                  onChange={(e) => {
                                    void setFieldValue(
                                      `keyValuePair.${index}.value`,
                                      e.target.value,
                                    );
                                    // setFieldValue is async, so running
                                    `submitForm` immediately afterwards
                                    // causes the validation to run on stale
                                    values. There is no clean workaround
                                    // other than calling submit on the next
                                    event loop using setTimeout.
                                    // https://github.com/jaredpalmer/formik/iss
                                    ues/529
                                    setTimeout(() => {
                                      submitForm().catch(() => {});
                                    });
                                  }}
                                  name={fieldProps.name}
                                  value={disabled ? "" : fieldProps.value}
                                  className="min-w-[207px]"
                                />
                              </div>
                            )}
                          </Field>
                        </FieldGroup>
                        <div
                          className={cn(
                            "flex items-center",
                            multiLines ? "mt-4" : "gap-2",
                          )}
                        >
                          <Button
                            onClick={() => {
                              const k = values.keyValuePair[index].key;
                              if (
                                alwaysDeleteOnRemove ||
                                !Object.prototype.hasOwnProperty.call(
                                  initialValues,
                                  k,
                                )
                              ) {
                                remove(index);
                              } else {
                                replace(index, {
                                  ...values.keyValuePair[index],
                                  value: "",
                                  deleted: true,
                                });
                              }
                              // Make sure theres always one Key Value Input row
                              if not allow
                              if (
                                !allowNoEntries &&
                                values.keyValuePair.reduce((acc, curr) => {
                                  const newCount = curr.deleted ? acc + 1 : acc;
                                  return newCount;
                                }, 0) ===
                                  values.keyValuePair.length - 1
                              ) {
                                push({ key: "", value: "", id: uuidv4() });
                              }
                              submitForm().catch(() => {});
                            }}
                            disabled={disabled}
                            id={`remove_key_value_pairs_${index}`}
                            iconOnly
                          >
                            <Icon iconName="clear" size="s" />
                          </Button>
                          {inlineAddButton &&
                            values.keyValuePair.length - 1 === index && (
                              <InlineAddButton
                                push={push}
                                disabled={disabled}
                              />
                            )}
                        </div>
                      </div>
                    ),
                  )}
                  {inlineAddButton && values.keyValuePair.length === 0 && (
                    <Button
                      onClick={() => push({ key: "", value: "", id: uuidv4() })}
                      disabled={disabled}
                      id="add_key_value_pairs"
                      className="mb-4 w-36"
                      iconOnly
                    >
                      <Icon iconName="add" size="s" />
                      <span>Add {label}</span>
                    </Button>
                  )}
                  {!inlineAddButton && (
                    <Button
                      onClick={() => push({ key: "", value: "", id: uuidv4() })}
                      disabled={disabled}
                      id="add_key_value_pairs"
                      className="w-36"
                      iconOnly
                    >
                      <Icon iconName="add" size="s" />
                      <span>Add {label}</span>
                    </Button>
                  )}
                </Stack>
              )}
            </FieldArray>
          </>
        )}
      </Formik>
    </FieldGroup>
  );
}

export default KeyValueInput;
```

---
## `LedgerAccountCategoriesHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import LedgerAccountCategoriesEmptyState from
"../containers/LedgerAccountCategoriesEmptyState";
import {
  LedgerAccountCategoriesHomeDocument,
  LedgerAccountCategoryChildrenDocument,
} from "../../generated/dashboard/graphqlSchema";
import ListView, { Node } from "./ListView";
import {
  getLedgerAccountCategorySearchComponents,
  mapLedgerAccountCategoryQueryToVariables,
  mapLedgerAccountCategoryQueryToNestingVariables,
} from "../../common/search_components/ledgerAccountCategorySearchComponents";
import {
  LEDGER_ACCOUNT_CATEGORY,
  LEDGER_ACCOUNT_CATEGORY_CHILD,
} from "../../generated/dashboard/types/resources";

const CONSTANT_QUERY_PARAMS = ["tab", "effective_at"];

function LedgerAccountCategoriesHome({
  ledgerId,
  initialShowSearchArea,
}: {
  ledgerId: string;
  initialShowSearchArea: boolean;
}) {
  const searchComponents = getLedgerAccountCategorySearchComponents();

  return (
    <ListView
      graphqlDocument={LedgerAccountCategoriesHomeDocument}
      resource={LEDGER_ACCOUNT_CATEGORY}
      constantQueryVariables={{
        ledgerId,
      }}
      constantQueryParams={CONSTANT_QUERY_PARAMS}
      ListViewEmptyState={
        <div className="flex justify-center px-6 py-16">
          <LedgerAccountCategoriesEmptyState ledgerId={ledgerId} />
        </div>
      }
      initialShowSearchArea={initialShowSearchArea}
      defaultSearchComponents={searchComponents.defaultComponents}
      additionalSearchComponents={searchComponents.additionalComponents}
      mapQueryToVariables={mapLedgerAccountCategoryQueryToVariables}
      nestingDocument={LedgerAccountCategoryChildrenDocument}
      mapQueryToNestingVariables={
        mapLedgerAccountCategoryQueryToNestingVariables
      }
      nestingResource={LEDGER_ACCOUNT_CATEGORY_CHILD}
      hasNesting={(node: Node) => (node.childrenCount ?? 0) !== 0}
      horizontalDefaultSearchComponents
    />
  );
}

export default LedgerAccountCategoriesHome;
```

---
## `LedgerAccountSettlementsHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  getLedgerAccountSettlementSearchComponents,
  mapLedgerAccountSettlementQueryToVariables,
} from "~/common/search_components/ledgerAccountSettlementSearchComponents";
import { LedgerAccountSettlementsHomeDocument } from
"../../generated/dashboard/graphqlSchema";
import { LEDGER_ACCOUNT_SETTLEMENT } from
"../../generated/dashboard/types/resources";
import ListView from "./ListView";
import LedgerAccountSettlementsEmptyState from
"../containers/LedgerAccountSettlementsEmptyState";

interface LedgerAccountSettlementsHomeProps {
  ledgerId: string;
}

const CONSTANT_QUERY_PARAMS = ["tab"];

const STYLE_MAPPING = {
  prettyStatus: "max-w-20",
  amount: "!px-1 max-w-20",
};

export default function LedgerAccountSettlementsHome({
  ledgerId,
}: LedgerAccountSettlementsHomeProps) {
  const searchComponents = getLedgerAccountSettlementSearchComponents();

  return (
    <ListView
      resource={LEDGER_ACCOUNT_SETTLEMENT}
      graphqlDocument={LedgerAccountSettlementsHomeDocument}
      defaultSearchComponents={searchComponents.defaultComponents}
      additionalSearchComponents={searchComponents.additionalComponents}
      ListViewEmptyState={
        <div className="flex justify-center px-6 py-16">
          <LedgerAccountSettlementsEmptyState />
        </div>
      }
      customizableColumns
      constantQueryParams={CONSTANT_QUERY_PARAMS}
      constantQueryVariables={{ ledgerId }}
      mapQueryToVariables={mapLedgerAccountSettlementQueryToVariables}
      initialShowSearchArea
      styleMapping={STYLE_MAPPING}
    />
  );
}
```

---
## `LedgerAccountsHome.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import LedgerAccountsEmptyState from "../containers/LedgerAccountsEmptyState";
import ListView from "./ListView";
import {
  LedgerAccountsHomeDocument,
  useLedgerAccountSelectQuery,
  useDeleteLedgerAccountMutation,
} from "../../generated/dashboard/graphqlSchema";
import { ConfirmModal } from "../../common/ui-components";
import { ExportDataParams } from "./ExportDataButton";
import {
  getLedgerAccountSearchComponents,
  LedgerAccountQueryFilter,
} from "../../common/search_components/ledgerAccountSearchComponents";
import { LEDGER_ACCOUNT } from "../../generated/dashboard/types/resources";
import { useDispatchContext } from "../MessageProvider";
import trackEvent from "../../common/utilities/trackEvent";
import { LEDGERS_EVENTS } from "../../common/constants/analytics";

const CONSTANT_QUERY_PARAMS = ["tab", "effective_at"];

interface LedgerAccountsHomeProps {
  ledgerId: string;
  initialShowSearchArea: boolean;
}

function LedgerAccountsHome({
  ledgerId,
  initialShowSearchArea,
}: LedgerAccountsHomeProps) {
  const { dispatchError } = useDispatchContext();
  const { loading: accountsLoading, data: accountData } =
    useLedgerAccountSelectQuery({
      variables: {
        id: ledgerId,
        accountId: "",
      },
    });

  const [currencyFilter, setCurrencyFilter] = useState<string>("");
  const [bulkDeleteIds, setBulkDeleteIds] = useState<Array<string>>([]);
  const [deleteLedgerAccount] = useDeleteLedgerAccountMutation();
  const cancelLedgerAccountDelete = () => {
    window.location.href = `/ledgers/${ledgerId}?tab=accounts`;
  };

  const onDeleteLedgerAccounts = (ledgerAccountIds: Array<string>): void => {
    ledgerAccountIds.forEach((ledgerAccountId) => {
      deleteLedgerAccount({
        variables: {
          input: { id: ledgerAccountId },
        },
      })
        .then((response) => {
          const { errors = [] } = response.data?.deleteLedgerAccount || {};
          if (errors.length) {
            dispatchError(errors.toString());
          } else {
            trackEvent(null, LEDGERS_EVENTS.DELETE_LEDGER_ACCOUNT_CLICKED);
          }
          window.location.href = `/ledgers/${ledgerId}?tab=accounts`;
        })
        .catch(() => {
          dispatchError("An error occurred. Please try again.");
        });
    });
  };

  const onDelete = (ledgerAccountIds: Array<string>) => {
    if (ledgerAccountIds) {
      setBulkDeleteIds(ledgerAccountIds);
    }
    return false;
  };

  const uniqueLedgerAccountCurrencies = new Map<string, number>(
    accountsLoading || !accountData
      ? []
      : accountData.ledgerAccounts.edges.map(({ node }) => [
          node.currency,
          Number.isNaN(node.currencyExponent)
            ? 2
            : Number(node.currencyExponent),
        ]),
  );

  const mapQueryToVariables = (query: LedgerAccountQueryFilter) => {
    setCurrencyFilter(query.currency ?? "");

    return {
      id: query.id,
      name: query.name,
      effectiveAt: query.effective_at?.lte || new Date().toISOString(),
      description: query.description,
      metadata: JSON.stringify(query.metadata),
      currency: query.currency,
      postedBalanceAmount: query.currency ? query.posted_balance_amount : null,
      pendingBalanceAmount: query.currency
        ? query.pending_balance_amount
        : null,
    };
  };

  const exportDataParams: ExportDataParams = {
    params: { ledger_id: ledgerId },
  };

  const searchComponents = getLedgerAccountSearchComponents(
    uniqueLedgerAccountCurrencies,
    currencyFilter,
  );

  return (
    <>
      {bulkDeleteIds.length > 0 && (
        <ConfirmModal
          title="Delete Ledger Account(s)"
          isOpen={bulkDeleteIds.length > 0}
          onRequestClose={() => setBulkDeleteIds([])}
          setIsOpen={() => {
            setBulkDeleteIds([]);
            cancelLedgerAccountDelete();
          }}
          confirmText="Delete Ledger Account(s)"
          confirmType="delete"
          onConfirm={() => {
            onDeleteLedgerAccounts(bulkDeleteIds);
            setBulkDeleteIds([]);
          }}
        >
          Do you want to proceed with ledger account deletion? Once deleted, a
          ledger account cannot be recovered.
        </ConfirmModal>
      )}
      <ListView
        actions={{
          Delete: (_actionName: string, ledgerAccountIds: Array<string>) =>
            onDelete(ledgerAccountIds),
        }}
        additionalSearchComponents={searchComponents.additionalComponents}
        constantQueryVariables={{
          ledgerId,
        }}
        enableActions
        favoritesEnabled
        defaultSearchComponents={searchComponents.defaultComponents}
        graphqlDocument={LedgerAccountsHomeDocument}
        initialShowSearchArea={initialShowSearchArea}
        horizontalDefaultSearchComponents
        customizableColumns
        constantQueryParams={CONSTANT_QUERY_PARAMS}
        resource={LEDGER_ACCOUNT}
        ListViewEmptyState={
          <div className="flex justify-center px-6 py-16">
            <LedgerAccountsEmptyState ledgerId={ledgerId} />
          </div>
        }
        enableExportData
        exportDataParams={exportDataParams}
        mapQueryToVariables={mapQueryToVariables}
      />
    </>
  );
}

export default LedgerAccountsHome;
```

---
## `LedgerEntriesHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { LedgerEntriesHomeDocument } from "~/generated/dashboard/graphqlSchema";
import {
  getLedgerEntrySearchComponents,
  mapLedgerEntryQueryToVariables,
} from "~/common/search_components/ledgerEntrySearchComponents";
import { LEDGER_ENTRY } from "~/generated/dashboard/types/resources";
import LedgerEntriesEmptyState from "../containers/LedgerEntriesEmptyState";
import ListView from "./ListView";
import { ExportDataParams } from "./ExportDataButton";

const CONSTANT_QUERY_PARAMS = ["tab"];

const STYLE_MAPPING = {
  prettyStatus: "max-w-20",
};

function LedgerEntriesHome({
  ledgerId,
  initialShowSearchArea,
  onClickLedgerAccountLink,
}: {
  ledgerId: string;
  initialShowSearchArea: boolean;
  onClickLedgerAccountLink: () => void;
}) {
  const exportDataParams: ExportDataParams = {
    params: { ledger_id: ledgerId },
  };
  const searchComponents = getLedgerEntrySearchComponents();

  return (
    <ListView
      graphqlDocument={LedgerEntriesHomeDocument}
      mapQueryToVariables={mapLedgerEntryQueryToVariables}
      resource={LEDGER_ENTRY}
      additionalSearchComponents={searchComponents.additionalComponents}
      defaultSearchComponents={searchComponents.defaultComponents}
      constantQueryParams={CONSTANT_QUERY_PARAMS}
      constantQueryVariables={{ ledgerId }}
      initialShowSearchArea={initialShowSearchArea}
      ListViewEmptyState={
        <div className="flex justify-center px-6 py-16">
          <LedgerEntriesEmptyState
            onClickLedgerAccountLink={onClickLedgerAccountLink}
          />
        </div>
      }
      enableExportData
      exportDataParams={exportDataParams}
      styleMapping={STYLE_MAPPING}
      hideAllCheckboxes
    />
  );
}

export default LedgerEntriesHome;
```

---
## `LedgerStatusBadge.tsx.txt`
**Path:** `.`  
```
import React from "react";
import upperFirst from "lodash/upperFirst";
import { Tag } from "~/common/ui-components";
import { TagColors } from "~/common/ui-components/Tag/Tag";
import { LedgerTransaction__StatusEnum } from
"../../generated/dashboard/graphqlSchema";

function LedgerStatusBadge({
  status,
}: {
  status: LedgerTransaction__StatusEnum;
}) {
  let color: TagColors = "gray";
  if (status === LedgerTransaction__StatusEnum.Posted) {
    color = "green";
  } else if (status === LedgerTransaction__StatusEnum.Archived) {
    color = "red";
  }
  return (
    <Tag size="small" color={color}>
      {upperFirst(status)}
    </Tag>
  );
}

export default LedgerStatusBadge;
```

---
## `LedgerTransactionDetailsCard.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { cn } from "~/common/utilities/cn";
import { LedgerTransaction__StatusEnum } from
"../../generated/dashboard/graphqlSchema";
import LedgerStatusBadge from "./LedgerStatusBadge";
import {
  DateTime,
  CopyableText,
  OverflowTip,
} from "../../common/ui-components";

interface LedgerTransactionDetailsCardProps {
  id: string;
  ledgerId: string;
  externalId?: string | null;
  status: LedgerTransaction__StatusEnum;
  ledgerablePath?: string | null;
  ledgerableId?: string | null;
  amount?: string;
  createdAt: string;
  updatedAt?: string | null;
  postedAt?: string | null;
  effectiveAt: string;
  ledgerableType?: string | null;
  description?: string | null;
  reversesLedgerTransactionId?: string | null;
  reversedByLedgerTransactionId?: string | null;
  partiallyPostsLedgerTransactionId?: string | null;
}

function EmptyLine(): JSX.Element {
  return <div className="w-28">-</div>;
}

function IdFormatted(id: string): JSX.Element {
  return <CopyableText text={id}>{id}</CopyableText>;
}

function LedgerTransactionDetailsCard({
  id,
  ledgerId,
  externalId,
  status,
  ledgerablePath,
  ledgerableId,
  amount,
  createdAt,
  updatedAt,
  postedAt,
  effectiveAt,
  ledgerableType,
  description,
  reversesLedgerTransactionId,
  reversedByLedgerTransactionId,
  partiallyPostsLedgerTransactionId,
}: LedgerTransactionDetailsCardProps) {
  const ledgerTransactionDetails = {
    ID: IdFormatted(id),
    "Ledger ID": ledgerId ?? <EmptyLine />,
    ...(externalId && { "External ID": externalId }),
    Status: <LedgerStatusBadge status={status} />,
    "Ledgerable Type": ledgerableType ?? <EmptyLine />,
    "Ledgerable ID": (ledgerablePath ? (
      <a href={ledgerablePath}>{ledgerableId}</a>
    ) : (
      ledgerableId
    )) ?? <EmptyLine />,
    ...(amount && { Amount: amount }),
    "Created At": <DateTime timestamp={createdAt} />,
    ...(postedAt && {
      "Posted At":
        status === LedgerTransaction__StatusEnum.Posted ? (
          <DateTime timestamp={postedAt} />
        ) : (
          <EmptyLine />
        ),
    }),
    ...(updatedAt && { "Updated At": <DateTime timestamp={updatedAt} /> }),
    "Effective At": <DateTime timestamp={effectiveAt} />,
    Description: (description || undefined) ?? <EmptyLine />,
    ...(reversesLedgerTransactionId && {
      "Reverses Ledger Transaction": (
        <a href={`/ledger_transactions/${reversesLedgerTransactionId}`}>
          {IdFormatted(reversesLedgerTransactionId)}
        </a>
      ),
    }),
    ...(reversedByLedgerTransactionId && {
      "Reversed By Ledger Transaction": (
        <a href={`/ledger_transactions/${reversedByLedgerTransactionId}`}>
          {IdFormatted(reversedByLedgerTransactionId)}
        </a>
      ),
    }),
    ...(partiallyPostsLedgerTransactionId && {
      "Partially Posts Ledger Transaction": (
        <a href={`/ledger_transactions/${partiallyPostsLedgerTransactionId}`}>
          {IdFormatted(partiallyPostsLedgerTransactionId)}
        </a>
      ),
    }),
  };

  return (
    <div className="rounded-md border border-alpha-black-100 bg-white px-6
    py-4">
      {Object.keys(ledgerTransactionDetails).map((label) => (
        <div
          key={label}
          className="grid grid-cols-3 whitespace-nowrap py-2 text-sm"
        >
          <div className="overflow-hidden overflow-ellipsis pr-1 text-gray-600">
            {label}
          </div>
          {typeof ledgerTransactionDetails[label] === "string" ? (
            <OverflowTip
              message={ledgerTransactionDetails[label] as string}
              className="col-span-2 self-center truncate text-left"
            >
              {ledgerTransactionDetails[label]}
            </OverflowTip>
          ) : (
            <div className={cn("col-span-2 self-center text-left")}>
              {ledgerTransactionDetails[label]}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}

export default LedgerTransactionDetailsCard;
```

---
## `LedgerTransactionsHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ListView from "~/app/components/ListView";
import {
  getLedgerTransactionSearchComponents,
  mapLedgerTransactionQueryToVariables,
} from "~/common/search_components/ledgerTransactionSearchComponents";
import { LedgerTransactionsHomeDocument } from
"~/generated/dashboard/graphqlSchema";
import { LEDGER_TRANSACTION } from "~/generated/dashboard/types/resources";
import LedgerTransactionsEmptyState from
"~/app/containers/LedgerTransactionsEmptyState";
import { ExportDataParams } from "~/app/components/ExportDataButton";

const STYLE_MAPPING = {
  prettyStatus: "max-w-20",
};

const CONSTANT_QUERY_PARAMS = ["tab"];

function LedgerTransactionsHome({
  ledgerId,
  initialShowSearchArea,
  onClickLedgerAccountLink,
}: {
  ledgerId: string;
  initialShowSearchArea: boolean;
  onClickLedgerAccountLink: () => void;
}) {
  const searchComponents = getLedgerTransactionSearchComponents();

  const editRow = (ids: string[]) => {
    if (ids.length > 0) {
      window.location.href = `/ledger_transactions/${ids[0]}/edit`;
    }

    return false;
  };

  const ACTIONS = {
    Edit: (_actionName, ids: string[]) => editRow(ids),
  };

  const exportDataParams: ExportDataParams = {
    params: { ledger_id: ledgerId },
  };

  return (
    <ListView
      resource={LEDGER_TRANSACTION}
      graphqlDocument={LedgerTransactionsHomeDocument}
      styleMapping={STYLE_MAPPING}
      defaultSearchComponents={searchComponents.defaultComponents}
      additionalSearchComponents={searchComponents.additionalComponents}
      ListViewEmptyState={
        <div className="flex justify-center px-6 py-16">
          <LedgerTransactionsEmptyState
            onClickLedgerAccountLink={onClickLedgerAccountLink}
          />
        </div>
      }
      mapQueryToVariables={mapLedgerTransactionQueryToVariables}
      constantQueryParams={CONSTANT_QUERY_PARAMS}
      constantQueryVariables={{ ledgerId }}
      initialShowSearchArea={initialShowSearchArea}
      actions={ACTIONS}
      horizontalDefaultSearchComponents
      enableActions
      enableExportData
      exportDataParams={exportDataParams}
      hideAllCheckboxes
    />
  );
}

export default LedgerTransactionsHome;
```

---
## `LedgerableEventsHome.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { LedgerableEventsHomeDocument } from
"../../generated/dashboard/graphqlSchema";
import { LEDGERABLE_EVENT } from "../../generated/dashboard/types/resources";
import ListView from "./ListView";
import LedgerableEventsEmptyState from
"../containers/LedgerableEventsEmptyState";

interface LedgerableEventsHomeProps {
  ledgerId: string;
}

const CONSTANT_QUERY_PARAMS = ["tab"];

export default function LedgerableEventsHome({
  ledgerId,
}: LedgerableEventsHomeProps) {
  return (
    <ListView
      resource={LEDGERABLE_EVENT}
      graphqlDocument={LedgerableEventsHomeDocument}
      constantQueryVariables={{
        ledgerId,
      }}
      customizableColumns={false}
      constantQueryParams={CONSTANT_QUERY_PARAMS}
      ListViewEmptyState={
        <div className="flex justify-center px-6 py-16">
          <LedgerableEventsEmptyState />
        </div>
      }
    />
  );
}
```

---
## `LedgersAdditionalInfoEntriesTab.tsx.txt`
**Path:** `.`  
```
import React from "react";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import { useLedgersAdditionalInfoEntriesQuery } from
"../../generated/dashboard/graphqlSchema";
import { handleLinkClick } from "~/common/utilities/handleLinkClick";
import { ButtonClickEventTypes, Pill } from "~/common/ui-components";

interface LedgersAdditionalInfoEntriesTabProps {
  entityId: string;
  entityType:
    | "LedgerableEvent"
    | "LedgerTransaction"
    | "LedgerAccountSettlement";
}

function exhaustiveGuard(_value: string): never {
  throw new Error(
    `Error! Reached forbidden guard function with unexpected value:
    ${JSON.stringify(
      _value,
    )}`,
  );
}

export default function LedgersAdditionalInfoEntriesTab({
  entityId,
  entityType,
}: LedgersAdditionalInfoEntriesTabProps) {
  function idForRequest() {
    switch (entityType) {
      case "LedgerTransaction":
        return { ledgerTransactionId: entityId };
      case "LedgerAccountSettlement":
        return { ledgerAccountSettlementId: entityId };
      default:
        return exhaustiveGuard(entityType);
    }
  }
  const { loading, data, error, refetch } =
    useLedgersAdditionalInfoEntriesQuery({
      notifyOnNetworkStatusChange: true,
      variables: {
        first: INITIAL_PAGINATION.perPage,
        ...idForRequest(),
      },
    });

  const ledgerEntries =
    loading || !data || error
      ? []
      : data.ledgerEntries.edges.map(({ node }) => ({
          debit:
            node.direction === "debit" ? (
              <Pill
                onClick={(e: ButtonClickEventTypes) =>
                  handleLinkClick(node.path, e)
                }
                showTooltip
              >
                {node.amount}
              </Pill>
            ) : (
              <span className="text-gray-600">-</span>
            ),
          credit:
            node.direction === "credit" ? (
              <Pill
                onClick={(e: ButtonClickEventTypes) =>
                  handleLinkClick(node.path, e)
                }
                showTooltip
              >
                {node.amount}
              </Pill>
            ) : (
              <span className="text-gray-600">-</span>
            ),
          accountName: (
            <span className="py-8 align-middle">{node.ledgerAccount.name}</span>
          ),
          id: node.id,
          path: node.ledgerAccount.path,
        }));

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
  }) => {
    const { cursorPaginationParams } = options;
    await refetch({
      ...cursorPaginationParams,
    });
  };

  return (
    <EntityTableView
      data={ledgerEntries}
      dataMapping={{
        accountName: "Account",
        debit: "Debit",
        credit: "Credit",
      }}
      styleMapping={{
        accountName: "whitespace-nowrap overflow-ellipsis overflow-hidden",
      }}
      loading={loading}
      onQueryArgChange={handleRefetch}
      cursorPagination={data?.ledgerEntries?.pageInfo}
      showDisabledPagination={false}
      disableQueryURLParams
    />
  );
}
```

---
## `LedgersAdditionalInfoTabs.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { LedgerTransactionViewQuery } from
"~/generated/dashboard/graphqlSchema";
import LedgersAdditionalInfoEntriesTab from "./LedgersAdditionalInfoEntriesTab";
import {
  SectionNavigator,
  KeyValueTable,
  LoadingLine,
  IndexTable,
  Heading,
} from "../../common/ui-components";
import AuditRecordsHome from "./AuditRecordsHome";
import LedgerTransactionVersionsView from
"../containers/LedgerTransactionVersionsTimeline";

type TabSection = "entries" | "metadata" | "timeline" | "custom_data";
type TabEntity =
  | "LedgerableEvent"
  | "LedgerTransaction"
  | "LedgerAccountSettlement";
export type TabLabels = Record<TabSection, string>;

interface LedgersAdditionalInfoTabsProps {
  entityId: string;
  entityType: TabEntity;
  initialSection: TabSection;
  loading?: boolean;
  metadataJson?: string;
  customDataJson?: string;
  sections: Partial<TabLabels>;
  bulkRequests: NonNullable<
    LedgerTransactionViewQuery["ledgerTransaction"]
  >["bulkRequests"];
}

function JsonTab({
  json,
  tabSection,
}: {
  json: string;
  tabSection: TabSection;
}) {
  const parsedJson = JSON.parse(json) as Record<string, unknown>;
  const jsonKeys = Object.keys(parsedJson);

  if (jsonKeys.length === 0) {
    return <div className="text-gray-500">No {tabSection} added.</div>;
  }

  const dataMapping = Object.fromEntries(jsonKeys.map((key) => [key, key]));
  return <KeyValueTable data={parsedJson} dataMapping={dataMapping} />;
}

function LedgerTransactionBulkRequestsTimeline({
  bulkRequests,
}: {
  bulkRequests: NonNullable<
    LedgerTransactionViewQuery["ledgerTransaction"]
  >["bulkRequests"];
}) {
  return (
    <div>
      <Heading level="h2" size="l" className="mb-4">
        Bulk Requests
      </Heading>
      <IndexTable
        data={bulkRequests}
        dataMapping={{
          id: "Bulk Request ID",
          prettyActionType: "Action Type",
          prettyStatus: "Status",
        }}
      />
    </div>
  );
}

function TimelineTab({
  entityId,
  entityType,
  bulkRequests,
}: {
  entityId: string;
  entityType: TabEntity;
  bulkRequests: NonNullable<
    LedgerTransactionViewQuery["ledgerTransaction"]
  >["bulkRequests"];
}) {
  return (
    <>
      <AuditRecordsHome
        queryArgs={{
          entityId,
          entityType,
        }}
        showDisabledPagination={false}
        hideLinks
      />
      <div className="pt-3">
        {entityType === "LedgerTransaction" && (
          <LedgerTransactionVersionsView ledgerTransactionId={entityId} />
        )}
      </div>
      {entityType === "LedgerTransaction" && (
        <LedgerTransactionBulkRequestsTimeline bulkRequests={bulkRequests} />
      )}
    </>
  );
}

function exhaustiveGuard(_value: never): never {
  throw new Error(
    `Error! Reached forbidden guard function with unexpected value:
    ${JSON.stringify(
      _value,
    )}`,
  );
}

export default function LedgersAdditionalInfoTabs({
  entityId,
  entityType,
  initialSection,
  loading = false,
  metadataJson = "{}",
  customDataJson = "{}",
  bulkRequests = [],
  sections,
}: LedgersAdditionalInfoTabsProps) {
  const [currentSection, setCurrentSection] =
    useState<TabSection>(initialSection);

  function getContent() {
    switch (currentSection) {
      case "metadata":
        return <JsonTab tabSection={currentSection} json={metadataJson} />;
      case "custom_data":
        return <JsonTab tabSection={currentSection} json={customDataJson} />;
      case "entries":
        return (
          <LedgersAdditionalInfoEntriesTab
            entityId={entityId}
            entityType={entityType}
          />
        );
      case "timeline":
        return (
          <TimelineTab
            entityId={entityId}
            entityType={entityType}
            bulkRequests={bulkRequests}
          />
        );
      default:
        return exhaustiveGuard(currentSection);
    }
  }

  return (
    <div>
      {loading ? (
        <div className="pb-4">
          <LoadingLine />
        </div>
      ) : (
        <SectionNavigator
          sections={sections}
          currentSection={currentSection}
          onClick={setCurrentSection as (section: string) => void}
        />
      )}
      {getContent()}
    </div>
  );
}
```

---
## `LedgersHeader.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { LedgerFragment } from "../../generated/dashboard/graphqlSchema";
import {
  Icon,
  LoadingLine,
  Tabs,
  ActionItem,
  ButtonClickEventTypes,
} from "../../common/ui-components";
import {
  PopoverPanel,
  PopoverTrigger,
  Popover,
} from "../../common/ui-components/Popover/Popover";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";
import { Link } from "~/common/ui-components/Link/Link";

export const TRANSACTION_TAB = "transactions";
export const ACCOUNTS_TAB = "accounts";
export const ENTRIES_TAB = "entries";
export const ACCOUNT_CATEGORIES_TAB = "categories";
export const SETTLEMENTS_TAB = "settlements";
export const LEDGERABLE_EVENTS_TAB = "ledgerable_events";

type LedgerViewQueryLedgerType = LedgerFragment | null | undefined;

type TabEntity =
  | "LedgerAccount"
  | "LedgerAccountCategory"
  | "LedgerEntry"
  | "LedgerableEvent"
  | "LedgerTransaction"
  | "LedgerAccountSettlement";

interface LedgersHeaderProps {
  onTabChange?: (tab: string, event: ButtonClickEventTypes) => void;
  selectedTab?: string;
  ledger?: LedgerViewQueryLedgerType;
  entityId?: string;
  entityType?: TabEntity;
  ledgerTransactionStatus?: string;
  canUpdateLedgerAccounts?: boolean;
  canUpdateLedgerTransactions?: boolean;
  canUpdateLedgerAccountCategories?: boolean;
  canUpdateLedgerAccountSettlements?: boolean;
  discarded?: boolean;
  skipActions?: boolean;
}

interface LedgersHeaderSkeletonLoaderProps {
  onTabChange?: (tab: string, event: ButtonClickEventTypes) => void;
  selectedTab?: string;
  entityId?: string;
  entityType?: TabEntity;
}

interface CreateEntitiesDropdownProps {
  canUpdateLedgerAccounts: boolean;
  canUpdateLedgerTransactions: boolean;
  canUpdateLedgerAccountCategories: boolean;
  canUpdateLedgerAccountSettlements: boolean;
  ledgerId: string;
}

const displayName = (entityType: string): string => {
  switch (entityType) {
    case "LedgerAccount":
      return "Ledger Account";
    case "LedgerAccountCategory":
      return "Ledger Account Category";
    case "LedgerEntry":
      return "Ledger Entry";
    case "LedgerableEvent":
      return "Ledgerable Event";
    case "LedgerTransaction":
      return "Ledger Transaction";
    case "LedgerAccountSettlement":
      return "Ledger Account Settlement";
    default:
      return "";
  }
};

function LedgersHeaderSkeletonLoader({
  onTabChange,
  selectedTab,
  entityId,
  entityType,
}: LedgersHeaderSkeletonLoaderProps) {
  return (
    <div className="flex flex-col">
      <div className="mb-5 flex pb-5">
        <span className="text-lg">
          <a className="text-lg text-blue-600 no-underline" href="/ledgers">
            Ledgers
          </a>
        </span>
        <div className="flex self-center px-1">
          <Icon
            iconName="forward_slash"
            color="currentColor"
            className="text-gray-400"
          />
        </div>
        <div className="flex w-1/6">
          <LoadingLine noHeight />
        </div>
        {entityId && (
          <>
            <div className="flex self-center px-1">
              <Icon
                iconName="forward_slash"
                color="currentColor"
                className="text-gray-400"
              />
            </div>
            <span className="max-w-xs overflow-hidden overflow-ellipsis
            whitespace-nowrap text-lg font-medium mint-lg:max-w-md">
              {displayName(entityType || "")}
            </span>
          </>
        )}
      </div>
      {!entityId && (
        <div className="flex w-full pb-6">
          <Tabs
            selected={selectedTab || ""}
            onClick={
              onTabChange as (tab: string, event: ButtonClickEventTypes) => void
            }
            tabs={{
              [ACCOUNTS_TAB]: "Accounts",
              [TRANSACTION_TAB]: "Transactions",
              [ENTRIES_TAB]: "Entries",
              [ACCOUNT_CATEGORIES_TAB]: "Categories",
              [SETTLEMENTS_TAB]: "Settlements",
              [LEDGERABLE_EVENTS_TAB]: "Ledgerable Events",
            }}
          />
        </div>
      )}
    </div>
  );
}

function CreateEntitiesDropdown({
  canUpdateLedgerAccounts,
  canUpdateLedgerTransactions,
  canUpdateLedgerAccountCategories,
  canUpdateLedgerAccountSettlements,
  ledgerId,
}: CreateEntitiesDropdownProps) {
  const disableActionsButton = !(
    canUpdateLedgerAccounts ||
    canUpdateLedgerTransactions ||
    canUpdateLedgerAccountCategories ||
    canUpdateLedgerAccountSettlements
  );

  return (
    <Popover>
      <PopoverTrigger buttonType="primary" disabled={disableActionsButton}>
        <span id="Actions">Actions</span>
        <Icon
          iconName="chevron_down"
          color="currentColor"
          className="text-white"
        />
      </PopoverTrigger>
      <PopoverPanel anchorOrigin={{ horizontal: "right" }}>
        {canUpdateLedgerAccounts && (
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick(
                `/ledgers/${ledgerId}/ledger_accounts/new`,
                event,
              );
            }}
          >
            <div id="create-ledger-account">Create Account</div>
          </ActionItem>
        )}
        {canUpdateLedgerTransactions && (
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick(
                `/ledgers/${ledgerId}/ledger_transactions/new`,
                event,
              );
            }}
          >
            <div id="create-ledger-transaction">Create Transaction</div>
          </ActionItem>
        )}
        {canUpdateLedgerAccountCategories && (
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick(
                `/ledgers/${ledgerId}/ledger_account_categories/new`,
                event,
              );
            }}
          >
            <div id="create-ledger-account-category">Create Category</div>
          </ActionItem>
        )}
        {canUpdateLedgerAccountSettlements && (
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick(
                `/ledgers/${ledgerId}/ledger_account_settlements/new`,
                event,
              );
            }}
          >
            <div id="create-ledger-account-settlement">Create Settlement</div>
          </ActionItem>
        )}
      </PopoverPanel>
    </Popover>
  );
}

function LedgersHeader({
  onTabChange,
  selectedTab,
  ledger,
  entityType,
  entityId,
  ledgerTransactionStatus,
  canUpdateLedgerAccounts = false,
  canUpdateLedgerTransactions = false,
  canUpdateLedgerAccountCategories = false,
  canUpdateLedgerAccountSettlements = false,
  discarded,
  skipActions = false,
}: LedgersHeaderProps) {
  if (!ledger) {
    return (
      <LedgersHeaderSkeletonLoader
        selectedTab={selectedTab}
        onTabChange={onTabChange}
        entityId={entityId}
      />
    );
  }

  return (
    <div className="flex flex-col">
      <div className="flex pb-8">
        <div className="flex w-full justify-between">
          <div className="flex w-full flex-wrap">
            <span className="text-lg">
              <Link to="/ledgers">Ledgers</Link>
            </span>
            {ledger && (
              <>
                <div className="flex self-center px-1">
                  <Icon
                    iconName="forward_slash"
                    color="currentColor"
                    className="text-gray-400"
                  />
                </div>
                {!entityId && (
                  <div className="flex">
                    <span className="max-w-xs overflow-hidden overflow-ellipsis
                    whitespace-nowrap text-lg font-medium mint-lg:max-w-md">
                      {ledger.name || "Ledger"}
                    </span>
                  </div>
                )}
                {entityId && (
                  <>
                    <div className="flex">
                      <a
                        className="max-w-xs overflow-hidden overflow-ellipsis
                        whitespace-nowrap text-lg text-blue-600 no-underline
                        mint-lg:max-w-md"
                        href={`/ledgers/${ledger.id}`}
                      >
                        {ledger.name}
                      </a>
                    </div>
                    <div className="flex self-center px-1">
                      <Icon
                        iconName="forward_slash"
                        color="currentColor"
                        className="text-gray-400"
                      />
                    </div>
                    <span className="max-w-xs overflow-hidden overflow-ellipsis
                    whitespace-nowrap text-lg font-medium mint-lg:max-w-md">
                      {displayName(entityType || "")}
                    </span>
                    {discarded && (
                      <div className="ml-3 max-w-max self-center rounded-sm bg-
                      gray-100 p-1 text-base text-gray-800">
                        Deleted
                      </div>
                    )}
                  </>
                )}
              </>
            )}
          </div>
          {!entityId && !skipActions && (
            <CreateEntitiesDropdown
              canUpdateLedgerAccounts={canUpdateLedgerAccounts}
              canUpdateLedgerTransactions={canUpdateLedgerTransactions}
              canUpdateLedgerAccountCategories={
                canUpdateLedgerAccountCategories
              }
              canUpdateLedgerAccountSettlements={
                canUpdateLedgerAccountSettlements
              }
              ledgerId={ledger.id}
            />
          )}
          {entityId && entityType === "LedgerTransaction" && !skipActions && (
            <div className="justify-end pl-2">
              <Popover>
                <PopoverTrigger buttonHeight="small" hideFocusOutline>
                  <div id="actions">Actions</div>
                  <Icon
                    iconName="caret_down"
                    color="currentColor"
                    className="text-black"
                  />
                </PopoverTrigger>
                <PopoverPanel
                  className="badge-action-dropdown reports-button-panel"
                  anchorOrigin={{ horizontal: "right" }}
                >
                  <ActionItem
                    onClick={(event: ButtonClickEventTypes) => {
                      event?.stopPropagation();
                      handleLinkClick(
                        `/ledger_transactions/${entityId}/edit`,
                        event,
                      );
                    }}
                  >
                    <div id="edit">Edit</div>
                  </ActionItem>
                  {ledgerTransactionStatus === "posted" && (
                    <ActionItem
                      onClick={(event: ButtonClickEventTypes) => {
                        event?.stopPropagation();
                        handleLinkClick(
                          `/ledger_transactions/${entityId}/reverse`,
                          event,
                        );
                      }}
                    >
                      <div id="reverse">Reverse</div>
                    </ActionItem>
                  )}
                </PopoverPanel>
              </Popover>
            </div>
          )}
        </div>
      </div>
      {!entityId && (
        <div className="flex w-full pb-6">
          <Tabs
            selected={selectedTab || ""}
            onClick={
              onTabChange as (tab: string, event: ButtonClickEventTypes) => void
            }
            tabs={{
              [ACCOUNTS_TAB]: "Accounts",
              [TRANSACTION_TAB]: "Transactions",
              [ENTRIES_TAB]: "Entries",
              [ACCOUNT_CATEGORIES_TAB]: "Categories",
              [SETTLEMENTS_TAB]: "Settlements",
              [LEDGERABLE_EVENTS_TAB]: "Ledgerable Events",
            }}
          />
        </div>
      )}
    </div>
  );
}

export default LedgersHeader;
```

---
## `LedgersSVG.tsx.txt`
**Path:** `.`  
```
import React from "react";

function LedgersSVG({ className }: { className?: string }) {
  return (
    <svg
      className={className}
      width="100%"
      height="auto"
      viewBox="0 0 414 207"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <rect x="207" width="207" height="207" fill="#A5B99C" />
      <g>
        <path
          d="M250.999 93.4401H330.999C331.795 93.4401 332.439 92.7961 332.439
          92.0001V52.0001C332.439 51.2041 331.795 50.5601 330.999
          50.5601H250.999C250.203 50.5601 249.559 51.2041 249.559
          52.0001V92.0001C249.559 92.7961 250.203 93.4401 250.999
          93.4401ZM252.439 81.5841C257.103 82.2281 260.771 85.8961 261.415
          90.5601H252.439V81.5841ZM252.439 78.7081V65.2921C258.687 64.6161
          263.615 59.6881 264.291 53.4401H317.703C318.379 59.6881 323.311
          64.6161 329.559 65.2961V78.7081C323.311 79.3881 318.383 84.3161
          317.703 90.5641H264.291C263.615 84.3121 258.687 79.3841 252.439
          78.7081ZM320.587 90.5601C321.231 85.9001 324.895 82.2321 329.559
          81.5841V90.5601H320.587ZM329.559 62.4161C324.895 61.7721 321.231
          58.1041 320.587 53.4401H329.559V62.4161ZM261.415 53.4401C260.771
          58.1001 257.099 61.7721 252.439 62.4161V53.4401H261.415ZM290.999
          85.4401C298.411 85.4401 304.439 79.4121 304.439 72.0001C304.439
          64.5881 298.411 58.5601 290.999 58.5601C283.587 58.5601 277.559
          64.5881 277.559 72.0001C277.559 79.4121 283.587 85.4401 290.999
          85.4401ZM290.999 61.4401C296.823 61.4401 301.559 66.1801 301.559
          72.0001C301.559 77.8201 296.819 82.5601 290.999 82.5601C285.179
          82.5601 280.439 77.8241 280.439 72.0001C280.439 66.1761 285.175
          61.4401 290.999 61.4401ZM370.999 114.56H290.999C290.203 114.56 289.559
          115.204 289.559 116V156C289.559 156.796 290.203 157.44 290.999
          157.44H370.999C371.795 157.44 372.439 156.796 372.439 156V116C372.439
          115.204 371.795 114.56 370.999 114.56ZM369.559 126.412C364.899 125.768
          361.231 122.104 360.587 117.44H369.559V126.412ZM369.559
          129.296V142.704C363.315 143.384 358.383 148.312 357.703
          154.56H304.291C303.611 148.312 298.683 143.384 292.435
          142.704V129.296C298.683 128.62 303.611 123.688 304.291
          117.44H357.703C358.383 123.688 363.311 128.616 369.559
          129.296ZM301.415 117.44C300.771 122.104 297.103 125.768 292.439
          126.412V117.44H301.415ZM292.439 145.588C297.099 146.232 300.767
          149.896 301.415 154.56H292.439V145.588ZM360.587 154.56C361.231 149.9
          364.895 146.232 369.559 145.588V154.56H360.587ZM330.999 122.56C323.587
          122.56 317.559 128.592 317.559 136C317.559 143.408 323.591 149.44
          330.999 149.44C338.407 149.44 344.439 143.408 344.439 136C344.439
          128.592 338.411 122.56 330.999 122.56ZM330.999 146.56C325.175 146.56
          320.439 141.824 320.439 136C320.439 130.176 325.175 125.44 330.999
          125.44C336.823 125.44 341.559 130.176 341.559 136C341.559 141.824
          336.823 146.56 330.999 146.56ZM254.479
          134.56H278.999V137.444H254.479L264.019 146.984L261.983 149.024L248.963
          136L261.983 122.98L264.019 125.02L254.479 134.56ZM367.523
          73.4401H342.999V70.5601H367.523L357.979 61.0161L360.019
          58.9801L373.035 72.0001L360.019 85.0161L357.979 82.9801L367.523
          73.4401Z"
          fill="black"
        />
      </g>
      <rect width="207" height="207" fill="#1B1D1D" />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M110.561 117C110.561 112.893 113.894 109.56 118.001
        109.56H136.001V112.44H118.001C115.494 112.44 113.441 114.493 113.441
        117C113.441 119.507 115.494 121.56 118.001 121.56H130.001C134.107 121.56
        137.441 124.893 137.441 129C137.441 133.107 134.107 136.44 130.001
        136.44H112.001V133.56H130.001C132.507 133.56 134.561 131.507 134.561
        129C134.561 126.493 132.507 124.44 130.001 124.44H118.001C113.894 124.44
        110.561 121.107 110.561 117Z"
        fill="white"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M125.441 103V111H122.561V103H125.441Z"
        fill="white"
      />
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M125.441 135V143H122.561V135H125.441Z"
        fill="white"
      />
      <path
        d="M164.027 112.28C166.907 122.973 165.414 134.147 159.894
        143.72C154.374 153.293 145.414 160.147 134.721 163.027C124.027 165.88
        112.854 164.413 103.281 158.893C90.0005 151.213 82.5605 137.267 82.5605
        122.947C82.5605 115.933 84.3472 108.813 88.1072 102.307C99.5205 82.5201
        124.934 75.7201 144.721 87.1334C154.294 92.6801 161.147 101.613 164.027
        112.307V112.28ZM101.707 91.5601H129.521V94.4401H98.1072C95.2005 97.0534
        92.6672 100.173 90.6139 103.72C86.4539 110.92 84.9072 118.893 85.6272
        126.573L99.5206 102.493L102.027 103.933L86.3472 131.107C88.5605 141.373
        94.9339 150.707 104.747 156.36C105.787 156.973 106.881 157.507 107.947
        158.013L94.0272 133.907L96.5072 132.467L112.214 159.693C119.201 161.96
        126.694 162.147 133.974 160.2C138.481 159 142.641 157.027 146.347
        154.413H118.481V151.533H149.921C152.827 148.893 155.361 145.773 157.387
        142.253C161.547 135.053 163.121 127.08 162.374 119.4L148.481
        143.48L145.974 142.04L161.654 114.867C159.441 104.6 153.067 95.2667
        143.254 89.6134C142.214 89.0001 141.121 88.4401 140.054 87.9601L153.974
        112.067L151.467 113.507L135.761 86.3067C124.107 82.5467 111.441 84.6534
        101.654 91.5867L101.707 91.5601ZM61.3072
        91.5601H84.0005V94.4401H61.3072C60.6139 98.9467 56.7205 102.44 52.0005
        102.44C46.8005 102.44 42.5605 98.2001 42.5605 93.0001C42.5605 87.8001
        46.8005 83.5601 52.0005 83.5601C56.7205 83.5601 60.5872 87.0534 61.3072
        91.5601ZM45.4405 93.0001C45.4405 96.6267 48.3739 99.5601 52.0005
        99.5601C55.6272 99.5601 58.5605 96.6267 58.5605 93.0001C58.5605 89.3734
        55.6272 86.4401 52.0005 86.4401C48.3739 86.4401 45.4405 89.3734 45.4405
        93.0001ZM61.3072 51.5601H120.081C120.587 51.5601 121.067 51.8267 121.334
        52.2801L133.254 72.9201L130.747 74.3601L119.227 54.4401H61.3072C60.6139
        58.9467 56.7205 62.4401 52.0005 62.4401C46.8005 62.4401 42.5605 58.2001
        42.5605 53.0001C42.5605 47.8001 46.8005 43.5601 52.0005 43.5601C56.7205
        43.5601 60.5872 47.0267 61.3072 51.5601ZM45.4405 53.0001C45.4405 56.6267
        48.3739 59.5601 52.0005 59.5601C55.6272 59.5601 58.5605 56.6267 58.5605
        53.0001C58.5605 49.3734 55.6272 46.4401 52.0005 46.4401C48.3739 46.4401
        45.4405 49.3734 45.4405 53.0001ZM61.3072
        131.56H76.0005V134.44H61.3072C60.6139 138.947 56.7205 142.44 52.0005
        142.44C46.8005 142.44 42.5605 138.2 42.5605 133C42.5605 127.8 46.8005
        123.56 52.0005 123.56C56.7205 123.56 60.5872 127.053 61.3072
        131.56ZM45.4405 133C45.4405 136.627 48.3739 139.56 52.0005
        139.56C55.6272 139.56 58.5605 136.627 58.5605 133C58.5605 129.373
        55.6272 126.44 52.0005 126.44C48.3739 126.44 45.4405 129.373 45.4405
        133Z"
        fill="white"
      />
    </svg>
  );
}

export default LedgersSVG;
```

---
## `LineItemsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import reduce from "lodash/reduce";
import { useLineItemsViewQuery } from "../../generated/dashboard/graphqlSchema";
import { CursorPaginationInput } from "../types/CursorPaginationInput";

import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";

function LineItemsView({
  itemizableType,
  itemizableId,
}: {
  itemizableType: string;
  itemizableId: string;
}) {
  const { loading, data, error, refetch } = useLineItemsViewQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: INITIAL_PAGINATION.perPage,
      paymentOrderId:
        itemizableType === "payment_orders" ? itemizableId : undefined,
      expectedPaymentId:
        itemizableType === "expected_payments" ? itemizableId : undefined,
    },
  });

  const lineItems =
    loading || !data || error
      ? []
      : data.lineItems.edges.map(({ node }) => ({
          ...node,
          accountingCategoryName: node.accountingCategory?.name,
          accountingLedgerClassName: node.accountingLedgerClass?.name,
        }));

  const expandedData = reduce(
    lineItems,
    (acc, curr) => {
      acc[curr.id] = [
        { key: "ID", value: curr.id },
        { key: "Description", value: curr.description },
        { key: "Accounting Category", value: curr.accountingCategoryName },
        { key: "Accounting Class", value: curr.accountingLedgerClassName },
        ...(JSON.parse(curr.metadata) as Array<{
          key: string;
          value: string;
        }>),
      ];

      return acc;
    },
    {},
  );

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
    query: unknown;
  }) => {
    const { cursorPaginationParams } = options;
    await refetch({ ...cursorPaginationParams });
  };
  return (
    <EntityTableView
      data={lineItems}
      loading={loading}
      dataMapping={{ amount: "Amount", description: "Description" }}
      styleMapping={{
        amount: "table-entry-small",
      }}
      onQueryArgChange={handleRefetch}
      cursorPagination={data?.lineItems?.pageInfo}
      enableActions={!!expandedData}
      expandedData={expandedData}
    />
  );
}

export default LineItemsView;
```

---
## `ListView.tsx.txt`
**Path:** `.`  
```
import React, { useState, useEffect } from "react";
import ReactTooltip from "react-tooltip";
import {
  useApolloClient,
  DocumentNode,
  ApolloQueryResult,
  ApolloError,
  ApolloClient,
  TypedDocumentNode,
  FetchPolicy,
} from "@apollo/client";
import { debounce, get, isNil, omitBy, isEmpty, merge } from "lodash";
import invariant from "ts-invariant";
import TruncateString from "react-truncate-string";
import { Icons } from "~/common/ui-components/Icon/Icon";
import useView from "~/common/utilities/persisted_views/useView";
import Gon from "~/common/utilities/gon";
import { TABLE_SORT_ACTIONS } from "~/generated/analytics/tableSortEvents";
import { StatusIndicatorStatuses } from "~/common/ui-
components/StatusIndicator/StatusIndicator";
import { getScopedParamName, parseQuery } from "~/common/utilities/queryString";
import {
  DisplayColumnOptions__AssociatedEntityLabelFieldTypeEnum,
  DisplayColumn,
  PageInfo,
  PaymentSubtypeEnum,
  useListViewFiltersQuery,
  ResourceEnum,
} from "~/generated/dashboard/graphqlSchema";
import { getDrawerContent } from "~/common/utilities/getDrawerContent";
import trackEvent from "../../common/utilities/trackEvent";
import { DisplayColumnTypeEnum } from
"../../generated/dashboard/types/displayColumnTypeEnum";
import EntityTableView, {
  cursorPaginationParams as cursorPaginationParamsFn,
  INITIAL_PAGINATION,
  isEmptyQuery,
  RenderSource,
  SharedEntityTableViewProps,
} from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import {
  Amount,
  Countdown,
  DateTime,
  OverflowTip,
  Shortcode,
  StatusIndicator,
  Tag,
  TagColors,
  Pill,
  Drawer,
} from "../../common/ui-components";
import {
  RESOURCES,
  ResourcesEnum,
} from "../../generated/dashboard/types/resources";
import { NestingDataActions } from "../../common/ui-
components/IndexTable/IndexTable";
import { formatPaymentSubtype } from
"../../common/utilities/formatPaymentSubtype";
import useQueryParams from "./filter/useQueryParams";
import {
  FilterType,
  OverrideValue,
  mapLogicalFieldsToFilters,
} from "./filter/util";
import { createPolymorphicAssociation } from
"../utilities/createPolymorphicAssociation";
import { cn } from "~/common/utilities/cn";

export type OverrideCustomColumnValue = {
  [key: string]: {
    default?: boolean;
    hidden?: boolean;
  };
};

/**
 * Computes the displayColumns to show based off the displayColumnIdsToFilter
 * and overrideCustomColumnValue
 */
function computeDisplayColumns(
  data: ResponseType,
  displayColumnIdsToFilter: string[] | undefined,
  graphqlField: string,
  overrideCustomColumnValue: OverrideCustomColumnValue,
) {
  if (!isEmpty(overrideCustomColumnValue)) {
    return data[graphqlField].displayColumns.map((displayColumn) =>
      merge({}, displayColumn, {
        viewOptions: {
          listView: {
            default: !!get(overrideCustomColumnValue, [
              displayColumn.id,
              "default",
            ]),
          },
        },
      }),
    );
  }
  const idsToFilter = new Set(displayColumnIdsToFilter);
  return data[graphqlField].displayColumns.filter(
    (displayColumn) => !idsToFilter.has(displayColumn.id),
  );
}

/**
 * Computes the value from the graphql response based on the column display
 type.
 * Different values are rendered depending on the type defined on the display
 column
 */
function computeValue(
  displayColumn: DisplayColumn,
  node: Node,
): React.ReactNode {
  if (node?.[displayColumn.id] == null) {
    return null;
  }
  let content: React.ReactNode = null;
  let entityLabel: string;
  let tagIconsField: string | null;
  let tagColorsField: string | null;

  switch (displayColumn.type) {
    case DisplayColumnTypeEnum.DisplayColumnTypesAssociation:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "AssociationOption",
      );

      if (
        displayColumn.displayTypeOptions?.associatedEntityLabelFieldType ===
        DisplayColumnOptions__AssociatedEntityLabelFieldTypeEnum.Object
      ) {
        content = (
          <Drawer
            trigger={
              <Pill className="associated-entity z-10" showTooltip={false}>
                {
                  get(node, [
                    displayColumn.displayTypeOptions.associatedEntityLabelField,
                  ]) as string
                }
              </Pill>
            }
            path={get(node, [displayColumn.id, "path"]) as string}
          >
            {getDrawerContent(
              get(node, [displayColumn.id, "typename"]) as string,
              get(node, [displayColumn.id, "id"]) as string,
            )}
          </Drawer>
        );
      } else {
        content = (
          <Drawer
            trigger={
              <Pill className="associated-entity z-10" showTooltip>
                {
                  get(node, [
                    displayColumn.id,
                    displayColumn.displayTypeOptions.associatedEntityLabelField,
                  ]) as string
                }
              </Pill>
            }
            path={get(node, [displayColumn.id, "path"]) as string}
          >
            {getDrawerContent(
              get(node, [displayColumn.id, "typename"]) as string,
              get(node, [displayColumn.id, "id"]) as string,
            )}
          </Drawer>
        );
      }
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAssociationList:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AssociationListOption",
      );
      entityLabel = displayColumn.displayTypeOptions.associatedEntityLabelField;

      content = (get(node, [displayColumn.id]) as object[]).map((entity) => (
        <Drawer
          trigger={
            <div className="mr-1">
              <Pill className="associated-entity z-10" showTooltip>
                {get(entity, entityLabel) as string}
              </Pill>
            </div>
          }
          path={get(entity, ["path"]) as string}
        >
          {getDrawerContent(
            get(entity, ["typename"]) as string,
            get(entity, ["id"]) as string,
          )}
        </Drawer>
      ));
      break;
    case DisplayColumnTypeEnum.SharedTypesScalarsDateTimeType:
      content = <DateTime timestamp={node[displayColumn.id] as string} />;
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesToggled:
      content = node[displayColumn.id] ? "Enabled" : "Disabled";
      break;
    case DisplayColumnTypeEnum.GraphQlTypesBoolean:
      content = node[displayColumn.id] ? "True" : "False";
      break;
    case DisplayColumnTypeEnum.GraphQlTypesInt:
      content = (node[displayColumn.id] as number).toString();
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAmount ||
      DisplayColumnTypeEnum.DisplayColumnTypesLongAmount:
      content = <Amount>{node[displayColumn.id] as string}</Amount>;
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesAmountDifference:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AmountDifferenceOption",
      );
      content = (
        <Amount
          difference={
            get(node, [
              displayColumn.displayTypeOptions
                .highlightAmountDifferenceField as string,
            ]) === true
          }
        >
          {node[displayColumn.id] as string}
        </Amount>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesLongAmountDifference:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "AmountDifferenceOption",
      );
      content = (
        <Amount
          difference={
            get(node, [
              displayColumn.displayTypeOptions
                .highlightAmountDifferenceField as string,
            ]) === true
          }
        >
          {node[displayColumn.id] as string}
        </Amount>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesOrderedList:
      content = (
        <ol>
          {(node[displayColumn.id] as Array<string>).map((element) => (
            <li className="mb-1 mt-1 whitespace-nowrap first:mt-0 last:mb-0">
              <OverflowTip
                message={element}
                className="overflow-hidden overflow-ellipsis"
              >
                {element}
              </OverflowTip>
            </li>
          ))}
        </ol>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesLongText:
      content = (
        <div className="text-xs">{node[displayColumn.id] as string}</div>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesPolymorphicAssociation:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "PolymorphicAssociationOption",
      );
      content = createPolymorphicAssociation(
        node,
        displayColumn.displayTypeOptions.associationPrefix,
        displayColumn.id,
        displayColumn.displayTypeOptions.drawerEnabled ?? false,
        displayColumn.displayTypeOptions.stackedDrawerEnabled ?? false,
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesCountdown:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "CountdownOption",
      );
      content = (
        <Countdown
          type={
            (displayColumn.displayTypeOptions.countdownType as
              | "relative"
              | "timestamp") ?? "timestamp"
          }
          timestamp={node[displayColumn.id] as string}
        />
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesLabelWithCount:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "LabelWithCountOption",
      );
      if ((node[displayColumn.displayTypeOptions.countField] as number) === 0) {
        if (displayColumn.displayTypeOptions.truncateMiddle) {
          content = (
            <div className="w-full pr-4">
              <div data-tip={node[displayColumn.id]}>
                <TruncateString text={node[displayColumn.id]} />
              </div>
              <ReactTooltip
                className="max-w-md text-wrap"
                data-place="top"
                data-effect="float"
                delayShow={200}
                multiline
              />
            </div>
          );
        } else {
          content = node[displayColumn.id] as string;
        }
      } else {
        content = (
          <span>
            {node[displayColumn.id]}
            {(node[displayColumn.displayTypeOptions.countField] as number) >
              0 && (
              <span>
                {" "}
                <span className="text-gray-400">
                  {
                    node[
                      displayColumn.displayTypeOptions.prettyCountField
                    ] as string
                  }
                </span>
              </span>
            )}
          </span>
        );
      }
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesTag:
      invariant(displayColumn.displayTypeOptions?.__typename === "TagOption");
      content = (
        <Tag
          size="small"
          color={
            displayColumn.displayTypeOptions.tagColorField
              ? (node[
                  displayColumn.displayTypeOptions.tagColorField
                ] as TagColors)
              : undefined
          }
          icon={
            displayColumn.displayTypeOptions.tagIconField &&
            node[displayColumn.displayTypeOptions.tagIconField]
              ? {
                  iconName: node[
                    displayColumn.displayTypeOptions.tagIconField
                  ] as Icons,
                  size: "s",
                }
              : undefined
          }
        >
          {node[displayColumn.id] as string}
        </Tag>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesShortcode:
      content = <Shortcode>{node[displayColumn.id] as string}</Shortcode>;
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesTagList:
      invariant(
        displayColumn.displayTypeOptions?.__typename === "TagListOption",
      );
      tagColorsField = displayColumn.displayTypeOptions?.tagColorsField || null;
      tagIconsField = displayColumn.displayTypeOptions?.tagIconsField || null;
      content = (
        <div className="flex flex-wrap gap-y-2">
          {(node[displayColumn.id] as Array<string>).map((element, idx) => (
            <Tag
              className="mr-2"
              size="small"
              color={
                tagColorsField
                  ? (get(node, [tagColorsField, idx]) as TagColors)
                  : undefined
              }
              icon={
                tagIconsField && node[tagIconsField]
                  ? {
                      iconName: get(node, [tagIconsField, idx]) as Icons,
                      size: "s",
                    }
                  : undefined
              }
            >
              {element}
            </Tag>
          ))}
        </div>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicator:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "StatusIndicatorOption",
      );
      content = (
        <StatusIndicator
          currentStatus={
            displayColumn.displayTypeOptions.statusIndicatorCurrentStatusField
              ? (node[
                  displayColumn.displayTypeOptions
                    .statusIndicatorCurrentStatusField
                ] as StatusIndicatorStatuses)
              : "incomplete"
          }
          statusDescriptor={
            displayColumn.displayTypeOptions.statusIndicatorDescriptorField
              ? (node[
                  displayColumn.displayTypeOptions
                    .statusIndicatorDescriptorField
                ] as string)
              : ""
          }
          verbose={
            displayColumn.displayTypeOptions.statusIndicatorVerboseField
              ? (displayColumn.displayTypeOptions
                  .statusIndicatorVerboseField as boolean)
              : false
          }
        />
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicatorWithLabel:
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "StatusIndicatorOption",
      );
      content = (
        <div className="flex gap-1">
          <StatusIndicator
            currentStatus={
              displayColumn.displayTypeOptions.statusIndicatorCurrentStatusField
                ? (node[
                    displayColumn.displayTypeOptions
                      .statusIndicatorCurrentStatusField
                  ] as StatusIndicatorStatuses)
                : "incomplete"
            }
            statusDescriptor={
              displayColumn.displayTypeOptions.statusIndicatorDescriptorField
                ? (node[
                    displayColumn.displayTypeOptions
                      .statusIndicatorDescriptorField
                  ] as string)
                : ""
            }
            verbose={
              displayColumn.displayTypeOptions.statusIndicatorVerboseField
                ? (displayColumn.displayTypeOptions
                    .statusIndicatorVerboseField as boolean)
                : false
            }
          />
          {node[displayColumn.id] as string}
        </div>
      );
      break;
    case DisplayColumnTypeEnum.DisplayColumnTypesLink:
      invariant(displayColumn.displayTypeOptions?.__typename === "LinkOption");
      content = get(node, [
        displayColumn.displayTypeOptions.displayNameField,
      ]) as string;
      break;
    case DisplayColumnTypeEnum.TypesPaymentOrderPaymentSubtypeEnumType:
      content = (
        <Shortcode>
          {formatPaymentSubtype(node[displayColumn.id] as PaymentSubtypeEnum)}
        </Shortcode>
      );

      break;
    default:
      content = node[displayColumn.id] as string;
      break;
  }
  return content;
}

// This is necessary because IndexTable wraps cell contents with the OverflowTip
component, and we want to style that
// component differently depending on the type of the display column.
const computeOverflowStyleMapping = (displayColumns: Array<DisplayColumn>) =>
  displayColumns.reduce<Record<string, string>>((acc, displayColumn) => {
    if (
      displayColumn.type === DisplayColumnTypeEnum.DisplayColumnTypesLongText
    ) {
      acc[displayColumn.id] = cn("line-clamp-3", "h-fit");

      if (displayColumn.displayTypeOptions) {
        invariant(
          displayColumn.displayTypeOptions.__typename === "LongTextOption",
        );
        acc[displayColumn.id] = cn(acc[displayColumn.id], {
          "whitespace-pre-wrap":
            displayColumn.displayTypeOptions.preserveWhitespace,
        });
      }
    } else {
      acc[displayColumn.id] = "truncate";
    }

    return acc;
  }, {});

const computeStyleMapping = (
  styleMapping: Record<string, string>,
  displayColumns: Array<DisplayColumn>,
) => {
  const computedStyleMapping = { ...styleMapping };

  displayColumns.forEach((displayColumn) => {
    if (!computedStyleMapping[displayColumn.id]) {
      computedStyleMapping[displayColumn.id] = "";
    }
    const customLabel = displayColumn.viewOptions.listView?.label;
    // Tag is slightly taller than regular text, adjust padding
    // to account for that
    if (
      displayColumn.type === DisplayColumnTypeEnum.DisplayColumnTypesLongText
    ) {
      computedStyleMapping[displayColumn.id] += " basis-56";
    }
    if (
      displayColumn.type === DisplayColumnTypeEnum.DisplayColumnTypesShortText
    ) {
      computedStyleMapping[displayColumn.id] +=
        " scrollable-shorttext basis-10";
    }
    if (displayColumn.type === DisplayColumnTypeEnum.DisplayColumnTypesTag) {
      computedStyleMapping[displayColumn.id] += " !py-2 flex";
    }
    if (
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesAssociation ||
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesPolymorphicAssociation ||
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesAssociationList
    ) {
      computedStyleMapping[displayColumn.id] +=
        " scrollable-association basis-20 !py-1 !pt-2 items-start";
    }
    if (
      displayColumn.type ===
      DisplayColumnTypeEnum.DisplayColumnTypesAssociationList
    ) {
      computedStyleMapping[displayColumn.id] += " flex-wrap gap-y-2";
    }
    if (
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesShortcode ||
      displayColumn.type ===
        DisplayColumnTypeEnum.TypesPaymentOrderPaymentSubtypeEnumType
    ) {
      computedStyleMapping[displayColumn.id] += " basis-4 scrollable-shortcode";
    }
    if (
      displayColumn.type === DisplayColumnTypeEnum.DisplayColumnTypesAmount ||
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesAmountDifference
    ) {
      computedStyleMapping[displayColumn.id] +=
        " basis-8 justify-end scrollable-amount max-w-30";
    }
    if (
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesLongAmount ||
      displayColumn.type ===
        DisplayColumnTypeEnum.DisplayColumnTypesLongAmountDifference
    ) {
      computedStyleMapping[displayColumn.id] +=
        " basis-8 justify-end scrollable-amount max-w-36";
    }
    if (
      displayColumn.type ===
      DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicatorWithLabel
    ) {
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "StatusIndicatorOption",
      );
      computedStyleMapping[displayColumn.id] +=
        " basis-8 scrollable-amount max-w-20";
    }
    if (
      displayColumn.type ===
      DisplayColumnTypeEnum.DisplayColumnTypesStatusIndicator
    ) {
      invariant(
        displayColumn.displayTypeOptions?.__typename ===
          "StatusIndicatorOption",
      );
      if (
        displayColumn?.displayTypeOptions?.statusIndicatorVerboseField ===
          true &&
        !customLabel
      ) {
        /** Magic number: widest-known Tag to-date in a ListView ("Needs
        Approval") */
        computedStyleMapping[displayColumn.id] +=
          " !min-w-[130px] !shrink-0 !pt-2.5 pb-1";
      } else if (
        !displayColumn?.displayTypeOptions?.statusIndicatorVerboseField &&
        customLabel
      ) {
        computedStyleMapping[displayColumn.id] +=
          " flex-none basis-16 scrollable-status";
      } else {
        computedStyleMapping[displayColumn.id] +=
          " flex-none basis-4 scrollable-status";
      }
    }
    if (
      displayColumn.type === DisplayColumnTypeEnum.SharedTypesScalarsDateType
    ) {
      computedStyleMapping[displayColumn.id] +=
        " basis-8 scrollable-amount max-w-28";
    }
  });
  return computedStyleMapping;
};
type FormatDataType<D> = {
  path?: string;
  metadataJson?: Record<string, string>;
} & D;

function formatData<D extends Record<string, unknown>>(
  data: ResponseType,
  graphqlField: string,
  displayColumns: Array<DisplayColumn>,
  hasNesting?: (node: Node) => boolean,
  computeValueOverride?: {
    [key: string]: (
      displayColumn: DisplayColumn,
      node: Node,
    ) => string | JSX.Element;
  },
  pathOverride?: (node: Node) => string,
): Array<FormatDataType<D>> {
  return data[graphqlField].edges.map<FormatDataType<D>>(({ node }) => ({
    id: node.id,
    typename: node.typename,
    path: pathOverride ? pathOverride(node) : node.path,
    metadataJson: node.metadataJson,
    hasNesting: hasNesting && hasNesting(node),
    ...displayColumns.reduce<D>(
      (acc, displayColumn) => ({
        ...acc,
        [displayColumn.id]: computeValueOverride?.[displayColumn.id]
          ? computeValueOverride?.[displayColumn.id](displayColumn, node)
          : computeValue(displayColumn, node),
      }),
      {} as D,
    ),
  }));
}

async function getNestedData<D extends Record<string, unknown>>(
  client: ApolloClient<object>,
  nestingDocument: DocumentNode,
  nestedRecords: Array<D> = [],
  nestedPaginationInfo: PageInfo | null,
  query: Record<string, unknown>,
  id: string,
  action: NestingDataActions,
  nestingGraphqlField: string,
  displayColumns: Array<DisplayColumn>,
  mapQueryToNestingVariables: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>,
  constantQueryVariables = {},
  hasNesting?: (node: Node) => boolean,
  pathOverride?: (node: Node) => string,
  computeValueOverride?: {
    [key: string]: (
      displayColumn: DisplayColumn,
      node: Node,
    ) => string | JSX.Element;
  },
): Promise<{
  updatedNestedRecords: Array<D>;
  updatedNestedPaginationInfo: PageInfo | null;
}> {
  let updatedNestedRecords: Array<D> = [];
  let updatedNestedPaginationInfo: PageInfo | null = null;
  if (action === NestingDataActions.ResetData) {
    return {
      updatedNestedRecords,
      updatedNestedPaginationInfo,
    };
  }

  const response: ApolloQueryResult<unknown> = await client.query({
    query: nestingDocument,
    variables: {
      id,
      ...mapQueryToNestingVariables(query),
      ...{ first: 10, after: nestedPaginationInfo?.endCursor },
      ...constantQueryVariables,
    },
  });
  const responseData = response.data as ResponseType;

  const { pageInfo } = responseData[nestingGraphqlField];
  updatedNestedPaginationInfo = pageInfo;

  updatedNestedRecords = nestedRecords.concat(
    formatData(
      responseData,
      nestingGraphqlField,
      displayColumns,
      hasNesting,
      computeValueOverride,
      pathOverride,
    ),
  );

  return {
    updatedNestedRecords,
    updatedNestedPaginationInfo,
  };
}

export type Node = {
  id: string;
  path?: string;
  metadataJson: Record<string, string>;
  hasNesting: boolean;
  [key: string]: unknown;
};

type ResponseType = {
  [key: string]: {
    displayColumns: Array<DisplayColumn>;
    edges: Array<{ node: Node }>;
    pageInfo: PageInfo;
  };
};

interface ListViewProps<Q extends Record<string, unknown>>
  extends UIContainerProps {
  computeValueOverride?: {
    [key: string]: (
      displayColumn: DisplayColumn,
      node: Node,
    ) => string | JSX.Element;
  };
  constantQueryVariables?: Record<string, unknown>;
  customizableColumns?: boolean;
  displayColumnIdsToFilter?: string[];
  filterActionExcludedRow?: (node: Record<string, unknown>) => boolean;
  graphqlDocument: DocumentNode;
  hasNesting?: (node: Node) => boolean;
  ListViewEmptyState?: JSX.Element;
  mapQueryToNestingVariables?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  mapQueryToVariables?: (query: Q) => Record<string, unknown>;
  nestingDocument?: DocumentNode;
  nestingResource?: ResourcesEnum;
  onDataChange?: (
    query: Record<string, unknown>,
    data?: Record<string, unknown>,
  ) => void;
  onQueryArgChangeCallback?: (query: Record<string, unknown>) => void;
  pathOverride?: (node: Node) => string;
  resource: ResourcesEnum;
  styleMapping?: Record<string, string>;
  enableNewFilters?: boolean;
  legacyFilterMappers?: {
    queryToFilters: (query: Record<string, unknown>) => Record<string, unknown>;
    queryToGraphqlArguments: (
      query: Record<string, unknown>,
    ) => Record<string, unknown>;
    filtersToLegacyFormat?: (
      query: Record<string, unknown>,
    ) => Record<string, unknown>;
  };
  overrideFilterValue?: OverrideValue;
  refetch?: number | null;
  customViewName?: string;
  overrideCustomColumnValue?: OverrideCustomColumnValue;
  setSelectEverythingCallback?: (selectEverything: boolean) => void;
  totalCount?: number;
}

const onQuerySuccess = (
  setLoading: (loading: boolean) => void,
  onDataChange:
    | ((
        query: Record<string, unknown>,
        data?: Record<string, unknown> | undefined,
      ) => void)
    | undefined,
  graphqlField: string,
  setData: (data: Record<string, unknown> | undefined) => void,
  setFavorites: (favorites: Set<string>) => void,
  resultData: ResponseType,
  variables: Record<string, unknown>,
) => {
  if (onDataChange) {
    onDataChange(variables, resultData);
  }
  const updatedFavoriteIds = resultData[graphqlField]?.edges
    .filter(({ node }) => node.favorited)
    .map(({ node }) => node.id);

  setData(resultData as Record<string, unknown> | undefined);
  setFavorites(new Set([...updatedFavoriteIds]));
  setLoading(false);
};

/**
 * This is used for initial list view query loads to generate a observable
 * object that ApolloCache will subscribe to. We don't want to use this for
 * refetch because we don't need additional subscribers to the query. We want
 * to make this observable to ensure that refetchQueries and other updates to
 * the cache are reflected on the screen without requiring a hard reload.
 */

const executeObservableQuery = (
  setLoading: (loading: boolean) => void,
  setError: (error: ApolloError | undefined) => void,
  onDataChange:
    | ((
        query: Record<string, unknown>,
        data?: Record<string, unknown> | undefined,
      ) => void)
    | undefined,
  client: ApolloClient<unknown>,
  graphqlDocument:
    | DocumentNode
    | TypedDocumentNode<unknown, Record<string, unknown>>,
  graphqlField: string,
  setData: (data: Record<string, unknown> | undefined) => void,
  setFavorites: (favorites: Set<string>) => void,
  fetchPolicy: FetchPolicy,
  variables: Record<string, unknown>,
) => {
  setLoading(true);
  setError(undefined);
  const querySubscription = client
    .watchQuery({
      query: graphqlDocument,
      variables,
      fetchPolicy,
    })
    .subscribe({
      next: (result) => {
        onQuerySuccess(
          setLoading,
          onDataChange,
          graphqlField,
          setData,
          setFavorites,
          result.data as ResponseType,
          variables,
        );
      },
      error: (err: ApolloError) => {
        setError(err);
      },
    });

  return querySubscription;
};

/**
 * Normally we want to use Apollo's provided hooks, however this leads
 * to unforeseen bugs specifically dealing with loading states. When using
 hooks,
 * the `notifyOnNetworkStatusChange` updates the `loading` value whenever a
 graphql
 * query is executing. For some reason this would cause an infinite loop causing
 * this query to continuously re-execute. Calling the query manually allows us
 to
 * have more control over the loading variable and avoid this bug.
 */
const executeQuery = async (
  setLoading: (loading: boolean) => void,
  setError: (error: ApolloError | undefined) => void,
  onDataChange:
    | ((
        query: Record<string, unknown>,
        data?: Record<string, unknown> | undefined,
      ) => void)
    | undefined,
  client: ApolloClient<unknown>,
  graphqlDocument:
    | DocumentNode
    | TypedDocumentNode<unknown, Record<string, unknown>>,
  graphqlField: string,
  setData: (data: Record<string, unknown> | undefined) => void,
  setFavorites: (favorites: Set<string>) => void,
  fetchPolicy: FetchPolicy,
  variables: Record<string, unknown>,
) => {
  setLoading(true);
  setError(undefined);
  const {
    data: responseData,
    error: responseError,
  }: ApolloQueryResult<unknown> = await client.query({
    query: graphqlDocument,
    variables,
    fetchPolicy,
  });
  onQuerySuccess(
    setLoading,
    onDataChange,
    graphqlField,
    setData,
    setFavorites,
    responseData as ResponseType,
    variables,
  );

  setError(responseError);
};

/**
 * Declare the debounced query outside the component scope to prevent
 * re-creating the debounced function on every render.
 */
const debouncedExecuteQuery = debounce(executeQuery, 300, {
  leading: false,
  trailing: true,
});

/**
 * Renders a list of records.
 * Expects a graphql query function which implements a generated "List"
 fragment.
 * The fragment contains all information required to render the list of records.
 */
function ListView<
  Q extends Record<string, unknown>,
  D extends Record<string, unknown>,
>({
  className,
  computeValueOverride,
  constantQueryParams,
  constantQueryVariables = {},
  customizableColumns = true,
  displayColumnIdsToFilter,
  draggableMutation = false,
  filterActionExcludedRow,
  graphqlDocument,
  hasNesting,
  ListViewEmptyState,
  mapQueryToNestingVariables = (query) => query,
  mapQueryToVariables = (query) => query,
  nestingDocument,
  nestingResource,
  onDataChange,
  onQueryArgChangeCallback,
  pathOverride,
  resource,
  styleMapping = {},
  initialQuery = {},
  enableNewFilters = false,
  legacyFilterMappers,
  overrideFilterValue = {},
  refetch,
  customViewName,
  filterIdsToRemove,
  overrideCustomColumnValue = {},
  setSelectEverythingCallback,
  totalCount,
  ...props
}: ListViewProps<Q> & SharedEntityTableViewProps<D>) {
  const {
    ui: { isGhosting },
  } = Gon.gon;

  const [data, setData] = useState<Record<string, unknown> | undefined>(
    undefined,
  );
  const [error, setError] = useState<ApolloError | undefined>(undefined);
  const [loading, setLoading] = useState(true);
  const [nestedRecords, setNestedRecords] = useState<Record<string, Array<D>>>(
    {},
  );
  const [isNestedRecordsLoading, setIsNestedRecordsLoading] = useState<
    Record<string, boolean>
  >({});
  const [nestedPaginationInfo, setNestedPaginationInfo] = useState<
    Record<string, PageInfo | null>
  >({});
  const client = useApolloClient();
  const [getFilters] = useQueryParams();

  const { view, loading: viewLoading } = useView(
    customViewName || `${resource}_list_view`,
  );
  const [favorites, setFavorites] = useState<Set<string>>();

  const graphqlField = RESOURCES[resource].graphql_fields?.list_view;

  const {
    data: filtersData,
    loading: filtersLoading,
    error: filtersError,
  } = useListViewFiltersQuery({
    skip: !enableNewFilters,
    variables: {
      // TODO(stephane-mt): Change the typscript type of `resource`
      // to the generated graphql type `ResourceEnum`.
      resource: resource as ResourceEnum,
    },
  });

  const filters =
    !filtersLoading &&
    !filtersError &&
    filtersData &&
    mapLogicalFieldsToFilters(
      filtersData.logicalFormFields,
      overrideFilterValue,
    );

  // If specifying to refetch manually, bypass cache
  const fetchPolicy = refetch !== undefined ? "network-only" : "cache-first";
  const scopedParamName = getScopedParamName(resource);

  // We need to call the useEffect hook below when either of these values
  change.
  // Since react compares values by reference and not value, an infinite loop
  will occur,
  // when comparing objects. A simple (but slightly hacky) solution is to
  stringify these
  // complex data structures so that they can be compared by value.
  const stringifiedVariables = JSON.stringify(constantQueryVariables);
  const stringifiedParams = JSON.stringify(constantQueryParams);
  useEffect(() => {
    if (!isGhosting && enableNewFilters && !view) {
      return undefined;
    }
    const parsedQuery = parseQuery<Record<string, unknown>>(scopedParamName);
    const query = {
      ...parsedQuery,
      ...(isEmptyQuery(parsedQuery, constantQueryParams ?? [])
        ? initialQuery
        : {}),
    };

    const paginationParams = cursorPaginationParamsFn(
      null,
      query,
      {
        page: query.page || INITIAL_PAGINATION.page,
        perPage: query.perPage || INITIAL_PAGINATION.perPage,
      },
      query.paginationDirection,
    );

    // Default filters set in `overrideFilterValue` prop
    const defaultFilters = Object.keys(overrideFilterValue).reduce(
      (acc, filterId) => {
        if (overrideFilterValue[filterId].default) {
          return {
            ...acc,
            [filterId]: overrideFilterValue[filterId].value,
          };
        }
        return acc;
      },
      {},
    );

    // Filters from url in new format
    let parsedFiltersFromUrl = enableNewFilters
      ? mapQueryToVariables(getFilters(resource) as Q)
      : {};
    if (legacyFilterMappers) {
      // Apply legacy filter if they exist. New format filter take priority
      parsedFiltersFromUrl = omitBy(
        {
          ...legacyFilterMappers.queryToGraphqlArguments(query as Q),
          ...parsedFiltersFromUrl,
        },
        isNil,
      );
    }

    let filtersToApply = {};
    if (!isEmpty(parsedFiltersFromUrl)) {
      filtersToApply = parsedFiltersFromUrl;
    } else {
      filtersToApply = mapQueryToVariables(defaultFilters as Q);
    }

    const args = {
      ...omitBy(mapQueryToVariables(query as Q), isNil),
      ...omitBy(filtersToApply, isNil),
      orderBy: JSON.stringify(query.orderBy),
      favoritesOnly: JSON.parse(
        (query.favoritesOnly || "false") as string,
      ) as boolean,
      ...constantQueryVariables,
      ...paginationParams,
    };

    const subscription = executeObservableQuery(
      setLoading,
      setError,
      onDataChange,
      client,
      graphqlDocument,
      graphqlField,
      setData,
      setFavorites,
      fetchPolicy,
      args,
    );

    return () => {
      subscription.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [resource, stringifiedVariables, stringifiedParams, view, refetch]);

  const handleRefetch = async (
    options: {
      cursorPaginationParams: CursorPaginationInput;
      query: Q;
    },
    debounceQuery,
  ) => {
    setNestedPaginationInfo({});
    setNestedRecords({});
    const { cursorPaginationParams, query } = options;

    let parsedFiltersFromUrl = enableNewFilters
      ? mapQueryToVariables(getFilters(resource) as Q)
      : {};
    if (legacyFilterMappers) {
      parsedFiltersFromUrl = {
        ...legacyFilterMappers.queryToGraphqlArguments(query),
        ...parsedFiltersFromUrl,
      };
    }
    const queryFn = debounceQuery ? debouncedExecuteQuery : executeQuery;

    const queryArgs = {
      ...mapQueryToVariables(query),
      ...parsedFiltersFromUrl,
      orderBy: JSON.stringify(query.orderBy),
      favoritesOnly: JSON.parse(
        (query.favoritesOnly || "false") as string,
      ) as boolean,
      ...cursorPaginationParams,
      ...constantQueryVariables,
    };

    await queryFn(
      setLoading,
      setError,
      onDataChange,
      client,
      graphqlDocument,
      graphqlField,
      setData,
      setFavorites,
      fetchPolicy,
      {
        ...queryArgs,
      },
    );

    if (onQueryArgChangeCallback) {
      onQueryArgChangeCallback(queryArgs);
    }
  };

  invariant(
    graphqlField,
    `The resource you passed to <ListView /> (${resource}) has no corresponding
    graphql field for this component. Did you forget to update resources.rb?`,
  );
  const waitingForData = loading || !data?.[graphqlField] || error;

  const displayColumns = waitingForData
    ? []
    : computeDisplayColumns(
        data as ResponseType,
        displayColumnIdsToFilter,
        graphqlField,
        overrideCustomColumnValue,
      );

  const records: Array<D> = waitingForData
    ? []
    : formatData(
        data as ResponseType,
        graphqlField,
        displayColumns,
        hasNesting,
        computeValueOverride,
        pathOverride,
      );

  const handleNestedRefetch = async (
    query: Record<string, unknown>,
    id: string,
    action: NestingDataActions,
  ) => {
    if (!nestingDocument) return;

    setIsNestedRecordsLoading({
      ...isNestedRecordsLoading,
      [id]: true,
    });

    const { updatedNestedRecords, updatedNestedPaginationInfo } =
      await getNestedData(
        client,
        nestingDocument,
        nestedRecords[id],
        nestedPaginationInfo[id],
        query,
        id,
        action,
        nestingResource !== undefined
          ? RESOURCES[nestingResource]?.graphql_fields?.list_view
          : "",
        displayColumns,
        mapQueryToNestingVariables,
        constantQueryVariables,
        hasNesting,
        pathOverride,
        computeValueOverride,
      );

    setIsNestedRecordsLoading({
      ...isNestedRecordsLoading,
      [id]: false,
    });

    setNestedRecords({
      ...nestedRecords,
      [id]: updatedNestedRecords,
    });

    setNestedPaginationInfo({
      ...nestedPaginationInfo,
      [id]: updatedNestedPaginationInfo,
    });
  };

  const hasMoreNestedData = (id: string) =>
    nestedPaginationInfo[id]?.hasNextPage || false;

  if (
    ListViewEmptyState &&
    !loading &&
    records.length === 0 &&
    isEmptyQuery(
      parseQuery<Record<string, unknown>>(scopedParamName),
      constantQueryParams ?? [],
    )
  ) {
    return <div>{ListViewEmptyState}</div>;
  }

  const actionExcludedRows: string[] =
    waitingForData || typeof filterActionExcludedRow !== "function"
      ? []
      : (data as ResponseType)[graphqlField]?.edges.reduce<Array<string>>(
          (acc, { node }) => {
            if (filterActionExcludedRow(node)) {
              return [...acc, node.id];
            }
            return acc;
          },
          [],
        );

  const draggableRefetchQuery = () =>
    client.query({
      query: graphqlDocument,
      variables: constantQueryVariables,
      fetchPolicy: "network-only",
    });

  return (
    <EntityTableView
      {...props}
      actionExcludedRows={actionExcludedRows}
      className={className}
      cursorPagination={{
        ...(data as ResponseType)?.[graphqlField]?.pageInfo,
      }}
      customizableColumns={customizableColumns}
      data={records}
      displayColumns={displayColumns}
      draggableMutation={draggableMutation}
      draggableRefetch={draggableRefetchQuery}
      enableNewFilters={enableNewFilters}
      favorites={favorites}
      filters={(filters as FilterType[]) || undefined}
      filtersLoading={filtersLoading}
      filtersToLegacyFormat={legacyFilterMappers?.filtersToLegacyFormat}
      hasMoreNestedData={hasMoreNestedData}
      initialQuery={initialQuery}
      isNestedDataLoading={isNestedRecordsLoading}
      legacyQueryToFilters={legacyFilterMappers?.queryToFilters}
      loading={loading || viewLoading}
      nestedData={nestedRecords}
      onNestedQueryArgChange={handleNestedRefetch}
      onQueryArgChange={handleRefetch}
      onSortChange={(columnName) => {
        const eventName = `${resource}_sorted_on_${columnName}`.toUpperCase();
        trackEvent(null, TABLE_SORT_ACTIONS[eventName]);
      }}
      renderDrawerContent={getDrawerContent}
      renderSource={RenderSource.ListView}
      filterIdsToRemove={filterIdsToRemove}
      resource={resource}
      scopedParamName={scopedParamName}
      styleMapping={computeStyleMapping(styleMapping, displayColumns)}
      usingPersistedViews={!isGhosting}
      view={view || undefined}
      nestingResource={nestingResource}
      setSelectEverythingCallback={setSelectEverythingCallback}
      totalCount={totalCount}
      overflowStyleMapping={computeOverflowStyleMapping(displayColumns)}
    />
  );
}
export default ListView;
```

---
## `MetadataInput.tsx.txt`
**Path:** `.`  
```
import React from "react";
import useGetMetadataKeys from "../../common/utilities/useGetMetadataKeys";
import {
  RESOURCES,
  ResourcesEnum,
} from "../../generated/dashboard/types/resources";
import KeyValueInput from "./KeyValueInput";

export type LegacyMetadata = Array<{ key: string; value: string }>;

/* Converts the array returned from `metadata_keys_and_values` to a simple hash
*/
export const formatLegacyMetadata = (metadata: Record<string, string>) =>
  Object.keys(metadata).reduce<Array<{ key: string; value: string }>>(
    (acc, key) => {
      acc.push({
        key,
        value: metadata[key],
      });
      return acc;
    },
    [],
  );

/* Converts a simple hash to an array compatible with `metadata_keys_and_values`
*/
export const parseLegacyMetadata = (metadata: LegacyMetadata | null) =>
  metadata
    ? metadata.reduce(
        (acc, value) => ({ ...acc, [value.key]: value.value }),
        {},
      )
    : [];

interface Props {
  /** When true, allows users to submit an empty metadata form */
  allowNoEntries?: boolean;
  /** When true, both keys and values must be non empty for the pair to be added
  as form data */
  completedValuesAndKeys?: boolean;
  /** When true, the component is disabled */
  disabled?: boolean;
  /** When true, hides the 'Metadata' Label */
  hideLabel?: boolean;
  /** Initial k,v pairs to display */
  initialValues?: Record<string, string>;
  /** Uses inline icon for adding new metadata fields rather than default button
  */
  inlineAddButton?: boolean;
  /** When true, the key and value input fields appear on different rows */
  multiLines?: boolean;
  /** When true, an empty k,v pair appears underneath the k,v pairs from initial
  values */
  noInitialEmptyEntry?: boolean;
  /** Function that fires when user types a character. */
  onChange: (metadata: Record<string, string>) => void;
  /** Underlying backend model used to fetch existing metadata keys from */
  resource: ResourcesEnum;
  /** When true, the metadata key/value pair will always be removed when x is
  pressed.
   * Otherwise, the pair is only removed if the key is not in the initial values
   */
  alwaysDeleteOnRemove?: boolean;
}

const SUGGESTION_LIST_SIZE = 10;

function MetadataInput({
  allowNoEntries = true,
  completedValuesAndKeys = true,
  disabled,
  hideLabel,
  initialValues = {},
  inlineAddButton = false,
  multiLines = false,
  noInitialEmptyEntry = false,
  alwaysDeleteOnRemove = false,
  onChange,
  resource,
}: Props) {
  const [metadataKeys, getMetadataKeys] = useGetMetadataKeys();

  const onKeyChange = (key: string) => {
    void getMetadataKeys({
      variables: {
        first: SUGGESTION_LIST_SIZE,
        key,
        resource: RESOURCES[resource].model,
      },
    });
  };

  return (
    <KeyValueInput
      label="Metadata"
      allowNoEntries={allowNoEntries}
      onChange={onChange}
      suggestions={metadataKeys}
      onKeyChange={onKeyChange}
      completedValuesAndKeys={completedValuesAndKeys}
      disabled={disabled}
      hideLabel={hideLabel}
      initialValues={initialValues}
      inlineAddButton={inlineAddButton}
      multiLines={multiLines}
      noInitialEmptyEntry={noInitialEmptyEntry}
      alwaysDeleteOnRemove={alwaysDeleteOnRemove}
    />
  );
}

export default MetadataInput;
```

---
## `MetadataView.tsx.txt`
**Path:** `.`  
```
import React, { useCallback, useState } from "react";
import { ClipLoader } from "react-spinners";
import isEmpty from "lodash/isEmpty";
import { Field, FieldProps, Form, Formik, FormikHelpers } from "formik";
import { sanitizeMetadata } from "../actions";
import { Button, KeyValueTable, Stack } from "../../common/ui-components";
import MetadataInput from "./MetadataInput";
import { ResourcesEnum } from "../../generated/dashboard/types/resources";

type MetadataViewProps<T> = {
  initialMetadata: { key: string; value: string }[];
  saveEntity?: (metadata: Record<string, string>) => Promise<T>;
  enableActions: boolean;
  resource: ResourcesEnum;
};

function MetadataView<T>({
  initialMetadata,
  enableActions,
  saveEntity,
  resource,
}: MetadataViewProps<T>) {
  const [isAdding, setIsAdding] = useState(false);
  const onSubmit = useCallback(
    (
      metadata: Record<string, string>,
      actions: FormikHelpers<{
        metadata: Record<string, string>;
      }>,
    ) => {
      if (saveEntity) {
        saveEntity(metadata).then(
          () => {
            setIsAdding(false);
            actions.setSubmitting(false);
          },
          () => {},
        );
      }
    },
    [saveEntity],
  );
  const onClick = useCallback(() => setIsAdding(true), []);

  return (
    <Stack className="metadata-view justify-items-start gap-4">
      {!isAdding && isEmpty(initialMetadata) && !enableActions && "No Metadata"}
      {!isAdding && !isEmpty(initialMetadata) && (
        <div className="w-full rounded-md border border-alpha-black-100 bg-white
        p-6">
          <KeyValueTable
            data={initialMetadata}
            copyableData={initialMetadata.map(
              // we are combining the key/value because KeyValueTable does that
              when no dataMapping is passed
              (metadataKv) => metadataKv.key + metadataKv.value,
            )}
          />
        </div>
      )}
      {!isAdding && enableActions && (
        <Button id="update-metadata-btn" onClick={onClick}>
          Add or Update Metadata
        </Button>
      )}
      {isAdding && enableActions && (
        <Formik
          initialValues={{ metadata: {} }}
          onSubmit={(
            values: { metadata: Record<string, string> },
            actions: FormikHelpers<{ metadata: Record<string, string> }>,
          ) => onSubmit(values.metadata, actions)}
        >
          {({ isSubmitting }) => (
            <Form>
              <Field name="metadata">
                {({
                  form,
                }: FieldProps<{ metadata: Record<string, string> }>) => (
                  <MetadataInput
                    onChange={(value) => {
                      void form.setFieldValue("metadata", value);
                    }}
                    initialValues={sanitizeMetadata(initialMetadata)}
                    resource={resource}
                    completedValuesAndKeys={false}
                    noInitialEmptyEntry={
                      Object.keys(sanitizeMetadata(initialMetadata)).length > 0
                    }
                  />
                )}
              </Field>
              <Button
                id="save-metadata-btn"
                buttonType="primary"
                isSubmit
                disabled={isSubmitting}
                className="mt-2"
              >
                Save
              </Button>
              <ClipLoader loading={isSubmitting} />
            </Form>
          )}
        </Formik>
      )}
    </Stack>
  );
}

export default MetadataView;
```

---
## `MoveMoneyDropdown.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Icon,
  Popover,
  ActionItem,
  PopoverPanel,
  PopoverTrigger,
  ButtonClickEventTypes,
} from "../../common/ui-components";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";

export default function MoveMoneyDropdown() {
  return (
    <div id="move-money-dropdown" className="flex-end">
      <Popover>
        <PopoverTrigger buttonType="primary">
          Move Money
          <Icon
            iconName="chevron_down"
            size="s"
            color="currentColor"
            className="text-white"
          />
        </PopoverTrigger>
        <PopoverPanel anchorOrigin={{ horizontal: "right" }}>
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick("/payment_orders/new", event);
            }}
          >
            <div id="counterparty">Create a Payment Order</div>
          </ActionItem>
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick("/payment_orders/bulk_imports/new", event);
            }}
          >
            <div id="counterparty">Create a Bulk Payment Order</div>
          </ActionItem>
          <ActionItem
            onClick={(event: ButtonClickEventTypes) => {
              handleLinkClick("/sweeps/new", event);
            }}
          >
            <div id="bulk-counterparty">Create a Sweep Rule</div>
          </ActionItem>
        </PopoverPanel>
      </Popover>
    </div>
  );
}
```

---
## `MultiUserSelect.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useMultiUserSelectLazyQuery } from
"../../generated/dashboard/graphqlSchema";
import { AsyncSelectField } from "../../common/ui-components";
import type { SelectValue, SelectAction } from "../../common/ui-components";

interface MultiUserSelectProps {
  onChange: (value: SelectValue | SelectValue[], action: SelectAction) => void;
  selectedUserIds?: string[];
  label?: string;
  disabled?: boolean;
}

function MultiUserSelect({
  onChange,
  selectedUserIds,
  label,
  disabled,
}: MultiUserSelectProps) {
  const [oldInputValue, setOldInputValue] = useState<string | null>(null);
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [nextSearchCursor, setNextSearchCursor] = useState<string | null>(null);
  const [userOptions, setUserOptions] = useState<Array<SelectValue>>([]);

  const [getMultiUserSelectQuery] = useMultiUserSelectLazyQuery();

  const loadOptions = (inputValue: string) =>
    new Promise((resolve, reject) => {
      const cleanedValue = inputValue.replace(/,/g, "");
      const scrollingCursor = cleanedValue ? null : nextCursor;
      getMultiUserSelectQuery({
        variables: {
          first: 10,
          after:
            inputValue &&
            // This query is loading the next 25 users from the same search
            inputValue === oldInputValue
              ? nextSearchCursor
              : // This query is a fresh search if it has an input value, or due
              to scrolling if not
                scrollingCursor,
          searchTerm: cleanedValue,
          userIds: selectedUserIds || [],
        },
      })
        .then(({ data }) => {
          if (data) {
            const currentValues = userOptions.map((o) => o.value);
            // Create user options
            const newUserOptions = [
              ...data.organizationUsers.edges.map((edge) => ({
                value: edge.node.user.id,
                label: `${edge.node.user.name ?? ""} (${edge.node.user.email})`,
              })),
            ];

            // If we have an initial selection, add the user to the list if it
            doesn't already exist
            if (data.usersUnpaginated && selectedUserIds) {
              const combinedValues = [...userOptions, ...newUserOptions].map(
                (o) => o.value,
              );
              data.usersUnpaginated
                .filter(
                  (user) =>
                    selectedUserIds?.includes(user.id) &&
                    !combinedValues.includes(user.id),
                )
                .forEach((user) => {
                  newUserOptions.push({
                    value: user.id,
                    label: `${user.name ?? ""} (${user.email})`,
                  });
                });
            }

            // Cache the options
            setUserOptions([
              ...newUserOptions.filter((o) => !currentValues.includes(o.value)),
              ...userOptions,
            ]);
            // If the results are from a search then save next cursor for the
            following graphql query
            if (inputValue) {
              if (inputValue !== oldInputValue) setOldInputValue(inputValue);
              setNextSearchCursor(
                data.organizationUsers.pageInfo.endCursor ?? null,
              );
            } else {
              // Clear search cursor
              setNextSearchCursor(null);
              // The results are from scrolling so, save next cursor for the
              following graphql query
              setNextCursor(data.organizationUsers.pageInfo.endCursor ?? null);
            }

            // Return the options to react-select
            resolve({
              hasMore: data.organizationUsers.pageInfo.hasNextPage,
              options: newUserOptions,
            });
          }
        })
        .catch((e) => reject(e));
    });

  const options: Array<SelectValue> = [...userOptions];
  let selectedOptions: SelectValue[] = [];
  if (selectedUserIds && selectedUserIds.length > 0) {
    selectedOptions = options.filter(
      (o) => selectedUserIds?.includes(o.value as string),
    );
  }

  return (
    <AsyncSelectField
      placeholder="Select User"
      name="multi-user-select"
      loadOptions={loadOptions}
      handleChange={onChange}
      selectValue={selectedOptions}
      label={label}
      disabled={disabled}
      isMulti
      isClearable
      defaultOptions
    />
  );
}

export default MultiUserSelect;
```

---
## `NavigationBar.tsx.txt`
**Path:** `.`  
```
import React, { useEffect, useState } from "react";
import { useLocation } from "react-router-dom";
import { matchPath } from "react-router";
import resolveConfig from "tailwindcss/resolveConfig";
import { debounce } from "lodash";
import Gon from "~/common/utilities/gon";
import { Clickable, Icon } from "~/common/ui-components";
import LogoModernTreasurySymbol from "~/common/ui-
components/Assets/LogoModernTreasurySymbol";
import { cn } from "~/common/utilities/cn";
import hiddenNavbarRoutes from "~/common/utilities/hiddenNavbarRoutes";
import {
  ViewDocumentTypeEnum,
  useUpsertViewDocumentMutation,
} from "~/generated/dashboard/graphqlSchema";
import SettingsNavigationMenu from "./navigation_bar/SettingsNavigationMenu";
import RootNavigationMenu from "./navigation_bar/RootNavigationMenu";
import { LinkType } from "./NavigationLink";
import tailwindConfig from "../../../../../tailwind.config";

const fullConfig = resolveConfig(tailwindConfig);

const INITIAL_MENU = "initial";
const ROOT_MENU = "root";
const SETTINGS_MENU = "settings";
type CurrentNavigationMenu = "root" | "settings";

function navigationRenderStyle(navBar): CurrentNavigationMenu {
  if (
    SETTINGS_MENU === navBar ||
    (navBar === INITIAL_MENU && window.location.pathname.includes("/settings/"))
  ) {
    return SETTINGS_MENU;
  }
  return ROOT_MENU;
}

type NavigationBarProps = {
  onLogoutClick: () => void;
  organizationName: string;
  navigationLinks: {
    primary_links: Array<LinkType>;
    secondary_links: Array<LinkType>;
    tertiary_links: Array<LinkType>;
    settings_links: Array<LinkType>;
  };
  toggleLiveMode: () => void;
  isOrganizationLive: boolean;
  onGhostLogoutClick: () => void;
  isGhosting: boolean;
};

function useHideNavbar() {
  const location = useLocation();
  return hiddenNavbarRoutes.some((path) => {
    const match = matchPath(location.pathname, {
      path,
      exact: true,
      strict: false,
    });
    return match !== null;
  });
}

function NavigationBar(props: NavigationBarProps) {
  const {
    ui: { navBarView },
  } = Gon.gon;
  const [navBar, setNavBar] = useState(INITIAL_MENU);
  const [showMobileNav, setShowMobileNav] = useState(false);
  const [isNavCollapsed, setIsNavCollapsed] = useState(
    navBarView ? navBarView.collapsed : false,
  );
  const [collapsedPreviewSection, setCollapsedPreviewSection] = useState<
    string | null
  >(null);
  const [upsertViewDocument] = useUpsertViewDocumentMutation();

  // Since the mobile nav uses the same UI as the regular nav,
  // we need to un-collapse the navbar when the mobile nav is active.
  useEffect(() => {
    window.addEventListener(
      "resize",
      debounce(() => {
        if (
          window.innerWidth <=
          parseInt(fullConfig.theme.screens["mint-md"] as string, 10)
        ) {
          setIsNavCollapsed(false);
        }
      }, 100),
    );
  }, []);

  const hideNavbar = useHideNavbar();

  const renderNavigationMenu = () => {
    switch (navigationRenderStyle(navBar)) {
      case SETTINGS_MENU:
        return (
          <SettingsNavigationMenu
            {...props}
            collapsed={isNavCollapsed}
            setCollapsedPreviewSection={setCollapsedPreviewSection}
            collapsedPreviewSection={collapsedPreviewSection}
          />
        );
      case ROOT_MENU:
        return (
          <RootNavigationMenu
            {...props}
            collapsed={isNavCollapsed}
            setNavBar={() => {
              setNavBar(SETTINGS_MENU);
              setCollapsedPreviewSection(null);
            }}
            setCollapsedPreviewSection={setCollapsedPreviewSection}
            collapsedPreviewSection={collapsedPreviewSection}
          />
        );
      default:
        return (
          <RootNavigationMenu
            {...props}
            collapsed={isNavCollapsed}
            setNavBar={() => setNavBar(SETTINGS_MENU)}
            setCollapsedPreviewSection={setCollapsedPreviewSection}
            collapsedPreviewSection={collapsedPreviewSection}
          />
        );
    }
  };

  return (
    <div className="relative h-full">
      {!hideNavbar && (
        <>
          <div className="hidden mint-md:block">
            <button
              onClick={() => {
                setIsNavCollapsed(!isNavCollapsed);
                setCollapsedPreviewSection(null);
                if (navBarView && navBarView.viewId) {
                  void upsertViewDocument({
                    variables: {
                      input: {
                        input: {
                          document: JSON.stringify({
                            collapsed: !isNavCollapsed,
                          }),
                          viewDocumentType: ViewDocumentTypeEnum.NavigationBar,
                          viewId: navBarView.viewId,
                        },
                      },
                    },
                  });
                }
              }}
              className="absolute -right-3 top-14 z-10 flex h-6 w-6 items-center
              justify-center rounded-full bg-gray-700 !p-0"
              type="button"
            >
              <Icon
                iconName={
                  !isNavCollapsed
                    ? "double_chevron_left"
                    : "double_chevron_right"
                }
                className="text-white"
                color="currentColor"
                size="s"
              />
              <div className="sr-only">
                {isNavCollapsed ? "Collapse" : "Expand"}
              </div>
            </button>
          </div>
          <div className="z-50 grid w-full grid-cols-2 items-center justify-
          items-end rounded-md border-b border-alpha-black-100 bg-white px-6
          py-4 mint-md:hidden">
            <div className="-mr-2.5 h-5 w-5">
              <LogoModernTreasurySymbol />
            </div>
            <Clickable onClick={() => setShowMobileNav(!showMobileNav)}>
              <div
                className={cn(
                  "-m-0.5 flex items-center p-0.5 transition-all duration-75
                  ease-in-out hover:bg-gray-50 active:bg-gray-100",
                  showMobileNav && "bg-gray-50",
                )}
              >
                <Icon
                  className="text-gray-700"
                  color="currentColor"
                  iconName={showMobileNav ? "clear" : "menu_hamburger"}
                />
              </div>
            </Clickable>
          </div>
          <div
            className={cn(
              "grid h-full grid-rows-[0fr] bg-gray-900 transition-all
              duration-150 ease-in-out mint-md:block mint-md:max-h-screen mint-
              md:transition-none",
              showMobileNav && "grid-rows-[1fr]",
            )}
            id="application-sidebar"
          >
            <div className="overflow-hidden mint-md:h-full mint-md:overflow-
            visible">
              {renderNavigationMenu()}
            </div>
          </div>
        </>
      )}
    </div>
  );
}

export default NavigationBar;
```

---
## `NavigationLink.tsx.txt`
**Path:** `.`  
```
import React, { RefObject, useCallback, useRef, useState } from "react";
import { Link, NavLink, useLocation } from "react-router-dom";
import { cn } from "~/common/utilities/cn";
import {
  NewFlag,
  Clickable,
  Icon,
  Stack,
  type IconProps,
} from "../../common/ui-components";
import isNewAppNav from "../utilities/newAppNavigation";
import { useHandleLinkClick } from "../../common/utilities/handleLinkClick";

function testId(text: string) {
  return text.replace(/\s/g, "");
}

/**
 * Determines if the provided path exactly matches the current pathname
 * or is a direct child of it.
 */
function isCurrentPath(currentPathname: string, path: string) {
  // Normalize paths by removing query params and trailing slashes
  const normalizePath = (p: string) => p.split("?")[0].replace(/\/$/, "");
  const currentSegments = normalizePath(currentPathname).split("/");
  const targetSegments = normalizePath(path).split("/");

  if (currentSegments.length < targetSegments.length) {
    return false;
  }

  return targetSegments.every(
    (segment, index) => currentSegments[index] === segment,
  );
}

function linkActive(
  currentPathname: string,
  linkPath: string | undefined,
  subpaths: Array<string> = [],
) {
  if (linkPath === "/") {
    return currentPathname === linkPath;
  }
  const paths = linkPath ? [linkPath, ...subpaths] : subpaths;
  return paths.some((path) => isCurrentPath(currentPathname, path));
}

export function sectionSelected(
  currentPathname: string,
  path: string,
): boolean {
  if (path === "/") {
    return currentPathname === path;
  }
  return isCurrentPath(currentPathname, path);
}

function subsectionActive(
  currentPathname: string,
  subsections: Array<SubsectionType>,
) {
  return (
    subsections &&
    (subsections.some((subsection) =>
      isCurrentPath(currentPathname, subsection.path),
    ) ||
      subsections
        .flatMap((subection) => subection.subpaths)
        .some((subpath) => subpath && isCurrentPath(currentPathname, subpath)))
  );
}

type SubsectionType = {
  path: string;
  onClickOverride?: () => void;
  icon?: string;
  text: string;
  subpaths?: Array<string>;
};

export type LinkType = {
  text: string;
  path: string;
  subpaths?: Array<string>;
  newBadge?: boolean;
  subsections?: Array<SubsectionType>;
  icon?: IconProps["iconName"];
  user_pilot_tour_id?: string;
  rightText?: string;
  onClickOverride?: () => void;
};

export interface NavigationLinkProps {
  link: LinkType;
  alwaysExpanded: boolean;
  collapsed: boolean;
  srOnly?: boolean;
  setCollapsedPreviewSection: (section: string | null) => void;
  collapsedPreviewSection: string | null;
}

type LocationType = {
  hash: string;
  pathname: string;
  search: string;
};

function setLinkPath(linkPath: string | undefined) {
  if (isNewAppNav() && linkPath && !linkPath.includes("newnav")) {
    // this is to account for paths that have parameters and therefore need
    "newnav" to be added as an additional
    // parameter with &. This feels like it should probably be done is a safer
    way.
    return linkPath.includes("?")
      ? `${linkPath}&newnav=true`
      : `${linkPath}?newnav=true`;
  }
  return linkPath;
}

function CollapsedPreviewSection({
  subsections,
  onMouseEnter,
  onMouseLeave,
  linkRef,
}: {
  subsections: Array<SubsectionType>;
  onMouseEnter: () => void;
  onMouseLeave: () => void;
  linkRef: RefObject<HTMLDivElement>;
}) {
  const location = useLocation();

  const handleLinkClick = useHandleLinkClick();

  return (
    <div
      className="absolute left-full z-10 -ml-2 pl-2 transition-all duration-150
      ease-in-out"
      style={{
        left: "calc(100% + 4px)",
        top:
          linkRef && linkRef.current
            ? linkRef.current.getBoundingClientRect().top
            : "",
      }}
      onMouseLeave={(e) => {
        if (
          e.relatedTarget &&
          typeof (e.relatedTarget as HTMLElement).id === "string" &&
          !(e.relatedTarget as HTMLElement).id.includes("navigation-link")
        ) {
          onMouseLeave();
        }
      }}
      onMouseEnter={onMouseEnter}
    >
      <div className="min-w-max rounded-sm bg-gray-900 px-2 py-2 ">
        <div className="flex flex-col flex-nowrap gap-1">
          {subsections.map((section, index) => (
            <Link
              to={section.path}
              onClick={(e) => {
                // Prevents the onClick handler of the parent section from
                firing
                e.stopPropagation();
                // Prevents flickering when SPA is not enabled.
                // Prevents the page from changing due to the `to` prop
                e.preventDefault();
                handleLinkClick(section.path, e);
              }}
              key={index}
              className={cn(
                "rounded-sm px-2 py-1 hover:bg-mist-700 hover:text-white",
                linkActive(location.pathname, section.path)
                  ? "bg-mist-700 text-white"
                  : "text-gray-200",
              )}
            >
              {section.text}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
}

function NavigationLink({
  link: {
    text,
    path,
    newBadge,
    subsections,
    icon,
    user_pilot_tour_id,
    rightText,
    onClickOverride,
  },
  collapsed,
  alwaysExpanded,
  srOnly,
  setCollapsedPreviewSection,
  collapsedPreviewSection,
}: NavigationLinkProps) {
  const ref = useRef(null);
  const location = useLocation();
  const handleLinkClick = useHandleLinkClick();
  const [previewSection, setPreviewSection] = useState(false);
  const isActive = linkActive(
    location.pathname,
    path,
    subsections?.map((section) => section.path),
  );

  const linkComponentFactory = useCallback(
    () => (
      <a
        className="flex items-center no-underline"
        href={path}
        id={testId(text)}
      >
        <div className="flex h-5 w-5 items-center justify-center">
          {icon && (
            <Icon
              className={cn(isActive ? "text-white" : "text-gray-200")}
              iconName={icon}
              color="currentColor"
              size="s"
            />
          )}
        </div>
        <span
          className={cn(
            "px-2",
            isActive ? "text-white" : "text-gray-200",
            collapsed && srOnly && "sr-only",
          )}
        >
          {text}
        </span>
        {newBadge && !collapsed && <NewFlag className="flex" />}
      </a>
    ),
    [isActive, newBadge, icon, path, text, collapsed, srOnly],
  );

  const handleMouseLeave = (e: React.MouseEvent) => {
    if (
      collapsed &&
      e.relatedTarget &&
      typeof (e.relatedTarget as HTMLElement).className === "string" &&
      (e.relatedTarget as HTMLElement).className.includes(
        "navbar-mouseleave-target",
      )
    ) {
      setCollapsedPreviewSection(null);
    }
  };

  function processLinkPath(
    e: React.MouseEvent | React.KeyboardEvent,
    linkPath: string | undefined,
  ) {
    e.preventDefault();
    const finalPath = setLinkPath(linkPath);
    handleLinkClick(finalPath || "/", e);
  }

  const listGroupItemClasses =
    "flex py-1.5 px-2 items-center cursor-pointer hover:bg-mist-700 rounded";

  if (subsections) {
    return (
      <>
        <Clickable
          onClick={(e) => {
            if (!collapsed) {
              setPreviewSection(!previewSection);
            } else {
              processLinkPath(e, subsections[0].path);
            }
          }}
          id="navigation-link"
        >
          <div
            ref={ref}
            className={cn(
              listGroupItemClasses,
              "w-full",
              !collapsed &&
                alwaysExpanded &&
                "!pointer-events-none !bg-transparent",
              "justify-between",
              collapsed && subsectionActive(location.pathname, subsections)
                ? "bg-mist-700 text-white"
                : "text-gray-200",
            )}
            id={user_pilot_tour_id}
            onMouseEnter={() => {
              if (collapsed) {
                setCollapsedPreviewSection(text);
              }
            }}
            onMouseLeave={handleMouseLeave}
          >
            <div className="flex items-center">
              <div className="flex h-5 w-5 items-center justify-center">
                {icon && (
                  <Icon
                    className="text-gray-200"
                    color="currentColor"
                    iconName={icon}
                    size="s"
                  />
                )}
              </div>
              <div
                className={cn(
                  "flex w-32 overflow-hidden overflow-ellipsis whitespace-nowrap
                  px-2 text-gray-200",
                  collapsed && "sr-only",
                )}
                id={testId(text)}
              >
                {text}
                <div className="ml-1.5 mt-0.5 flex h-fit w-fit items-center">
                  {newBadge && <NewFlag className="flex" />}
                </div>
              </div>
            </div>
            {!collapsed && !alwaysExpanded && (
              <div className="flex h-5 w-5 items-center justify-center">
                <div
                  className={cn(
                    "flex transition-transform duration-200 ease-in-out",
                    subsectionActive(location.pathname, subsections) ||
                      previewSection
                      ? "rotate-180"
                      : "rotate-0",
                  )}
                >
                  <Icon
                    className="text-gray-200"
                    color="currentColor"
                    iconName="chevron_down"
                    size="s"
                  />
                </div>
              </div>
            )}
            {collapsed && collapsedPreviewSection === text && (
              <CollapsedPreviewSection
                onMouseEnter={() => setCollapsedPreviewSection(text)}
                onMouseLeave={() => setCollapsedPreviewSection(null)}
                subsections={subsections}
                linkRef={ref}
              />
            )}
          </div>
        </Clickable>
        {(alwaysExpanded ||
          previewSection ||
          subsectionActive(location.pathname, subsections)) &&
          !collapsed && (
            <Stack className="gap-1">
              {subsections.map((section) => (
                <NavLink
                  key={section.text}
                  onClick={(e) => {
                    setCollapsedPreviewSection(null);
                    if (section.onClickOverride) {
                      section.onClickOverride();
                    } else {
                      processLinkPath(e, section.path);
                    }
                  }}
                  to={section.path}
                  className={cn(
                    "rounded py-1.5 pl-9 no-underline hover:bg-mist-700
                    hover:text-gray-100",
                    linkActive(
                      location.pathname,
                      section.path,
                      section.subpaths || [],
                    )
                      ? "bg-mist-700 text-white"
                      : "text-gray-200",
                  )}
                  id={testId(section.text)}
                >
                  {section.text}
                </NavLink>
              ))}
            </Stack>
          )}
      </>
    );
  }

  function doClickOverride(e: React.MouseEvent | React.KeyboardEvent) {
    e.preventDefault();
    if (!onClickOverride) return;
    onClickOverride();
  }

  return (
    <Clickable
      onClick={(e) =>
        onClickOverride ? doClickOverride(e) : processLinkPath(e, path)
      }
      id="navigation-link"
    >
      <div
        className={cn(
          "flex items-center no-underline",
          listGroupItemClasses,
          "w-full",
          {
            "rounded bg-mist-700 text-gray-25": isActive,
          },
        )}
        id={user_pilot_tour_id}
        onMouseEnter={() => {
          if (collapsed) {
            setCollapsedPreviewSection(text);
          }
        }}
        onMouseLeave={handleMouseLeave}
      >
        <Link
          to={(linkLocation: LocationType) => ({
            ...linkLocation,
            pathname: path,
          })}
          component={linkComponentFactory}
        />
        {collapsed && rightText && (
          <div className="ml-auto flex w-fit items-center text-gray-200">
            {rightText}
          </div>
        )}
        {collapsed && collapsedPreviewSection === text && (
          <CollapsedPreviewSection
            onMouseEnter={() => setCollapsedPreviewSection(text)}
            onMouseLeave={() => setCollapsedPreviewSection(null)}
            subsections={[
              {
                path,
                text,
              },
            ]}
            linkRef={ref}
          />
        )}
      </div>
    </Clickable>
  );
}

export default NavigationLink;
```

---
## `OffboardOrganizationButton.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { Button, ConfirmModal } from "../../common/ui-components";
import { useAdminOffboardOrganizationMutation } from
"../../generated/dashboard/graphqlSchema";
import { useDispatchContext } from "../MessageProvider";

interface OffboardOrganizationButtonProps {
  organizationId: string;
  organizationName: string;
  organizationLive: boolean;
}

function OffboardOrganizationButton({
  organizationId,
  organizationName,
  organizationLive,
}: OffboardOrganizationButtonProps) {
  const { dispatchSuccess, dispatchError } = useDispatchContext();

  const [isModalOpen, setIsModalOpen] = useState(false);

  const [adminOffboardOrganization, { loading: isOffboarding }] =
    useAdminOffboardOrganizationMutation();

  const handleOffboardOrganization = () => {
    adminOffboardOrganization({
      variables: { input: { organizationId } },
    })
      .then((result) => {
        if (result.errors) {
          dispatchError("Organization was not successfully offboarded.");
        } else {
          window.location.href = "/admin/organizations";
          dispatchSuccess("Organization successfully offboarded.");
        }
      })
      .catch((err: Error) => {
        dispatchError(err.message);
      })
      .finally(() => setIsModalOpen(false));
  };
  return (
    <>
      <ConfirmModal
        isOpen={isModalOpen}
        setIsOpen={setIsModalOpen}
        title={`Are you sure you want to offboard ${
          organizationName ?? "this organization"
        }?`}
        confirmDisabled={isOffboarding}
        onConfirm={handleOffboardOrganization}
      >
        This action will remove connections to all banks, deactivate all
        products, deactivate any live mode API keys, and revoke organization
        live mode. This action is irreversible.
      </ConfirmModal>
      {organizationLive && (
        <Button
          buttonType="destructive"
          onClick={() => setIsModalOpen(true)}
          disabled={isOffboarding}
        >
          Offboard {organizationName}
        </Button>
      )}
    </>
  );
}

export default OffboardOrganizationButton;
```

---
## `OperationalStatusBadge.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Badge, BadgeType } from "~/common/ui-components";
import { OperationalStatusEnum } from "~/generated/dashboard/graphqlSchema";

export interface OperationalStatusBadgeProps {
  status: OperationalStatusEnum;
  discarded?: boolean;
}

function OperationalStatusBadge({
  status,
  discarded,
}: OperationalStatusBadgeProps) {
  let badgeType: BadgeType;
  let text: string;
  if (discarded) {
    text = "Deleted";
    badgeType = BadgeType.Critical;
  } else {
    text = status as string;
    if (status === OperationalStatusEnum.Operational) {
      badgeType = BadgeType.Success;
    } else if (status === OperationalStatusEnum.Deactivated) {
      badgeType = BadgeType.Critical;
    } else {
      badgeType = BadgeType.Cool;
    }
  }
  return <Badge text={text?.toUpperCase()} type={badgeType} />;
}

export default OperationalStatusBadge;
```

---
## `OrgSwitcher.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useDispatch } from "react-redux";
import partition from "lodash/partition";
import { cn } from "~/common/utilities/cn";
import { logOut } from "../actions/sessions";
import {
  ButtonClickEventTypes,
  Clickable,
  Icon,
  Input,
} from "../../common/ui-components";
import Gon from "../../common/utilities/gon";
import { useDispatchContext } from "../MessageProvider";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";

interface OrganizationRowProps {
  selected?: boolean;
  name: string;
  id: string;
}

function OrganizationRow({ selected = false, name, id }: OrganizationRowProps) {
  const onRowClick = (event: ButtonClickEventTypes) => {
    handleLinkClick(`/auth/organizations/${id}`, event);
  };
  const rowId = `org-switcher-row-${id}`;
  return (
    <Clickable id={rowId} onClick={onRowClick}>
      <div
        className={cn(
          "flex items-center rounded-md p-2 hover:bg-mist-700",
          selected ? "bg-mist-700 text-white" : "text-gray-200",
        )}
      >
        <div className="flex w-full justify-between">
          <div
            className={cn(
              "w-40 overflow-hidden overflow-ellipsis whitespace-nowrap font-
              medium",
              selected ? "w-40" : "w-44",
            )}
          >
            {name}
          </div>
          {selected && (
            <div className={cn(selected ? "text-white" : "text-gray-200")}>
              <Icon
                iconName="done"
                size="s"
                color="currentColor"
                alignment="baseline"
              />
            </div>
          )}
        </div>
      </div>
    </Clickable>
  );
}

const organizationMatchesSearch = (
  organizationName: string,
  searchValue: string,
) => {
  if (!searchValue) {
    return true;
  }
  return organizationName
    .toLocaleLowerCase()
    .includes(searchValue.toLocaleLowerCase());
};

function OrgSwitcher({ onClose }: { onClose: () => void }) {
  const dispatch = useDispatch();
  const [searchValue, setSearchValue] = useState("");
  const { dispatchError } = useDispatchContext();

  const {
    organization: currentOrganization,
    ui: { organizations, isGhosting },
  } = Gon.gon;

  const onLogoutClick = () => {
    dispatch(logOut(dispatchError));
  };

  const onXClick = () => {
    if (searchValue) {
      setSearchValue("");
    } else {
      onClose();
    }
  };

  const [[selectedOrg], unselectedOrgs] = partition(
    organizations,
    (organization) => organization.id === currentOrganization?.id,
  );

  const noSearchResults = !organizations.some((organization) =>
    organizationMatchesSearch(organization.name, searchValue),
  );
  return (
    <div className="w-60 divide-y divide-gray-700 rounded-md border border-
    gray-700 bg-gray-900 text-sm shadow-md">
      <div className="relative overflow-hidden">
        <Input
          className="!border-box !h-auto bg-transparent !py-3.5 !text-gray-100
          placeholder:!text-gray-600"
          placeholder="Search Workspaces"
          value={searchValue}
          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
            setSearchValue(e.target.value)
          }
          outline={false}
          prefixIconName="search"
          prefixIconSize="s"
          suffixIconName="clear"
          onSuffixIconClick={onXClick}
          suffixIconSize="s"
        />
      </div>
      <div className="thin-scrollbar flex max-h-64 flex-col gap-2 overflow-y-
      scroll px-2 py-2.5">
        {!isGhosting ? (
          <>
            {organizationMatchesSearch(selectedOrg.name, searchValue) && (
              <OrganizationRow
                selected
                id={selectedOrg.id}
                name={selectedOrg.name}
              />
            )}
            {unselectedOrgs
              .filter((organization) =>
                organizationMatchesSearch(organization.name, searchValue),
              )
              .map((organization) => (
                <OrganizationRow
                  name={organization.name}
                  id={organization.id}
                />
              ))}
            {noSearchResults && (
              <div className="p-2 text-center font-medium text-gray-600">
                No results
              </div>
            )}
          </>
        ) : (
          <div className="p-2 text-center font-medium text-gray-600">
            Org switching is disabled in Customer View
          </div>
        )}
      </div>
      <div className="p-2">
        <Clickable onClick={onLogoutClick}>
          <div className="flex items-center gap-2 rounded-md p-2 text-gray-200
          hover:bg-mist-700">
            <Icon
              iconName="sign_out"
              size="s"
              color="currentColor"
              className="text-gray-200"
            />
            Sign out
          </div>
        </Clickable>
      </div>
    </div>
  );
}

export default OrgSwitcher;
```

---
## `OrganizationForm.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { ClipLoader } from "react-spinners";
import { Field, FieldArray, Form, Formik } from "formik";
import { required } from "../../common/ui-components/validations";
import {
  Button,
  EmailForm,
  FieldGroup,
  FieldsRow,
  FormContainer,
  Label,
} from "../../common/ui-components";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import { useCreateOrganizationMutation } from
"~/generated/dashboard/graphqlSchema";
import { useDispatchContext } from "../MessageProvider";
import {
  FormikCheckboxField,
  FormikErrorMessage,
  FormikInputField,
  FormikSelectField,
} from "~/common/formik";
import { CellEnum } from "../constants";

export interface FormValues {
  organization_name?: string;
  send_emails_enabled?: [boolean];
  cell?: string;
  emails?: { key: string }[];
}

const CELL_OPTIONS = [
  {
    label: "Commercial, Free, Demo, or Dev/QA (default)",
    value: CellEnum.US000,
  },
  {
    label: "Mid Market",
    value: CellEnum.US001,
  },
  {
    label: "Enterprise (US_2)",
    value: CellEnum.US002,
  },
  {
    label: "Enterprise (US_5)",
    value: CellEnum.US005,
  },
];

function OrganizationForm() {
  const [createOrganization, { loading: submitting }] =
    useCreateOrganizationMutation();
  const { dispatchSuccess } = useDispatchContext();

  async function onFormikSubmit(values: FormValues) {
    if (!values.organization_name || !values.cell) {
      return;
    }

    const result = await createOrganization({
      variables: {
        input: {
          organizationName: values.organization_name,
          sendEmailsEnabled: values.send_emails_enabled?.[0] || false,
          cell: values.cell,
          adminEmails: values.emails?.map((v) => v.key),
        },
      },
    });

    if (result.data?.createOrganization?.organizationId) {
      window.location.href = "/admin";
      dispatchSuccess("Organization successfully created");
    }
  }
  return (
    <Formik<FormValues>
      onSubmit={onFormikSubmit}
      initialValues={{ emails: [], cell: CellEnum.US000 }}
    >
      {({ handleSubmit, isValid }) => (
        <PageHeader hideBreadCrumbs title="Create New Organization">
          <Form>
            <FormContainer>
              <FieldsRow columns={1}>
                <FieldGroup>
                  <Label>Organization name</Label>
                  <Field
                    name="organization_name"
                    type="text"
                    component={FormikInputField}
                    validate={required}
                  />
                  <FormikErrorMessage name="organization_name" />
                </FieldGroup>
              </FieldsRow>
              <FieldsRow columns={1}>
                <FieldGroup direction="left-to-right">
                  <Field
                    name="send_emails_enabled"
                    type="checkbox"
                    value
                    component={FormikCheckboxField}
                  />
                  <Label
                    className="pl-2"
                    helpText="If you would like this organization to have
                    sending emails capabilities, check this box."
                  >
                    Send Emails Capability
                  </Label>
                </FieldGroup>
              </FieldsRow>
              <FieldsRow columns={1}>
                <FieldGroup>
                  <Label>Cell Allocation</Label>
                  <Label className="text-xs text-text-muted">
                    Select a customer segment to create their production
                    organization in the correct cell. If not creating a
                    customers production organization, select the default
                  </Label>
                  <Field
                    id="cell"
                    name="cell"
                    options={CELL_OPTIONS}
                    component={FormikSelectField}
                    validate={required}
                  />
                  <FormikErrorMessage name="cell" />
                </FieldGroup>
              </FieldsRow>
              <FieldArray
                name="emails"
                render={(props) => <EmailForm {...props} />}
              />
              <FieldsRow columns={1}>
                <Button
                  id="create-org-btn"
                  buttonType="primary"
                  onClick={() => handleSubmit()}
                  disabled={submitting || !isValid}
                >
                  Create
                </Button>
                <ClipLoader loading={submitting} />
              </FieldsRow>
            </FormContainer>
          </Form>
        </PageHeader>
      )}
    </Formik>
  );
}

export default OrganizationForm;
```

---
## `Page.tsx.txt`
**Path:** `.`  
```
import React from "react";

type PageProps = {
  title: string;
  children: React.ReactElement;
};
function Page({ title, children }: PageProps) {
  document.title = `${title} - Modern Treasury`;

  return children;
}

export default Page;
```

---
## `PartnerHeader.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Icon, Tabs } from "../../common/ui-components";

export const PARTNER_FORM_TAB = "Partner";
export const PARTNER_CONTACTS_TAB = "Partner Contacts";

interface PartnerHeaderProps {
  onTabChange?: (
    tab: string,
    e: React.MouseEvent | React.KeyboardEvent,
  ) => void;
  selectedTab?: string;
  partnerName?: string;
}

function PartnerHeader({
  onTabChange,
  selectedTab,
  partnerName,
}: PartnerHeaderProps) {
  return (
    <div className="flex flex-col">
      <div className="mb-5 flex pb-5">
        <span className="text-lg">
          <a
            className="text-lg text-blue-500 no-underline"
            href="/admin/partner_tools?tab=onboarding_partners"
          >
            Partners
          </a>
        </span>
        <div className="flex self-center px-1">
          <Icon
            iconName="forward_slash"
            color="currentColor"
            className="text-gray-400"
          />
        </div>
        {partnerName && (
          <span className="max-w-xs overflow-hidden overflow-ellipsis
          whitespace-nowrap text-lg font-medium mint-lg:max-w-md">
            {partnerName}
          </span>
        )}
      </div>
      {partnerName && (
        <div className="flex w-full pb-6">
          <Tabs
            selected={selectedTab || ""}
            onClick={
              onTabChange as (
                tab: string,
                e: React.MouseEvent | React.KeyboardEvent,
              ) => void
            }
            tabs={{
              [PARTNER_FORM_TAB]: "Partner",
              [PARTNER_CONTACTS_TAB]: "Partner Contacts",
            }}
          />
        </div>
      )}
    </div>
  );
}

export default PartnerHeader;
```

---
## `PaymentOrderBulkImport.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CellValueUnion } from "@flatfile/api/api";
import {
  useBulkCreatePaymentOrdersMutation,
  useBulkValidatePaymentOrdersMutation,
} from "../../generated/dashboard/graphqlSchema";
import { BulkResourceType } from "./FlatfileBulkUploadButton";
import BulkImportHeader from "./BulkImportHeader";
import InternalAccountIdsList from "./InternalAccountIdsList";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";
import {
  paymentOrderBlueprint,
  paymentOrderBlueprintFields,
} from "./bulk_imports/blueprints/paymentOrderBlueprint";

function PaymentOrderBulkImport(): JSX.Element {
  const [bulkCreatePaymentOrders] = useBulkCreatePaymentOrdersMutation();
  const [bulkValidatePaymentOrders] = useBulkValidatePaymentOrdersMutation();

  const submit = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => {
    const { data } = await bulkCreatePaymentOrders({
      variables: {
        input: {
          paymentOrders: resultsData,
          flatfileSheetId,
          flatfileSpaceId,
        },
      },
    });
    const { bulkImportId } = data?.bulkCreatePaymentOrders ?? {};
    if (bulkImportId) {
      return { success: true, bulkImportId };
    }
    return { success: false, bulkImportId: "" };
  };

  const validate = async (
    resultsData: Array<Record<string, CellValueUnion | null>>,
  ) => {
    const response = await bulkValidatePaymentOrders({
      variables: {
        input: {
          paymentOrders: resultsData,
        },
      },
    });
    return response.data?.bulkValidatePaymentOrders?.recordErrors;
  };

  return (
    <PageHeader
      crumbs={[
        {
          name: "Payments",
          path: "/payment_orders",
        },
      ]}
      title="Bulk Imports"
    >
      <BulkImportHeader
        bulkImportType="Payment Order"
        validate={validate}
        submit={submit}
        expectedFields={paymentOrderBlueprintFields}
        blueprint={paymentOrderBlueprint}
        resource={BulkResourceType.PaymentOrders}
      />
      <InternalAccountIdsList />
    </PageHeader>
  );
}

export default PaymentOrderBulkImport;
```

---
## `PaymentReferenceReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Label,
  SelectField,
  Autosuggest,
  Icon,
  Clickable,
} from "../../common/ui-components";

interface PaymentReferenceReconciliationMatchResultProps {
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  suggestedMatcher: string | null | undefined;
  matcher: string | null;
  referenceValue: string | null | undefined;
  transactionField: string | null | undefined;
  transactionFieldString: string | null | undefined;
  parser: string | null | undefined;
  showParser: boolean;
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null | undefined,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

function PaymentReferenceReconciliationMatchResult({
  selectFieldOptions,
  matcher,
  referenceValue,
  parser,
  showParser,
  transactionField,
  transactionFieldString,
  suggestedMatcher,
  callback,
}: PaymentReferenceReconciliationMatchResultProps) {
  const transactionFieldOptions = [
    {
      label: "vendor_description",
      value: "vendor_description",
    },
    {
      label: "vendor_id",
      value: "vendor_id",
    },
    {
      label: "unique_vendor_id",
      value: "unique_vendor_id",
    },
    {
      label: "vendor_customer_id",
      value: "vendor_customer_id",
    },
  ];

  return (
    <div className="flex w-full flex-col">
      <div className="flex w-full">
        <Label className="flex self-center pb-4 pr-3">Reference Type</Label>
        <div className="min-w-44">
          <SelectField
            className="justify-right flex"
            handleChange={(e) => {
              callback(
                "Payment Reference",
                e as string,
                parser,
                showParser,
                transactionField,
                null,
                null,
              );
            }}
            id="select-id1"
            name="select-name1"
            selectValue={matcher}
            options={selectFieldOptions}
          />
        </div>
        {referenceValue ? (
          <Label className="flex pb-5 pl-2 text-gray-500">
            {referenceValue}
          </Label>
        ) : (
          <Label className="flex pb-5 pl-2 italic text-gray-400">
            No reference found
          </Label>
        )}
      </div>

      <div className="flex w-full flex-col">
        <div className="flex w-full">
          <Label className="flex self-center pb-4 pr-1">
            Transaction Field
          </Label>
          <div className="min-w-44">
            <SelectField
              className="justify-right flex"
              handleChange={(e) => {
                callback(
                  "Payment Reference",
                  matcher,
                  parser,
                  showParser,
                  e as string,
                  null,
                  null,
                );
              }}
              id="select-id2"
              name="select-name2"
              selectValue={transactionField}
              options={transactionFieldOptions}
            />
          </div>
        </div>
        <Label className="flex pl-10 text-xs text-gray-500">
          {transactionFieldString}
        </Label>
      </div>

      <div className="flex w-full">
        {showParser ? (
          // <Animation animationState={showParser}>
          <div className="flex w-full flex-col">
            <div className="flex w-full pt-2">
              <Label className="justify-left flex self-center pr-1">
                Parser:
              </Label>
              <Label className="self-center px-1">/</Label>
              <Autosuggest
                className="justify-right w-full"
                onChange={(e) => {
                  callback(
                    "Payment Reference",
                    matcher,
                    e.target.value,
                    showParser,
                    transactionField,
                    null,
                    null,
                  );
                }}
                onSuggestionSelect={(e, suggestion) => {
                  callback(
                    "Payment Reference",
                    matcher,
                    suggestion.suggestionValue,
                    showParser,
                    transactionField,
                    null,
                    null,
                  );
                }}
                value={parser || ""}
                suggestions={
                  suggestedMatcher
                    ? [
                        {
                          label: `Suggested: ${suggestedMatcher}`,
                          value: suggestedMatcher,
                        },
                      ]
                    : [
                        {
                          label: "No Suggestion",
                          value: "(.*)",
                        },
                      ]
                }
                placeholder="Enter a value"
              />
              <Label className="self-center px-1">/</Label>
            </div>

            <div className="flex w-full">
              <Clickable
                onClick={() => {
                  callback(
                    "Payment Reference",
                    matcher,
                    null,
                    false,
                    transactionField,
                    null,
                    null,
                  );
                }}
              >
                <div className="mr-auto flex flex-row pb-6 pt-2">
                  <Icon
                    className="self-center text-red-500"
                    iconName="remove"
                    size="xs"
                    color="currentColor"
                  />
                  <Label className="flex self-center pl-1 text-xs text-red-500">
                    Remove Parser
                  </Label>
                </div>
              </Clickable>
            </div>
          </div>
        ) : (
          <div className="flex w-full">
            <Clickable
              onClick={() => {
                callback(
                  "Payment Reference",
                  matcher,
                  parser,
                  true,
                  transactionField,
                  null,
                  null,
                );
              }}
            >
              <div className="mr-auto flex flex-row pb-2 pt-1">
                <Icon
                  className="self-center text-blue-500"
                  iconName="add"
                  size="xs"
                  color="currentColor"
                />
                <Label className="flex self-center pl-1 text-xs text-blue-500">
                  Add Parser
                </Label>
              </div>
            </Clickable>
          </div>
        )}
      </div>
    </div>
  );
}
export default PaymentReferenceReconciliationMatchResult;
```

---
## `PaymentsByStatus.tsx.txt`
**Path:** `.`  
```
import React, { useState, useEffect, useMemo } from "react";
import {
  Bar,
  BarChart,
  Tooltip,
  XAxis,
  YAxis,
  ResponsiveContainer,
} from "recharts";
import { v4 } from "uuid";
import ChartView from "../../common/ui-components/Charts/ChartView";
import DateSearch, { dateSearchMapper } from "./search/DateSearch";
import { Clickable, DateRangeFormValues } from "../../common/ui-components";
import { useToggle } from "../../common/utilities/useToggle";
import { tooltipFormatter } from
"./transaction_cash_flow/HistoricalCashFlowBarChart";
import CheckboxWithLabel from "./CheckBoxWithLabel";
import { stringify } from "../../common/utilities/queryString";
import PlaceholderLineChart from "./PlaceholderLineChart";
import { formatAmount } from "../../common/utilities/formatAmount";
import { ACCOUNT_DATE_RANGE_FILTER_OPTIONS } from
"../containers/reconciliation/utils";
import { usePaymentsByStatusQuery } from
"../../generated/dashboard/graphqlSchema";
import { ACCOUNT_ACTIONS } from "../../common/constants/analytics";
import trackEvent from "../../common/utilities/trackEvent";

function redirectToPaymentOrders(
  query: PaymentsByStatusQueryFilter,
  status: string,
  currency: string,
  originatingAccountId?: string,
  direction?: string,
) {
  window.open(
    `/payment_orders?${stringify({
      effective_date: query.effectiveDate,
      status,
      currency,
      ...(originatingAccountId && {
        originating_account_ids: originatingAccountId,
      }),
      ...(direction && { direction }),
    })}`,
    "_blank",
  );
}

interface MetaData {
  color: string;
  label: string;
}

interface AlertTypeKeys {
  needs_approval: MetaData;
  reversed: MetaData;
  returned: MetaData;
  failed: MetaData;
}
const alertTypes: AlertTypeKeys = {
  needs_approval: { color: "#007787", label: "Needs Approval" },
  reversed: { color: "#71b79a", label: "Reversed" },
  returned: { color: "#ffbf34", label: "Returned" },
  failed: { color: "#e35263", label: "Failed" },
};

function PaymentsByStatusBarChart({
  all,
  query,
  currency,
  entityId,
}: {
  all: Alert[];
  query: PaymentsByStatusQueryFilter;
  currency: string;
  entityId?: string;
}) {
  let direction = "";

  const newData: Record<keyof AlertTypeKeys, number> = all.reduce(
    (acc, obj) => {
      if (alertTypes[obj.label]) {
        acc[obj.label] = obj.floatTotal;
        if (obj.direction === "debit" || obj.direction === "credit") {
          // only care about debit or credit, ignore all other directions
          direction = obj.direction;
        }
      }
      return acc;
    },
    {} as Record<keyof AlertTypeKeys, number>,
  );

  // delete all the keys that have 0 value
  Object.keys(newData).forEach((key) => {
    if (newData[key as keyof AlertTypeKeys] === 0) {
      delete newData[key as keyof AlertTypeKeys];
    }
  });

  const final = [newData];
  return (
    <div className="-ml-2">
      <ResponsiveContainer width="100%" height={65}>
        <BarChart
          width={600}
          height={40}
          data={final}
          layout="vertical"
          style={{
            stroke: "#fff",
            strokeWidth: 5,
            padding: "0 0",
          }}
        >
          <XAxis type="number" hide />
          <YAxis type="category" dataKey="name" hide />
          <Tooltip
            formatter={(value) => tooltipFormatter(value, currency)}
            cursor={{ fill: "transparent" }}
          />
          {Object.keys(newData).map((key, index) => {
            const borderRad = 4;
            let radius = [0, 0, 0, 0];
            if (index === 0) radius = [borderRad, 0, 0, borderRad];
            if (index === Object.keys(newData).length - 1)
              radius = [0, borderRad, borderRad, 0];
            if (Object.keys(newData).length === 1)
              radius = [borderRad, borderRad, borderRad, borderRad];

            return (
              <Bar
                className="cursor-pointer active:cursor-wait"
                key={key}
                dataKey={key}
                name={alertTypes[key as keyof AlertTypeKeys].label}
                fill={alertTypes[key as keyof AlertTypeKeys].color}
                stackId="a"
                radius={radius}
                isAnimationActive={false}
                onClick={() =>
                  redirectToPaymentOrders(
                    query,
                    key,
                    currency,
                    entityId,
                    direction,
                  )
                }
              />
            );
          })}
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}
function LegendforGraph({
  all,
  query,
  currency,
  entityId,
}: {
  all: Alert[];
  query: PaymentsByStatusQueryFilter;
  currency: string;
  entityId?: string;
}) {
  const newData: Record<keyof AlertTypeKeys, string> = all.reduce(
    (acc, obj) => {
      if (alertTypes[obj.label]) {
        acc[obj.label] = obj.prettyCount;
      }
      return acc;
    },
    {} as Record<keyof AlertTypeKeys, string>,
  );

  return (
    <div className="-mx-2 -my-2 flex flex-wrap">
      {Object.keys(alertTypes).map((key) => (
        <div className="w-full mint-lg:w-6/12">
          <Clickable
            onClick={() =>
              redirectToPaymentOrders(query, key, currency, entityId)
            }
          >
            <div
              key={key}
              className="m-2 rounded-sm py-1"
              style={{
                backgroundColor: "#FAFAF9",
              }}
            >
              <div className="m-3">
                <div className="flex justify-between gap-3">
                  <div className="flex flex-row items-center gap-2">
                    <div
                      className="h-3 w-3 rounded-full"
                      style={{
                        backgroundColor:
                          alertTypes[key as keyof AlertTypeKeys].color,
                      }}
                    />
                    <div>{alertTypes[key as keyof AlertTypeKeys].label}</div>
                  </div>
                  <div>{newData[key]} payments</div>
                </div>
              </div>
            </div>
          </Clickable>
        </div>
      ))}
    </div>
  );
}

type Alert = {
  direction: string;
  label: string;
  total: number;
  count: number;
  prettyTotal: string;
  prettyCount: string;
  floatTotal: number;
};
interface PaymentsByStatusQueryFilter {
  currency: string;
  entityId?: string;
  entityType?: string;
  effectiveDate: DateRangeFormValues;
}
function PaymentsByStatus({
  entityId,
  entityType,
  currency = "USD",
  dateRange,
  setGlobalDateFilterLabel,
}: {
  entityId?: string;
  entityType?: string;
  currency: string;
  dateRange?: DateRangeFormValues;
  setGlobalDateFilterLabel?: () => void;
}) {
  const [totalInflows, setTotalInFlows] = useState<string | null | undefined>();
  const [totalOutFlows, setTotalOutFlows] = useState<
    string | null | undefined
  >();
  const [totals, setTotals] = useState<string | null | undefined>();
  const [direction, toggle] = useToggle(true);
  const [query, setQuery] = useState<PaymentsByStatusQueryFilter>({
    effectiveDate: dateRange || ACCOUNT_DATE_RANGE_FILTER_OPTIONS[1].dateRange,
    entityId,
    entityType,
    currency,
  });

  const { data, loading, error, refetch } = usePaymentsByStatusQuery({
    variables: {
      ...query,
      effectiveDate: dateSearchMapper(query.effectiveDate),
    },
    notifyOnNetworkStatusChange: true,
  });
  const handleRefetch = async (newQuery: PaymentsByStatusQueryFilter) => {
    setQuery({ ...newQuery, currency, effectiveDate: newQuery.effectiveDate });

    await refetch({
      ...newQuery,
      effectiveDate: dateSearchMapper(newQuery.effectiveDate),
      currency,
    });
  };

  const alerts: Alert[] = useMemo(() => {
    if (loading || !data || error) {
      return [];
    }
    if (!data || !data.paymentsByStatus) {
      return [];
    }

    return data.paymentsByStatus.map(
      (alert) =>
        ({
          direction: alert.direction,
          label: alert.status,
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          total: alert.total,
          floatTotal: alert.floatTotal,
          count: alert.count,
          prettyTotal: alert.prettyTotal,
          prettyCount: alert.count?.toLocaleString(undefined, {
            style: "decimal",
          }),
        }) as Alert,
    );
  }, [loading, data, error]);

  useEffect(() => {
    let inflows = 0;
    let outflows = 0;

    alerts.forEach((obj) => {
      if (obj.direction === "debit") {
        inflows += Number(obj.total);
      }
      if (obj.direction === "credit") {
        outflows += Number(obj.total);
      }
    });
    if (currency != null) {
      setTotalInFlows(formatAmount(inflows, currency));
      setTotalOutFlows(formatAmount(outflows, currency));
      setTotals(formatAmount(outflows + inflows, currency));
    }
  }, [alerts, currency]);

  useEffect(() => {
    void handleRefetch({
      ...query,
      currency,
      ...(dateRange && { effectiveDate: dateRange }),
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currency, dateRange]);

  const searchComponents = [
    {
      field: "effectiveDate",
      // so cascading date filter label updates when date range changes
      key: v4(),
      query,
      options: ACCOUNT_DATE_RANGE_FILTER_OPTIONS,
      component: DateSearch,
      isSearchable: false,
      updateQuery: (input: Record<string, DateRangeFormValues>) => {
        trackEvent(null, ACCOUNT_ACTIONS.CHANGED_WIDGET_DATE_FILTER, {
          widget: "Payment Exceptions",
        });
        void handleRefetch({
          ...query,
          effectiveDate: input.effectiveDate,
          currency,
        });
      },
      setGlobalDateFilterLabel,
      autoWidth: true,
      showStartAndEndDateArrow: false,
    },
    {
      field: "direction",
      component: CheckboxWithLabel,
      label: "By Direction",
      value: direction,
      onToggle: toggle,
    },
  ];

  const inflows =
    alerts.filter((obj: Alert) => obj.direction === "debit") ?? [];
  const outflows = alerts.filter((obj: Alert) => obj.direction === "credit");

  return (
    <ChartView
      title="Payment Exceptions"
      searchComponents={searchComponents}
      className="bg-background-default"
      loading={loading}
      hasChartOptions
    >
      {alerts && alerts.length > 0 ? (
        <div>
          {direction ? (
            <>
              <div className="font-medium">
                Outflows: {totalOutFlows}{" "}
                <span className="text-gray-500">{currency} Total</span>
              </div>
              <PaymentsByStatusBarChart
                all={outflows}
                query={query}
                currency={currency}
                entityId={entityId}
              />
              <div className="font-medium">
                Inflows: {totalInflows}{" "}
                <span className="text-gray-500">{currency} Total</span>
              </div>
              <PaymentsByStatusBarChart
                all={inflows}
                query={query}
                currency={currency}
                entityId={entityId}
              />
            </>
          ) : (
            <>
              <div className="font-medium">
                Total: {totals}{" "}
                <span className="text-gray-500">{currency}</span>
              </div>
              <PaymentsByStatusBarChart
                all={alerts.filter((obj) => obj.direction === "all")}
                query={query}
                currency={currency}
              />
            </>
          )}

          <LegendforGraph
            all={alerts.filter((obj) => obj.direction === "all")}
            query={query}
            currency={currency}
            entityId={entityId}
          />
        </div>
      ) : (
        <div className="flex flex-grow items-center justify-center">
          <PlaceholderLineChart content="There is no data in this date range. If
          you believe this is an error, please contact support." />
        </div>
      )}
    </ChartView>
  );
}

export default PaymentsByStatus;
```

---
## `PlaceholderLineChart.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Legend, Line, LineChart, ResponsiveContainer } from "recharts";
import colors from "../../common/styles/colors";

const data: { x: number; y: number }[] = [];
for (let i = 0; i <= 720; i += 10) {
  data.push({ x: i, y: Math.sin((i * Math.PI) / 180) });
}

const renderCustomLegend = (content) => (
  <div className="flex flex-row justify-center pt-8 font-medium text-gray-700">
    <span>{content}</span>
  </div>
);

interface PlaceholderLineChartProps {
  content?: JSX.Element | string;
}

function PlaceholderLineChart({ content }: PlaceholderLineChartProps) {
  return (
    <ResponsiveContainer width="50%" height="50%">
      <LineChart data={data}>
        <Legend
          verticalAlign="bottom"
          align="center"
          content={renderCustomLegend(content)}
        />
        <Line
          dataKey="y"
          type="monotone"
          stroke={colors.gray[100]}
          dot={false}
          strokeWidth={4}
          strokeLinejoin="round"
          strokeLinecap="round"
        />
      </LineChart>
    </ResponsiveContainer>
  );
}

export default PlaceholderLineChart;
```

---
## `ProposedChangeNotice.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { startCase } from "lodash";
import { Alert } from "~/common/ui-components";
import { useCurrentOrganizationQuery } from
"~/generated/dashboard/graphqlSchema";

function ProposedChangeNotice({
  entityType,
  action,
}: {
  entityType: string;
  action?: string | undefined;
}) {
  const { data, loading, error } = useCurrentOrganizationQuery();
  const adminApprovalsEnabled =
    !loading && !error && data?.currentOrganization?.adminApprovalRuleEnabled;

  if (!adminApprovalsEnabled) {
    return null;
  }

  let message = "Changes will not be active until approved by an admin.";
  if (action === "create") {
    message = `${startCase(
      entityType,
    )} will not be created until approved by an admin.`;
  }

  return (
    <div className="float-end -mt-6">
      {!!action && <Alert alertType="info">{message}</Alert>}
    </div>
  );
}

export default ProposedChangeNotice;
```

---
## `PublishableKeyForm.tsx.txt`
**Path:** `.`  
```
import React, { useRef } from "react";
import {
  Field,
  Form,
  Formik,
  FormikErrors,
  FormikHelpers,
  FormikProps,
  FieldArray,
} from "formik";
import * as yup from "yup";
import { Button, Heading, Icon, Label } from "../../common/ui-components";
import { required } from "../../common/ui-components/validations";
import { useUpsertPublishableKeyMutation } from
"../../generated/dashboard/graphqlSchema";
import { FormikErrorMessage, FormikInputField } from "../../common/formik";
import useErrorBanner from "../../common/utilities/useErrorBanner";

interface FormValues {
  id?: string;
  name?: string;
  domainAllowlist?: string[];
}

interface PublishableKeyFormProps {
  publishableKeyId?: string;
  isEditing?: boolean;
  publishableKeyData?: FormValues;
}

const validate = yup.object().shape({
  name: yup.string().required("Name is required"),
});

function PublishableKeyForm({
  publishableKeyId,
  isEditing,
  publishableKeyData,
}: PublishableKeyFormProps) {
  const formikRef = useRef<FormikProps<FormValues>>(null);
  const [upsertPublishableKey] = useUpsertPublishableKeyMutation();
  const flashError = useErrorBanner();

  let initialValues: FormValues;
  if (isEditing && publishableKeyId) {
    initialValues = {
      name: publishableKeyData?.name,
      domainAllowlist: publishableKeyData?.domainAllowlist,
    };
  } else {
    initialValues = {
      name: "",
      domainAllowlist: [],
    };
  }

  function submitPublishableKey(
    formValues: FormValues,
    setErrors: (errors: FormikErrors<FormValues>) => void,
    setSubmitting: (isSubmitting: boolean) => void,
  ) {
    setSubmitting(true);

    const formData: FormValues = {
      name: formValues.name,
      domainAllowlist: formValues.domainAllowlist,
      ...(isEditing && { id: publishableKeyId }),
    };

    upsertPublishableKey({
      variables: { input: formData },
    })
      .then(({ data }) => {
        if (data?.upsertPublishableKey?.errors?.length) {
          flashError(data.upsertPublishableKey.errors.join(", "));
          window.scrollTo(0, 0);
          setSubmitting(false);
        } else if (data?.upsertPublishableKey?.publishableKey?.id) {
          window.location.href = `/developers/publishable_keys/${data.upsertPubl
          ishableKey.publishableKey.id}`;
        }
      })
      .catch((error: Error) => {
        flashError(error.message);
      });
  }

  return (
    <div className="flex flex-col">
      <div className="mt-8 flex flex-col">
        <Formik
          initialValues={initialValues}
          onSubmit={(
            values,
            { setErrors, setSubmitting }: FormikHelpers<FormValues>,
          ) => {
            submitPublishableKey(values, setErrors, setSubmitting);
          }}
          innerRef={formikRef}
          validationSchema={validate}
        >
          {({ values, isSubmitting }) => (
            <div>
              <Form>
                <div className="flex flex-col">
                  <div className="pb-4">
                    <Label id="name">Name</Label>
                    <Field
                      id="name"
                      name="name"
                      placeholder="Publishable Key"
                      component={FormikInputField}
                      validate={required}
                    />
                    <FormikErrorMessage name="name" />
                  </div>
                  <div className="bg-background-light p-4">
                    <Heading level="h4" size="l" className="pb-4">
                      Allowed Domains
                    </Heading>
                    <FieldArray name="domainAllowlist">
                      {({ remove, push }) => (
                        <div className="grid gap-4">
                          {!!values?.domainAllowlist?.length &&
                            values?.domainAllowlist?.map((domain, index) => (
                              <div
                                className="grid grid-cols-2 gap-6"
                                key="index"
                              >
                                <div>
                                  <Field
                                    name={`domainAllowlist.${index}`}
                                    placeholder="https://www.example.domain"
                                    type="text"
                                    className="max-w-md"
                                    component={FormikInputField}
                                  />
                                </div>
                                <div>
                                  <Button
                                    buttonType="destructive"
                                    onClick={() => remove(index)}
                                  >
                                    <Icon
                                      color="currentColor"
                                      className="text-white"
                                      iconName="remove_circle"
                                    />
                                    <span>Remove Domain</span>
                                  </Button>
                                </div>
                              </div>
                            ))}
                          <div />
                          <div className="flex flex-row space-x-4">
                            <Button
                              buttonType="secondary"
                              onClick={() => push("")}
                            >
                              <Icon iconName="add" />
                              Add Allowed Domain
                            </Button>
                          </div>
                        </div>
                      )}
                    </FieldArray>
                  </div>
                  <div className="flex flex-row space-x-4 pt-5">
                    <Button
                      buttonType="primary"
                      disabled={isSubmitting}
                      isSubmit
                    >
                      {isEditing ? "Update" : "Create"}
                    </Button>
                  </div>
                </div>
              </Form>
            </div>
          )}
        </Formik>
      </div>
    </div>
  );
}

export default PublishableKeyForm;
```

---
## `PublishableKeySelectField.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { usePublishableKeysDemoSelectQuery } from
"../../generated/dashboard/graphqlSchema";
import { AsyncSelectField } from "../../common/ui-components";
import { SelectValue } from "../../common/ui-
components/AsyncSelectField/AsyncSelectField";

interface PublishableKeySelectFieldProps {
  selectValue: string;
  onChange: (value: SelectValue | null) => void;
  disabled: boolean;
}

function PublishableKeySelectField({
  selectValue,
  onChange,
  disabled = false,
}: PublishableKeySelectFieldProps) {
  const [options, setOptions] = useState<SelectValue[]>([]);
  const [isDataLoaded, setIsDataLoaded] = useState<boolean>(false);
  const { refetch } = usePublishableKeysDemoSelectQuery({
    skip: true,
  });

  const loadOptions = (input: string) =>
    new Promise((resolve, reject) => {
      if (isDataLoaded) {
        const filteredOptions = options.filter((option) =>
          option.label.includes(input.toUpperCase()),
        );
        resolve({ options: filteredOptions });
      } else {
        refetch()
          .then(({ data }) => {
            const publishableKeyOptions = data.publishableKeys.edges.map(
              (e) => ({
                label: `${e.node.name} Â· ${e.node.prettyDomainAllowlist}`,
                value: e.node.key,
              }),
            );
            setOptions(publishableKeyOptions);
            setIsDataLoaded(true);
            resolve({
              options: publishableKeyOptions,
            });
          })
          .catch((e) => reject(e));
      }
    });
  return (
    <AsyncSelectField
      className="w-full"
      id="publishableKey"
      name="publishableKeySelect"
      loadOptions={loadOptions}
      selectValue={
        selectValue
          ? {
              value: selectValue,
              label: selectValue,
            }
          : undefined
      }
      handleChange={(option: SelectValue) => onChange(option)}
      noOptionsMessage={(val) =>
        val.inputValue === "" ? "Type to see options" : "No options"
      }
      disabled={disabled}
    />
  );
}

export default PublishableKeySelectField;
```

---
## `ReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Field, getIn } from "formik";
import { MatchResult } from "../../generated/dashboard/graphqlSchema";
import {
  FieldsRow,
  Label,
  MTContainer,
  Textarea,
  Icon,
} from "../../common/ui-components";
import { FormikTextareaFieldProps } from
"../../common/formik/FormikTextareaField";

interface MatcherTextAreaFieldProps extends FormikTextareaFieldProps {
  callback: (
    id: string,
    strategyName: string,
    field: string,
    matcher_type: string,
    matcher: string,
  ) => void;
  matcherId: string;
  strategyName: string;
  matcherField: string;
  matcherType: string;
}

function MatchResultTextareaField({
  field,
  form,
  meta,
  callback,
  matcherId,
  strategyName,
  matcherField,
  matcherType,
  ...args
}: MatcherTextAreaFieldProps) {
  return (
    <Textarea
      {...args}
      name={field.name}
      value={field.value as string}
      onChange={(e) => {
        void form.setFieldValue(field.name, e.target.value);
        callback(
          matcherId,
          strategyName,
          matcherField,
          matcherType,
          String(e?.target?.value),
        );
      }}
      onBlur={() => {
        void form.setFieldTouched(field.name, true);
      }}
      invalid={
        (getIn(form.errors, field.name) &&
          getIn(form.touched, field.name)) as boolean
      }
    />
  );
}

interface ReconciliationMatchResultProps {
  matchResult: MatchResult;
  strategyName: string;
  matcherType: string;
  callback: (
    id: string,
    strategy_name: string,
    field: string,
    matcher_type: string,
    matcher: string,
  ) => void;
}

function ReconciliationMatchResult({
  matchResult,
  strategyName,
  matcherType,
  callback,
}: ReconciliationMatchResultProps) {
  const matcherId = strategyName + matcherType + matchResult.field;

  return (
    <MTContainer>
      <div className="pl-2 pr-2">
        <div className="border-mt-gray-200 rounded border">
          <div className="px-4 py-2">
            <div className="w-full">
              <span className="font-app relative left-0 text-base font-medium">
                {matchResult.field}
              </span>
              {matchResult.match ? (
                <Icon
                  className="float-right text-green-500"
                  iconName="checkmark_circle"
                  color="currentColor"
                  size="l"
                />
              ) : (
                <Icon
                  className="float-right text-red-500"
                  iconName="remove_circle"
                  color="currentColor"
                  size="l"
                />
              )}
            </div>
          </div>

          <div className="border-mt-gray-200 border-t p-2" />
          <div className="pl-4 pr-4">
            <FieldsRow
              className="form-row flex justify-center border-b-2 border-gray-50"
              columns={1}
            >
              <div>
                <Field
                  name={matcherId}
                  id={matcherId}
                  callback={callback}
                  matcherId={matcherId}
                  strategyName={strategyName}
                  matcherField={matchResult.field}
                  matcherType={matchResult.matcherType}
                  component={MatchResultTextareaField}
                />
                <Label labelPrefix="Suggested:">
                  {matchResult.suggestedMatcher}
                </Label>
              </div>
            </FieldsRow>
            <FieldsRow columns={1}>
              <Label labelPrefix="Expected: ">{matchResult.expected}</Label>
            </FieldsRow>
            <FieldsRow columns={1}>
              <Label labelPrefix="Actual: ">{matchResult.actual}</Label>
            </FieldsRow>
          </div>
        </div>
      </div>
    </MTContainer>
  );
}

export default ReconciliationMatchResult;
```

---
## `ReconciliationStrategy.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { Field, Form, Formik } from "formik";
import {
  MatchResultInput,
  Strategy,
} from "../../generated/dashboard/graphqlSchema";
import {
  Button,
  ExpandableCard,
  Icon,
  Label,
  MTContainer,
} from "../../common/ui-components";
import ReconciliationMatchResult from "./ReconciliationMatchResult";
import { FormikTextareaField } from "../../common/formik";

interface ReconciliationStrategyProps {
  strategy: Strategy;
  callback: (matchResults: MatchResultInput[]) => void;
  overrideMatchers: MatchResultInput[];
}

function ReconciliationStrategy({
  strategy,
  callback,
  overrideMatchers,
}: ReconciliationStrategyProps) {
  const strategyConfigLines = strategy.strategyConfig.split("\n");
  const strategyConfigRows =
    strategyConfigLines.length +
    strategyConfigLines.filter((l) => l.length > 80).length;
  const matchResults = (strategy.transactionMatchResults || []).concat(
    strategy.transactableMatchResults || [],
  );
  const [matchResultState, setMatchResultState] =
    useState<MatchResultInput[]>(overrideMatchers);

  const matchResultCallback = (
    id: string,
    strategy_name: string,
    field: string,
    matcher_type: string,
    matcher: string,
  ) => {
    setMatchResultState((prevState) => [
      ...prevState.filter((obj) => obj.id !== id),
      {
        id,
        strategyName: strategy_name,
        field,
        matcherType: matcher_type,
        matcher,
      } as MatchResultInput,
    ]);
  };

  const matchResultValues = matchResults
    .map((mr) => [strategy.name + mr.matcherType + mr.field, mr.matcher])
    .reduce((a, v) => ({ ...a, [v[0]]: v[1] }), {});

  const initialValues = {
    ...matchResultValues,
    strategyConfig: strategy.strategyConfig || "",
  };

  return (
    <MTContainer>
      <div className="pt-4">
        <ExpandableCard
          expandable
          minHeightWhenExpandable={180}
          heading={strategy.name}
          expanded={matchResults.filter((mr) => mr.override).length > 0}
        >
          <div className="border-mt-gray-200 border-t p-2" />

          <Formik
            initialValues={initialValues}
            enableReinitialize
            onSubmit={(_, actions) => {
              callback(matchResultState);
              actions.resetForm();
              actions.setSubmitting(false);
            }}
          >
            {({ isSubmitting }) => (
              <Form>
                <div>
                  <div className="pr-2">
                    {matchResults.every((mr) => mr.match) ? (
                      <Icon
                        className="float-right text-green-500"
                        iconName="checkmark_circle"
                        color="currentColor"
                        size="xl"
                      />
                    ) : (
                      <Icon
                        className="float-right text-red-500"
                        iconName="remove_circle"
                        color="currentColor"
                        size="xl"
                      />
                    )}
                    <Label className="pb-2 pl-4 text-base">
                      {`${matchResults.filter((mr) => mr.match).length}/${
                        matchResults.length
                      } Properties Matched`}
                    </Label>
                  </div>
                </div>

                {strategy.transactionMatchResults &&
                  strategy.transactionMatchResults.filter(
                    (mr) => !mr.match || mr.override,
                  ).length > 0 && (
                    <Label className="pb-2 pl-4 text-base">
                      Transaction Matchers
                    </Label>
                  )}
                {strategy.transactionMatchResults &&
                  strategy.transactionMatchResults
                    .filter((mr) => !mr.match || mr.override)
                    .map((matchResult) => (
                      <ReconciliationMatchResult
                        key={matchResult.field + matchResult.matcherType}
                        matchResult={matchResult}
                        strategyName={strategy.name}
                        matcherType="transactions"
                        callback={matchResultCallback}
                      />
                    ))}
                {strategy.transactableMatchResults &&
                  strategy.transactableMatchResults.filter(
                    (mr) => !mr.match || mr.override,
                  ).length > 0 && (
                    <Label className="pb-2 pl-4 text-base">
                      Transactable Matchers
                    </Label>
                  )}
                {strategy.transactableMatchResults &&
                  strategy.transactableMatchResults
                    .filter((mr) => !mr.match || mr.override)
                    .map((matchResult) => (
                      <ReconciliationMatchResult
                        key={matchResult.field + matchResult.matcherType}
                        matchResult={matchResult}
                        strategyName={strategy.name}
                        matcherType="transactables"
                        callback={matchResultCallback}
                      />
                    ))}
                <div className="pl-2">
                  <Button buttonType="primary" isSubmit disabled={isSubmitting}>
                    Evaluate Matchers
                  </Button>
                </div>

                <div className="p-2">
                  <Label className="py-2 pl-4 text-base">Strategy Config</Label>
                  <Field
                    className="p-2"
                    name="strategyConfig"
                    id="strategyConfig"
                    component={FormikTextareaField}
                    rows={strategyConfigRows}
                  />
                </div>
              </Form>
            )}
          </Formik>
        </ExpandableCard>
      </div>
    </MTContainer>
  );
}

export default ReconciliationStrategy;
```

---
## `ReconciliationSuggestionsView.tsx.txt`
**Path:** `.`  
```
import React, { useState, SyntheticEvent, useCallback } from "react";
import ReactTooltip from "react-tooltip";
import { Field, Form, Formik } from "formik";
import * as Yup from "yup";
import {
  Button,
  ConfirmModal,
  FieldGroup,
  Icon,
  Label,
  MTContainer,
} from "../../common/ui-components";
import FormContainer from "../../common/ui-
components/FormContainer/FormContainer";
import useErrorBanner from "../../common/utilities/useErrorBanner";
import {
  MatchResultInput,
  useDeleteReconciliationSuggestionMutation,
  useInternalToolsVisibilityQuery,
  useReconcileReconciliationSuggestionsMutation,
  useReconciliationSuggestionsViewQuery,
  useStrategiesQuery,
} from "../../generated/dashboard/graphqlSchema";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import CreateReconciliationSuggestionForm from
"./CreateReconciliationSuggestionForm";
import { FormikErrorMessage, FormikInputField } from "../../common/formik";
import DatabaseReconciliationStrategy from "./DatabaseReconciliationStrategy";
import ReconciliationStrategy from "./ReconciliationStrategy";
import colors from "~/common/styles/colors";

const cannotManuallyReconcileMessage =
  "The above reconciliation suggestion amounts do not match the transaction
  amount.";

const validateManualReason = Yup.object({
  manualReason: Yup.string().required("Manual Reason is required"),
});
interface ReconciliationSuggestionsViewProps {
  transactionId: string;
  transactionReconciled: boolean;
}

const RECON_SUGGESTION_DATA_MAPPING = {
  transactableId: "Transactable ID",
  transactablePath: "Link",
  transactableAmount: "Amount",
  transactableTypePretty: "Type",
  transactionLineItemType: "Line Item Type",
  actorName: "Created By",
  actions: "Actions",
};

function ReconciliationSuggestionsView({
  transactionId,
  transactionReconciled,
}: ReconciliationSuggestionsViewProps) {
  const { loading, data, error, refetch } =
    useReconciliationSuggestionsViewQuery({
      notifyOnNetworkStatusChange: true,
      variables: {
        first: INITIAL_PAGINATION.perPage,
        transactionId,
      },
    });

  const flashError = useErrorBanner();

  const [deleteReconciliationSuggestion, { loading: deleting }] =
    useDeleteReconciliationSuggestionMutation({
      refetchQueries: ["ReconciliationSuggestionsView"],
    });
  const [isModalOpen, setIsModalOpen] = useState(false);

  const [reconcileTransaction, { loading: reconciling }] =
    useReconcileReconciliationSuggestionsMutation();

  const [manualReconciliationReason, setManualReconciliationReason] =
    useState("");

  const handleDeleteReconciliationSuggestion = (
    e: SyntheticEvent,
    id: string,
  ) => {
    e.stopPropagation();
    deleteReconciliationSuggestion({
      variables: { input: { id } },
    })
      .then((response) => {
        const { errors = [] } =
          response.data?.deleteReconciliationSuggestion || {};
        if (errors.length) {
          flashError(errors[0]);
        }
      })
      .catch((err: Error) => {
        flashError(err.message);
      });
  };

  const handleReconcileTransaction = () => {
    reconcileTransaction({
      variables: { input: { transactionId, manualReconciliationReason } },
    })
      .then((response) => {
        const { errors = [] } =
          response.data?.reconcileReconciliationSuggestions || {};
        if (errors.length) {
          flashError(errors[0]);
        } else {
          window.location.href = `/transactions/${transactionId}`;
        }
      })
      .catch((err: Error) => {
        flashError(err.message);
      })
      .finally(() => {
        setIsModalOpen(false);
      });
  };

  const reconSuggestions =
    loading || !data || error
      ? []
      : data.reconciliationSuggestions.edges.map(({ node }) => ({
          ...node,
          path: node?.transactablePath,
          actions: (
            <div className="flex">
              <Button
                buttonType="destructive"
                disabled={loading || reconciling || deleting}
                onClick={(e: SyntheticEvent) =>
                  handleDeleteReconciliationSuggestion(e, node.id)
                }
              >
                Delete
              </Button>
            </div>
          ),
        }));

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
  }) => {
    const { cursorPaginationParams } = options;
    await refetch({
      ...cursorPaginationParams,
    });
  };

  const [overrideMatchers, setOverrideMatchers] = useState<MatchResultInput[]>(
    [],
  );
  const [newStrategyToggle, setNewStrategyToggle] = useState<boolean>(false);

  const { data: strategyData, refetch: strategyRefetch } = useStrategiesQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      transactionId,
      matcherOverrides: overrideMatchers,
      defaultStrategy: newStrategyToggle,
    },
  });

  const updateMatcherState = useCallback((state: MatchResultInput[]) => {
    setOverrideMatchers(state);
  }, []);

  const showInternalTools =
    useInternalToolsVisibilityQuery().data?.internalToolsVisibility;

  if (!showInternalTools) {
    return null;
  }

  return (
    <MTContainer>
      <ConfirmModal
        isOpen={isModalOpen}
        setIsOpen={setIsModalOpen}
        title="Are you sure you want to reconcile this transaction?"
        confirmText="Reconcile"
        cancelText="Cancel"
        onConfirm={handleReconcileTransaction}
        confirmDisabled={loading || reconciling || deleting}
        cancelDisabled={loading || reconciling || deleting}
      />
      <div className="mb-8">
        <FormContainer>
          <CreateReconciliationSuggestionForm
            transactionId={transactionId}
            refetchStrategies={strategyRefetch}
          />
        </FormContainer>
      </div>
      <EntityTableView
        data={reconSuggestions}
        dataMapping={RECON_SUGGESTION_DATA_MAPPING}
        loading={loading}
        onQueryArgChange={handleRefetch}
        cursorPagination={data?.reconciliationSuggestions?.pageInfo}
        disableQueryURLParams
      />
      {data?.canManuallyReconcileTransaction ? (
        <Formik
          initialValues={{ manualReason: "" }}
          onSubmit={({ manualReason }, actions) => {
            setManualReconciliationReason(manualReason);
            setIsModalOpen(true);
            actions.resetForm();
            actions.setSubmitting(false);
          }}
          validationSchema={validateManualReason}
        >
          {({ isSubmitting }) => (
            <Form>
              <FieldGroup>
                <Label id="manualReason">Manual Reconciliation Reason</Label>
                <Field
                  id="manualReason"
                  name="manualReason"
                  component={FormikInputField}
                />
                <FormikErrorMessage name="manualReason" />
              </FieldGroup>
              <Button
                buttonType="primary"
                isSubmit
                disabled={isSubmitting || loading || reconciling}
              >
                Reconcile Transaction
              </Button>
            </Form>
          )}
        </Formik>
      ) : (
        <>
          <span data-tip={cannotManuallyReconcileMessage}>
            <Button buttonType="primary" disabled>
              Reconcile Transaction
            </Button>
          </span>
          <ReactTooltip
            multiline
            data-place="top"
            data-type="dark"
            data-effect="float"
            delayShow={500}
          />
        </>
      )}

      <div className="mt-2 rounded-lg border pb-2">
        <div className="flex w-full justify-center rounded-t-lg bg-mist-600
        py-2">
          <Icon
            className="self-center text-gray-25"
            iconName="money_vs"
            color="currentColor"
          />
          <Label className="flex w-full justify-center px-2 text-xl text-
          gray-25">
            Reconciliation Strategies
          </Label>
          <Icon
            className="self-center text-gray-25"
            iconName="money_vs"
            color="currentColor"
          />
        </div>

        <div className="flex justify-center pt-6">
          <Label className="mr-2 self-center text-lg font-light">
            View and edit strategies below, or
          </Label>
          <Button
            className="flex border border-green-600 bg-green-500 font-medium
            text-white hover:border-green-700 hover:bg-green-600 focus:border-
            transparent focus:outline-none focus:ring-2 disabled:cursor-not-
            allowed disabled:bg-green-900 disabled:text-gray-300
            disabled:opacity-50"
            disabled={
              !data?.reconciliationSuggestions?.edges?.length &&
              !transactionReconciled
            }
            onClick={() => setNewStrategyToggle(true)}
            title={
              data?.canManuallyReconcileTransaction
                ? undefined
                : "To create a new strategy, specify above which payments this
                transaction should reconcile to"
            }
          >
            <Icon
              iconName="add"
              color={
                data?.canManuallyReconcileTransaction
                  ? colors.white
                  : colors.gray["300"]
              }
            />
            Create A New Strategy
          </Button>
        </div>
        <Label className="mr-2 mt-2 flex w-full justify-center self-center text-
        sm font-light italic">
          No changes will be saved until submitted and reviewed
        </Label>
        {strategyData?.strategies?.strategies?.map((strategy) =>
          strategy.databaseStrategy ? (
            <div>
              <DatabaseReconciliationStrategy
                key={strategy.name}
                strategy={strategy}
                transactionId={transactionId}
              />
              <div>
                {strategy.suggestedChanges &&
                  strategy.suggestedChanges.map((change, index) => (
                    <DatabaseReconciliationStrategy
                      key={`${change.name}${index}`}
                      strategy={change}
                      transactionId={transactionId}
                    />
                  ))}
              </div>
            </div>
          ) : (
            <ReconciliationStrategy
              key={strategy.name}
              strategy={strategy}
              callback={updateMatcherState}
              overrideMatchers={overrideMatchers}
            />
          ),
        )}
      </div>
    </MTContainer>
  );
}

export default ReconciliationSuggestionsView;
```

---
## `ReturnCodeSearch.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { CombinedQuery } from "~/common/utilities/queryString";
import { ReturnCodesQuery } from "../../generated/dashboard/graphqlSchema";
import ReturnCodeSelectField from "./ReturnCodeSelectField";

interface ReturnCodeSearchProps {
  field: string;
  disabled: boolean;
  updateQuery: (options) => void;
  query: CombinedQuery<ReturnCodesQuery>;
  label: string;
}

function ReturnCodeSearch({
  field,
  disabled,
  updateQuery,
  query,
  label = "Code",
}: ReturnCodeSearchProps) {
  return (
    <ReturnCodeSelectField
      selectValue={query[field] as string}
      onChange={(value: string | null) => updateQuery({ [field]: value })}
      label={label}
      disabled={disabled}
    />
  );
}

export default ReturnCodeSearch;
```

---
## `ReturnCodeSelectField.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import isNil from "lodash/isNil";
import { useReturnCodesQuery } from "../../generated/dashboard/graphqlSchema";
import { AsyncSelectField } from "../../common/ui-components";
import { SelectValue } from "../../common/ui-
components/AsyncSelectField/AsyncSelectField";

interface ReturnCodeSelectFieldProps {
  selectValue: string;
  onChange: (value: string | null) => void;
  label: string;
  disabled: boolean;
}

function ReturnCodeSelectField({
  selectValue,
  onChange,
  label = "Code",
  disabled = false,
}: ReturnCodeSelectFieldProps) {
  const [options, setOptions] = useState<SelectValue[]>([]);
  const [isDataLoaded, setIsDataLoaded] = useState<boolean>(false);
  const { refetch } = useReturnCodesQuery({
    skip: true,
  });

  const loadOptions = (input: string) =>
    new Promise((resolve, reject) => {
      if (isDataLoaded) {
        const filteredOptions = options.filter((option) =>
          option.label.includes(input.toUpperCase()),
        );
        resolve({ options: filteredOptions });
      } else {
        refetch()
          .then(({ data: returnCodesData }) => {
            const returnCodeOptions = returnCodesData.returnCodes.all.map(
              (code) => ({
                value: code,
                label: code.toUpperCase(),
              }),
            );
            setOptions(returnCodeOptions);
            setIsDataLoaded(true);
            resolve({
              options: returnCodeOptions,
            });
          })
          .catch((e) => reject(e));
      }
    });

  return (
    <AsyncSelectField
      isClearable
      defaultOptions={!isNil(selectValue)}
      loadOptions={loadOptions}
      handleChange={(option: SelectValue) =>
        onChange(option && (option.value as string))
      }
      selectValue={
        selectValue
          ? {
              value: selectValue,
              label: selectValue,
            }
          : undefined
      }
      noOptionsMessage={(val) =>
        val.inputValue === "" ? "Type to see options" : "No options"
      }
      label={label}
      name={label}
      disabled={disabled}
    />
  );
}

export default ReturnCodeSelectField;
```

---
## `ReturnRateLineChartTooltip.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { TooltipProps } from "recharts";
import moment from "moment-timezone";
import { cn } from "~/common/utilities/cn";
import { Icon } from "../../common/ui-components";
import { ReturnRateEntityEnum } from "../../generated/dashboard/graphqlSchema";

export interface ReturnRate {
  date: string;
  numDebitsOriginatedRolling60: number;
  numDebitsReturnedRolling60: number;
  overallReturnRate: number;
  numUnauthorizedDebitsRolling60: number;
  numAdministrativeReturnsRolling60: number;
  administrativeReturnRate: number;
  unauthorizedReturnRate: number;
}

/**
 * Interface to denote a type of return defined by NACHA
 *
 * @param entity Entity that the return rate compliance/calculation belongs to
 * @param value Value to compare in components such as a select field
 * @param label Name of the type for user interface
 * @param description NACHA description of the return rate type
 * @param threshold NACHA recommended return rate limit denoted as as percentage
 (expected as a decimal between 0 and 1)
 * @param rateKey Key for the corresponding return rate in the data provided
 * @param countKey Key for the corresponding return counts in the data provided
 */
interface ReturnRateOption {
  entity: ReturnRateEntityEnum;
  value: string;
  label: string;
  description: string;
  threshold?: number;
  rateKey: string;
  countKey: string;
}

function TooltipContent({
  data,
  returnRateOption,
}: {
  data: ReturnRate;
  returnRateOption: ReturnRateOption;
}) {
  const isAboveThreshold =
    returnRateOption.threshold &&
    data[returnRateOption.value] > returnRateOption.threshold;
  return (
    <table>
      <tbody>
        <tr>
          <th className="text-left text-gray-500">Debits Originated</th>
          <td className="pl-6">{data.numDebitsOriginatedRolling60}</td>
        </tr>
        <tr>
          <th className="text-left text-gray-500">Debits Returned</th>
          <td className={`pl-6 ${isAboveThreshold ? "text-red-500" : ""}`}>
            {data[returnRateOption.countKey]}
          </td>
        </tr>
        <tr>
          <th className="text-left text-gray-500">{returnRateOption.label}</th>
          <td className={cn("pl-6", isAboveThreshold && "text-red-500")}>
            {`${data[returnRateOption.rateKey] as number} %`}
          </td>
        </tr>
        <tr>
          <th className="text-left text-gray-500">Date</th>
          <td className="pl-6">{moment(data.date).format("MMM D, YYYY")}</td>
        </tr>
      </tbody>
    </table>
  );
}

interface ReturnRateLineChartTooltipProps extends TooltipProps {
  returnRateOption: ReturnRateOption;
}

function ReturnRateLineChartTooltip({
  payload,
  returnRateOption,
}: ReturnRateLineChartTooltipProps) {
  return payload && payload.length !== 0 ? (
    <div className="bg-white p-4 drop-shadow-md">
      <TooltipContent
        data={payload[0].payload as ReturnRate}
        returnRateOption={returnRateOption}
      />
      <div className="mt-4 flex rounded-md border-yellow-300 bg-yellow-50 p-2
      px-6">
        <Icon
          iconName="error"
          className="mr-2 text-yellow-300"
          color="currentColor"
        />
        {returnRateOption.threshold ? (
          <>
            <span>{`Recommended ${returnRateOption.label} is below`}</span>
            <span className="pl-1 font-
            medium">{`${returnRateOption.threshold}%`}</span>
          </>
        ) : (
          <span>There is no threshold for this return rate</span>
        )}
      </div>
    </div>
  ) : null;
}

export default ReturnRateLineChartTooltip;
```

---
## `ReversalDetailsView.tsx.txt`
**Path:** `.`  
```
import { startCase } from "lodash";
import React, { useMemo } from "react";
import { ReversalDetailsViewFragment } from
"../../generated/dashboard/graphqlSchema";
import {
  DateTime,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../common/ui-components";

const REVERSAL_TITLE_MAPPING = {
  id: "ID",
  account: "Originating Account",
  amount: "Amount",
  counterparty: "Counterparty",
  receivingAccount: "Receiving Account",
  paymentOrder: "Payment Order",
  reason: "Reason",
  reversalType: "Reversal Type",
  createdAt: "Created At",
  updatedAt: "Updated At",
};

interface ReversalDetailsViewProps {
  loading: boolean;
  reversalFragment?: ReversalDetailsViewFragment | null;
}

function ReversalDetailsView({
  reversalFragment,
  loading,
}: ReversalDetailsViewProps): JSX.Element {
  const accountContent = useMemo(() => {
    if (loading || !reversalFragment) {
      return null;
    }

    const { paymentOrder, paymentOrderAttempt } = reversalFragment;

    const accountPath = paymentOrder.originatingAccount.path;

    const counterparty = paymentOrder.counterparty ? (
      <a href={paymentOrder.counterparty.path}>
        {paymentOrder.counterparty.name}
      </a>
    ) : null;
    const receivingAccount = paymentOrder.receivingEntity ? (
      <a href={paymentOrder.receivingEntity.path}>
        {paymentOrder.receivingEntity.name}
      </a>
    ) : null;

    const reversal = {
      ...reversalFragment,
      account: <a href={accountPath}>{paymentOrder.accountName}</a>,
      amount: paymentOrderAttempt.prettyAmount,
      counterparty,
      receivingAccount,
      createdAt: <DateTime timestamp={reversalFragment.createdAt} />,
      paymentOrder: <a href={paymentOrder.path}>{paymentOrder.id}</a>,
      reason: startCase(reversalFragment.reason),
      reversalType: reversalFragment.reversalType.toUpperCase(),
      updatedAt: <DateTime timestamp={reversalFragment.updatedAt} />,
    };

    return (
      <div>
        <KeyValueTable
          key={reversal.id}
          data={reversal}
          dataMapping={REVERSAL_TITLE_MAPPING}
        />
      </div>
    );
  }, [loading, reversalFragment]);

  return (
    <div>
      {loading ? (
        <KeyValueTableSkeletonLoader dataMapping={REVERSAL_TITLE_MAPPING} />
      ) : (
        accountContent
      )}
    </div>
  );
}

export default ReversalDetailsView;
```

---
## `ReversalModal.jsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import trackEvent from "../../common/utilities/trackEvent";
import requestApi from "../../common/utilities/requestApi";
import { REVERSE_MODAL_EVENTS } from "../../common/constants/analytics";
import {
  ConfirmModal,
  FieldGroup,
  Label,
  SelectField,
} from "../../common/ui-components";
import { useDispatchContext } from "../MessageProvider";

function ReverseModal({
  isOpen,
  setIsOpen,
  paymentOrderData: { direction: paymentOrderDirection, id: paymentOrderId },
}) {
  const [submitting, setSubmitting] = useState(false);
  const [state, setState] = useState({});
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  function onReversalSubmission() {
    const method = "POST";
    const action = `/payment_orders/${paymentOrderId}/reversals`;

    setSubmitting(true);
    trackEvent(null, REVERSE_MODAL_EVENTS.REVERSE_MODAL_SUBMIT_BUTTON_CLICKED);

    requestApi(action, null, method, { ...state })
      .json((reversal) => {
        dispatchSuccess("Reversal initiated");
        setIsOpen(false);
        window.location.href = `/reversals/${reversal.id}`;
      })
      .catch((error) => {
        try {
          const {
            errors: { message },
          } = JSON.parse(error.message);
          dispatchError(message);
        } catch {
          dispatchError("Sorry but we could not initiate this reversal.");
        }
      });
    setSubmitting(false);
  }

  function onReversalCancel() {
    trackEvent(null, REVERSE_MODAL_EVENTS.REVERSE_MODAL_BACK_BUTTON_CLICKED);
    setIsOpen(false);
  }

  return (
    <ConfirmModal
      title="Reverse Payment Order"
      isOpen={isOpen}
      onRequestClose={() => setIsOpen(false)}
      onAfterOpen={() =>
        trackEvent(null, REVERSE_MODAL_EVENTS.REVERSE_MODAL_OPENED)
      }
      confirmText="Initiate Reversal"
      confirmDisabled={submitting}
      onConfirm={onReversalSubmission}
      secondaryButtonDisabled={submitting}
      setIsOpen={onReversalCancel}
    >
      <form className="form-create">
        <div className="form-section">
          <div className="form-row form-row-full flex">
            Please select the reason you are reversing this payment order.
            Payment orders may only be reversed if one of these reasons applies.
          </div>
        </div>
        <div className="form-section">
          <div className="form-row form-row-full flex">
            The reversal should be initiated within 24 hours of discovering the
            error. If you are reversing for an invalid reason or outside of this
            timeline, you will be in violation of NACHA rules.
          </div>
        </div>
        <div className="form-section">
          <div className="form-row form-row-full flex">
            <span>
              {"For more information see our "}
              <a
                href="https://docs.moderntreasury.com/docs/reversing-a-payment-
                order"
                target="_blank"
                rel="noreferrer"
              >
                Guide to Reversals
              </a>
            </span>
          </div>
        </div>
        <div>
          <div className="form-row-full mt-8 flex">
            <FieldGroup direction="left-to-right">
              <Label id="reversal-reason">Reason for reversal</Label>
              <SelectField
                required
                name="reversal-reason"
                classes="w-80"
                options={[
                  { label: "Duplicate", value: "duplicate" },
                  { label: "Incorrect Amount", value: "incorrect_amount" },
                  {
                    label: "Incorrect Receiving Account",
                    value: "incorrect_receiving_account",
                  },
                  ...(paymentOrderDirection === "credit"
                    ? [
                        {
                          label: "Date Later Than Intended",
                          value: "date_later_than_intended",
                        },
                      ]
                    : []),
                  ...(paymentOrderDirection === "debit"
                    ? [
                        {
                          label: "Date Earlier Than Intended",
                          value: "date_earlier_than_intended",
                        },
                      ]
                    : []),
                ]}
                selectValue={state.reason}
                handleChange={(key, field) => {
                  const { value } = field;
                  setState({ ...state, reason: value });
                }}
              />
            </FieldGroup>
          </div>
        </div>
      </form>
    </ConfirmModal>
  );
}

export default ReverseModal;
```

---
## `ReversalStatusBadge.tsx.txt`
**Path:** `.`  
```
import { startCase } from "lodash";
import React from "react";
import { Reversal__StatusEnum } from "../../generated/dashboard/graphqlSchema";
import { Badge, BadgeType } from "../../common/ui-components";

interface ReversalStatusBadgeProps {
  status: Reversal__StatusEnum;
  keepCaseFormat?: boolean;
}

function ReversalStatusBadge({
  status,
  keepCaseFormat = false,
}: ReversalStatusBadgeProps): JSX.Element {
  let badgeType: BadgeType;
  switch (status) {
    case Reversal__StatusEnum.Completed: {
      badgeType = BadgeType.Success;
      break;
    }
    case Reversal__StatusEnum.Failed: {
      badgeType = BadgeType.Critical;
      break;
    }
    case Reversal__StatusEnum.Pending: {
      badgeType = BadgeType.Cool;
      break;
    }
    case Reversal__StatusEnum.Processing: {
      badgeType = BadgeType.Default;
      break;
    }
    case Reversal__StatusEnum.Returned: {
      badgeType = BadgeType.Warning;
      break;
    }
    case Reversal__StatusEnum.Sent: {
      badgeType = BadgeType.Purple;
      break;
    }
    default: {
      badgeType = BadgeType.Warning;
      break;
    }
  }

  return (
    <Badge
      text={startCase(status)}
      type={badgeType}
      keepCaseFormat={keepCaseFormat}
    />
  );
}

export default ReversalStatusBadge;
```

---
## `RuleApproversList.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button, Stack } from "~/common/ui-components";
import { RequiredReviewer } from "../../generated/dashboard/graphqlSchema";

function RuleApproversList({
  requiredReviewers,
}: {
  requiredReviewers: RequiredReviewer[];
}) {
  return (
    <Stack className="gap-4">
      {requiredReviewers?.map(
        (
          requiredReviewer: RequiredReviewer,
          requiredReviewerIndex: number,
          requiredReviewerArray: RequiredReviewer[],
        ) => {
          const lastReviewer =
            requiredReviewerArray.length - 1 === requiredReviewerIndex;
          const groups = requiredReviewer.conditionalGroups?.map(
            (group, groupIndex, groupArray) => {
              const lastElement = groupArray.length - 1 === groupIndex;
              return (
                <>
                  <Button
                    buttonType="link"
                    display="inline-block"
                    onClick={(): void => {
                      window.open(group?.path, "_blank");
                    }}
                  >
                    {group?.name}
                  </Button>
                  {!lastElement && " or "}
                </>
              );
            },
          );

          return (
            <>
              <span>
                {requiredReviewer.numberOfReviewers}
                {requiredReviewer.numberOfReviewers > 1
                  ? " Approvals"
                  : " Approval"}{" "}
                from {groups}
              </span>
              {!lastReviewer && (
                <div className="flex items-center">
                  <div className="w-fit gap-1 rounded bg-gray-50 px-2 py-1
                  capitalize">
                    And
                  </div>
                  <div className="h-px w-full bg-gray-100" />
                </div>
              )}
            </>
          );
        },
      )}
    </Stack>
  );
}

export default RuleApproversList;
```

---
## `RuleConditionsList.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Chip, Stack } from "~/common/ui-components";
import { RuleCondition } from "../../generated/dashboard/graphqlSchema";

function RuleConditionsList({
  allRequiredConditions,
  operator,
}: {
  allRequiredConditions: RuleCondition[][];
  operator: string;
}) {
  return (
    <Stack className="gap-4">
      {allRequiredConditions?.map(
        (currentRequiredConditions, requiredConditionsIndex, array) => {
          const lastElement = array.length - 1 === requiredConditionsIndex;

          return (
            <>
              {currentRequiredConditions.map((condition, index) => {
                const firstElement = index === 0;
                return (
                  <div className="flex gap-4">
                    {firstElement ? "When" : "And"}
                    <div className="flex gap-px">
                      <Chip contentClassName="rounded-l-sm">
                        {condition.prettyKey}
                      </Chip>
                      <Chip
                        condition={condition.operator}
                        negate={condition.negate}
                        contentClassName="rounded-none"
                      />
                      <div>
                        {condition.prettyValue.map((value) => (
                          <Chip contentClassName="rounded-r-sm">
                            {value.prettyContent}
                          </Chip>
                        ))}
                      </div>
                    </div>
                  </div>
                );
              })}
              {!lastElement && (
                <div className="flex items-center">
                  <div className="w-fit gap-1 rounded bg-gray-50 px-2 py-1
                  capitalize">
                    {operator}
                  </div>
                  <div className="h-px w-full bg-gray-100" />
                </div>
              )}
            </>
          );
        },
      )}
    </Stack>
  );
}

export default RuleConditionsList;
```

---
## `RuleForm.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useDispatch } from "react-redux";
import { startSubmit, stopSubmit } from "redux-form";
import { RULE_RESOURCE_TYPE_MAPPING } from "../constants";
import {
  useRulesFormQuery,
  useUpsertRuleMutation,
  RuleResourceTypeEnum,
} from "../../generated/dashboard/graphqlSchema";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { Button } from "../../common/ui-components";
import RuleApproverSection from "./rules/RuleApproverSection";
import RuleConditionSection from "./rules/RuleConditionSection";
import { normalizeRuleData } from "./rules/NormalizeRuleData";
import { useDispatchContext } from "../MessageProvider";
import { UIRuleData } from "../types/RuleConditionFieldValueInput";
import { RuleFormValues } from "../constants/rule_form";
import { PageHeader } from "../../common/ui-components/PageHeader/PageHeader";

const NEW_CONDITION_KEY = "newCondition";

function RuleForm({
  id,
  initialValues,
  isEditForm,
}: {
  id: string | null;
  initialValues: RuleFormValues;
  isEditForm: boolean;
}) {
  const [rule, setRule] = useState<RuleFormValues>(initialValues);
  const productPath =
    rule.resourceType === RuleResourceTypeEnum.ComplianceCase
      ? "compliance"
      : "payments";
  const rulesPath =
  `/settings/${productPath}/rules?resourceType=${rule.resourceType}`;
  const dispatch = useDispatch();

  const { data: queryData, loading } = useRulesFormQuery();
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  const [upsertRule] = useUpsertRuleMutation();

  function cancelRuleEdit() {
    window.location.href = rulesPath;
  }

  function renderEditRule() {
    const handleUpsertRule = () => {
      dispatch(startSubmit("rule"));

      // Remove empty condition if left
      const ruleData = rule.data;
      delete ruleData[NEW_CONDITION_KEY];

      upsertRule({
        variables: {
          input: {
            id: rule.id,
            data: JSON.stringify(normalizeRuleData(ruleData as UIRuleData)),
            key: rule.key,
            resourceType: rule.resourceType,
            groups: rule.groups,
            name: rule.name,
            requiredReviewers: [],
          },
        },
      })
        .then((upsertRuleData) => {
          const errors = upsertRuleData.data?.upsertRule?.errors;
          const rulePath = upsertRuleData.data?.upsertRule?.rule?.path;

          if (errors?.length) {
            dispatchError(errors.toString());
          } else if (rulePath) {
            window.location.href = rulePath;
            dispatchSuccess("Success!");
          } else {
            dispatchError("An error occurred");
          }
        })
        .catch(() => {
          dispatchError("An error occurred");
        })
        .finally(() => dispatch(stopSubmit("rule")));
    };

    const onNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const newRule = {
        ...rule,
        name: e.target.value,
      };

      setRule(newRule);
    };

    return (
      <div key={id} className="form-create form-create-wide form-create-rules">
        <div className="form-section w-1/3">
          <ReduxInputField
            input={{
              onChange: onNameChange,
              value: rule.name || "",
              name: "name",
            }}
            label="Name"
            type="text"
            dataField="name"
            placeholder="Rule Name"
          />
        </div>
        <div className="form-section">
          <RuleConditionSection
            id={id}
            rule={rule}
            queryData={queryData}
            resourceType={initialValues.resourceType}
            loading={loading}
            setRule={setRule}
          />
        </div>
        <RuleApproverSection
          id={id}
          rule={rule}
          queryData={queryData}
          loading={loading}
          setRule={setRule}
        />
        <div className="flex flex-row space-x-4">
          <Button buttonType="primary" onClick={() => handleUpsertRule()}>
            {isEditForm ? "Update" : "Create Rule"}
          </Button>
          <Button onClick={() => cancelRuleEdit()}>Cancel</Button>
        </div>
      </div>
    );
  }

  return (
    <PageHeader
      crumbs={[
        {
          ...RULE_RESOURCE_TYPE_MAPPING[rule.resourceType].headerCrumbs,
        },
      ]}
      title={`${isEditForm ? "Update" : "New"} ${
        RULE_RESOURCE_TYPE_MAPPING[rule.resourceType].name
      } Rule`}
    >
      {renderEditRule()}
    </PageHeader>
  );
}

export default RuleForm;
```

---
## `SaveReportModal.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import { ConfirmModal } from "../../common/ui-components";

interface SaveReportModalProps {
  saveReport: (name: string) => void;
  openModal: boolean;
  title: string;
  closeModal: () => void;
  reportName: string;
}

function SaveReportModal({
  saveReport,
  title,
  openModal,
  closeModal,
  reportName,
}: SaveReportModalProps) {
  const [name, setName] = useState(reportName);

  const saveReportFunc = () => {
    saveReport(name);
  };

  return (
    <ConfirmModal
      title={title}
      isOpen={openModal}
      setIsOpen={closeModal}
      confirmText="Save"
      onConfirm={saveReportFunc}
    >
      <ReduxInputField
        required
        input={{
          onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
            setName(e.target.value),
          value: name,
          name: "name",
          id: "name",
        }}
        label="Report Name"
        type="text"
        placeholder="New Report"
      />
    </ConfirmModal>
  );
}

export default SaveReportModal;
```

---
## `ScheduleReportModal.tsx.txt`
**Path:** `.`  
```
import { FormikProps } from "formik";
import React, { useRef } from "react";
import { ConfirmModal } from "../../common/ui-components";
import {
  ScheduleInput,
  useDeleteScheduleMutation,
  useReportScheduleDetailsQuery,
} from "../../generated/dashboard/graphqlSchema";
import { useDispatchContext } from "../MessageProvider";
import ScheduleForm, {
  ScheduleFormValues,
  scheduleFormValuesToInputType,
  scheduleInputTypeToFormValues,
  DEFAULT_VALUES,
} from "./forms/ScheduleForm";

const SUBTITLE =
  "An email with a link to download an export will be sent on the specified
  scheduled to all users with permissions to view this report.";

interface ScheduleModalProps {
  setIsOpen: React.Dispatch<React.SetStateAction<boolean>>;
  reportId: string;
  reportName: string;
  saveReport: (newName: string, schedule?: ScheduleInput) => void;
}

function ScheduleReportModal({
  setIsOpen,
  reportId,
  reportName,
  saveReport,
}: ScheduleModalProps) {
  const formRef = useRef<FormikProps<ScheduleFormValues>>(null);

  const [deleteSchedule] = useDeleteScheduleMutation();
  const { dispatchError, dispatchSuccess } = useDispatchContext();

  const { data, loading } = useReportScheduleDetailsQuery({
    variables: { reportId },
  });
  const initialValues = data?.report?.schedule
    ? scheduleInputTypeToFormValues(data.report.schedule)
    : DEFAULT_VALUES;

  function handleModalClose() {
    setIsOpen(false);
  }

  function confirmDeleteSchedule() {
    if (!data?.report?.schedule) return;

    deleteSchedule({
      refetchQueries: [
        "ReportDetailsTable",
        "ReportScheduleDetails",
        "ReportHeader",
      ],
      variables: { input: { id: data.report.schedule.id } },
    })
      .then((response) => {
        const { errors = [] } = response.data?.deleteSchedule || {};
        if (errors.length) {
          dispatchError(errors.toString());
        } else {
          dispatchSuccess("Schedule deleted.");
        }
      })
      .catch(() => dispatchError("Sorry, we could not delete the schedule."));

    setIsOpen(false);
  }

  async function confirmScheduleReport() {
    if (!formRef.current) return;

    const errors = await formRef.current.validateForm();
    // validateForm() does not update/display error messages on "untouched"
    fields, so this code
    // is necessary to ensure all errors are displayed.
    void formRef.current.setTouched({
      ...formRef.current.touched,
      ...(errors as Record<string, string>),
    });

    if (!formRef.current.isValid) return;

    saveReport(
      reportName,
      scheduleFormValuesToInputType(formRef.current.values),
    );

    setIsOpen(false);
  }

  return !loading ? (
    <ConfirmModal
      title={`Schedule "${reportName}"`}
      subtitle={SUBTITLE}
      confirmText={data?.report?.schedule ? "Save Changes" : "Save"}
      onConfirm={() => {
        void confirmScheduleReport();
      }}
      setIsOpen={confirmDeleteSchedule}
      cancelText={data?.report?.schedule ? "Remove Schedule" : undefined}
      cancelButtonType="destructive"
      onRequestClose={handleModalClose}
      enableCloseIcon
      isOpen
    >
      <ScheduleForm initialValues={initialValues} formRef={formRef} />
    </ConfirmModal>
  ) : null;
}

export default ScheduleReportModal;
```

---
## `ScimConfirmationModal.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { ConfirmModal } from "~/common/ui-components";

interface ScimConfirmationModalProps {
  onConfirm: () => void;
  isOpen: boolean;
  handleModalClose: () => void;
}

function ScimConfirmationModal({
  onConfirm,
  isOpen,
  handleModalClose,
}: ScimConfirmationModalProps) {
  return (
    <ConfirmModal
      title="Are you sure you want to enable SCIM for this organization?"
      isOpen={isOpen}
      setIsOpen={handleModalClose}
      onConfirm={onConfirm}
      confirmText="Enable"
      bodyClassName="max-h-96 overflow-y-scroll"
    />
  );
}

export default ScimConfirmationModal;
```

---
## `SessionExpiredOverlay.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Button } from "../../common/ui-components";

function SessionExpiredOverlay() {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center rounded
    bg-gray-200 bg-opacity-70">
      <div className="flex flex-col items-center justify-center gap-2 bg-white
      p-10">
        <span className="text-lg font-medium">Session Expired</span>
        <span className="mb-4">Use the button below to refresh the page.</span>
        <Button onClick={() => window.location.reload()}>Reload</Button>
      </div>
    </div>
  );
}

export default SessionExpiredOverlay;
```

---
## `ShareReportModal.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import {
  useShareReportModalQuery,
  ReportingPermissionFragment,
  ReportingPermission__PermissionEnum,
  ReportingPermission__ResourceEnum,
  useUpsertReportingPermissionsMutation,
} from "../../generated/dashboard/graphqlSchema";
import UserGroupSelect from "./UserGroupSelect";
import { ConfirmModal, SelectField } from "../../common/ui-components";
import { useDispatchContext } from "../MessageProvider";

interface ShareReportModalProps {
  openModal: boolean;
  closeModal: () => void;
  reportId: string;
  initialReportingPermissions: ReportingPermissionFragment[];
}

const PERMISSION_OPTIONS = [
  { value: ReportingPermission__PermissionEnum.Read, label: "Viewer" },
  { value: ReportingPermission__PermissionEnum.None, label: "No Access" },
];

type Actor = ReportingPermissionFragment["actor"];

function getActorName(actor: Actor): string {
  switch (actor.typename) {
    case "OrganizationUser":
      return actor.user.name || actor.user.email;
    case "Group":
      return actor.name;
    default:
      return "";
  }
}

function getActorSubtext(actor: Actor): string {
  switch (actor.typename) {
    case "OrganizationUser":
      return actor.user.email;
    case "Group":
      return "Role";
    default:
      return "";
  }
}

function ShareReportModal({
  openModal,
  closeModal,
  reportId,
  initialReportingPermissions,
}: ShareReportModalProps) {
  const { dispatchError } = useDispatchContext();
  const [upsertReportingPermissions] = useUpsertReportingPermissionsMutation({
    refetchQueries: ["ShareReportModal"],
  });

  const [reportingPermissions, setReportingPermissions] = useState<
    ReportingPermissionFragment[]
  >(initialReportingPermissions);

  const saveFunc = () => {
    upsertReportingPermissions({
      refetchQueries: ["ReportDetailsTable"],
      variables: {
        input: {
          resourceId: reportId,
          resourceType: ReportingPermission__ResourceEnum.Report,
          input: reportingPermissions.map((reportingPermission) => ({
            permission: reportingPermission.permission,
            actorId: reportingPermission.actor.id,
            actorType: reportingPermission.actor.typename,
          })),
        },
      },
    })
      .then((response) => {
        const { errors = [] } = response.data?.upsertReportingPermissions || {};
        if (errors.length) {
          dispatchError(errors.toString());
        } else {
          closeModal();
        }
      })
      .catch(() => dispatchError("Sorry, could not update permissions"));
  };

  function onPermissionSelect(
    actor: Actor,
    permission: ReportingPermission__PermissionEnum,
  ) {
    setReportingPermissions(
      reportingPermissions.map((reportingPermission) => {
        if (reportingPermission.actor.id === actor.id) {
          return {
            ...reportingPermission,
            permission,
          };
        }
        return reportingPermission;
      }),
    );
  }

  function onSelectUserGroup(value: Actor) {
    if (
      reportingPermissions.some(
        (reportingPermission) => reportingPermission.actor.id === value.id,
      )
    ) {
      // already exists
      return;
    }
    const newReportingPermission: ReportingPermissionFragment = {
      id: value.id,
      actor: value,
      permission: ReportingPermission__PermissionEnum.Read,
    };

    setReportingPermissions([newReportingPermission, ...reportingPermissions]);
  }

  return (
    <ConfirmModal
      title="Manage Access"
      isOpen={openModal}
      setIsOpen={closeModal}
      confirmText="Save"
      onConfirm={saveFunc}
    >
      <div className="flex flex-col">
        <div className="pb-4 pr-4">
          <UserGroupSelect
            onChange={(value?: Actor) => value && onSelectUserGroup(value)}
          />
        </div>
        <div className="index-table table-permissions table w-full">
          <div className="table-body max-h-96 overflow-y-auto">
            {reportingPermissions.map(({ id, actor, permission }) => (
              <div key={id} className="index-table-row">
                <div className="table-entry flex flex-col">
                  <div className="flex-grow">{getActorName(actor)}</div>
                  <div className="flex-grow text-gray-600">
                    {getActorSubtext(actor)}
                  </div>
                </div>
                <div className="table-entry table-entry-allow-overflow max-w-3xs
                pr-4">
                  <SelectField
                    placeholder="Permission"
                    selectValue={permission}
                    options={PERMISSION_OPTIONS}
                    handleChange={(
                      value: ReportingPermission__PermissionEnum,
                    ) => onPermissionSelect(actor, value)}
                    required
                  />
                </div>
              </div>
            ))}
            <div className="h-28" />
          </div>
        </div>
      </div>
    </ConfirmModal>
  );
}

interface ShareReportModalLoaderProps {
  openModal: boolean;
  closeModal: () => void;
  reportId: string;
}

function ShareReportModalLoader({
  openModal,
  closeModal,
  reportId,
}: ShareReportModalLoaderProps) {
  const { loading, data } = useShareReportModalQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      resourceId: reportId,
      resourceType: ReportingPermission__ResourceEnum.Report,
    },
  });

  if (loading || !data) {
    return null;
  }

  return (
    <ShareReportModal
      openModal={openModal}
      closeModal={closeModal}
      reportId={reportId}
      initialReportingPermissions={data.reportingPermissions}
    />
  );
}

export default ShareReportModalLoader;
```

---
## `SourceIcon.tsx.txt`
**Path:** `.`  
```
import React from "react";
import ReactTooltip from "react-tooltip";
import { Icon } from "../../common/ui-components";

export default function SourceIcon({
  createdFromDirectory,
  entityType,
}: {
  createdFromDirectory: boolean;
  entityType: string;
}) {
  const dataTip = `This ${entityType} is ${
    createdFromDirectory ? "" : "not "
  }managed by directory sync`;
  return (
    <>
      <span data-tip={dataTip}>
        <Icon
          iconName={createdFromDirectory ? "lock" : "lock_open_outlined"}
          size="s"
        />
      </span>
      <ReactTooltip className="whitespace-pre-wrap" multiline />
    </>
  );
}
```

---
## `StringReconciliationMatchResult.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { Label, SelectField, Autosuggest } from "../../common/ui-components";

interface StringReconciliationMatchResultProps {
  selectField: string | null | undefined;
  selectFieldOptions: {
    value: string;
    label: string;
  }[];
  suggestedMatcher: string | null | undefined;
  matcher: string | null;
  callback: (
    matchResultType: string | null | undefined,
    matcher: string | null,
    parser: string | null | undefined,
    showParser: boolean | null | undefined,
    transactionField: string | null | undefined,
    startDate: string | null,
    endDate: string | null,
  ) => void;
}

function StringReconciliationMatchResult({
  selectField,
  selectFieldOptions,
  matcher,
  suggestedMatcher,
  callback,
}: StringReconciliationMatchResultProps) {
  const matcherValue =
    selectField === "Matches" &&
    matcher &&
    matcher.startsWith("/") &&
    matcher.endsWith("/")
      ? matcher.slice(1, -1)
      : matcher || "";

  return (
    <div className="flex w-full">
      <div className="min-w-36">
        <SelectField
          className="justify-left flex"
          handleChange={(e) => {
            if (selectField === "Any" || e === "Is Null") {
              callback(e as string, null, null, null, null, null, null);
            } else if (
              e === "Matches" &&
              (!matcherValue.startsWith("/") || !matcherValue.endsWith("/"))
            ) {
              callback(
                e as string,
                `/${matcherValue}/`,
                null,
                null,
                null,
                null,
                null,
              );
            } else if (
              e === "Equals" &&
              matcherValue.startsWith("/") &&
              matcherValue.endsWith("/")
            ) {
              callback(
                e as string,
                matcherValue.slice(1, -1),
                null,
                null,
                null,
                null,
                null,
              );
            } else if (e === "Any") {
              callback(e as string, "any", null, null, null, null, null);
            } else {
              callback(e as string, matcherValue, null, null, null, null, null);
            }
          }}
          id="select-id"
          name="select-name"
          selectValue={selectField}
          options={selectFieldOptions}
        />
      </div>

      {selectField !== "Any" && selectField !== "Is Null" ? (
        <div className="flex w-full flex-col">
          <div className="flex w-full">
            {selectField === "Matches" ? (
              <Label className="mb-4 self-center px-1">/</Label>
            ) : null}

            <Autosuggest
              className="justify-right w-full"
              onChange={(e) => {
                if (selectField === "Matches") {
                  callback(
                    selectField,
                    `/${e.target.value}/`,
                    null,
                    null,
                    null,
                    null,
                    null,
                  );
                } else {
                  callback(
                    selectField,
                    e.target.value,
                    null,
                    null,
                    null,
                    null,
                    null,
                  );
                }
              }}
              onSuggestionSelect={(e, suggestion) => {
                if (selectField === "Matches" || selectField === "Equals") {
                  if (
                    suggestion.suggestionValue.startsWith("/") &&
                    suggestion.suggestionValue.endsWith("/")
                  ) {
                    callback(
                      "Matches",
                      suggestion.suggestionValue,
                      null,
                      null,
                      null,
                      null,
                      null,
                    );
                  } else {
                    callback(
                      "Equals",
                      suggestion.suggestionValue,
                      null,
                      null,
                      null,
                      null,
                      null,
                    );
                  }
                } else {
                  callback(
                    selectField,
                    suggestion.suggestionValue,
                    null,
                    null,
                    null,
                    null,
                    null,
                  );
                }
              }}
              value={matcherValue}
              suggestions={
                suggestedMatcher
                  ? [
                      {
                        label: `Suggested: ${suggestedMatcher}`,
                        value: suggestedMatcher,
                      },
                    ]
                  : [
                      {
                        label: "No Suggestion",
                        value: matcherValue,
                      },
                    ]
              }
              placeholder="Enter a value"
            />

            {selectField === "Matches" ? (
              <Label className="mb-4 self-center px-1">/</Label>
            ) : null}
          </div>
        </div>
      ) : null}
    </div>
  );
}
export default StringReconciliationMatchResult;
```

---
## `ToggleableAddressForm.tsx.txt`
**Path:** `.`  
```
import React, { useState, useEffect } from "react";
import isNil from "lodash/isNil";

import { FormAction } from "redux-form";
import AddressForm from "./AddressForm";
import { Button, Icon } from "../../common/ui-components";

interface ToggleableAddressFormProps {
  formName: string;
  fieldName: string;
  isDisabled?: boolean;
  address: Record<string, unknown>;
  addressName: string;
  reduxChange(
    form: string,
    field: string,
    value: unknown,
    touch?: boolean,
    persistentSubmitErrors?: boolean,
  ): FormAction;
}

function ToggleableAddressForm({
  formName,
  fieldName,
  isDisabled,
  address,
  addressName,
  reduxChange,
}: ToggleableAddressFormProps) {
  const [showAddressForm, setShowAddressForm] = useState(false);
  useEffect(() => {
    if (!isNil(address) && !isNil(address.id)) {
      setShowAddressForm(true);
    }
  }, [address]);

  if (!showAddressForm) {
    return (
      <div className="mt-3">
        <Button onClick={() => setShowAddressForm(true)}>
          <Icon iconName="add" />
          Add Address
        </Button>
      </div>
    );
  }
  return (
    <div>
      <AddressForm
        fieldName={fieldName}
        isDisabled={isDisabled}
        address={address}
        addressName={addressName}
      />
      <div className="mt-3">
        <Button
          onClick={() => {
            reduxChange(
              formName,
              `${fieldName}.${addressName}`,
              null,
              false,
              false,
            );
            setShowAddressForm(false);
          }}
        >
          <Icon
            iconName="clear"
            size="xs"
            color="currentColor"
            className="text-gray-300"
          />
          Remove Address
        </Button>
      </div>
    </div>
  );
}

export default ToggleableAddressForm;
```

---
## `UnreconcileTransactionModalContent.tsx.txt`
**Path:** `.`  
```
import React from "react";
import {
  Button,
  Heading,
  Icon,
  LoadingLine,
  ModalActions,
  ModalContent,
  ModalDescription,
  ModalHeader,
  ModalTitle,
} from "../../common/ui-components";

export interface UnreconcileTransactionData {
  id: string;
  amount: string;
  prettyAmount: string;
  currency: string;
  unreconcilable: boolean;
  expectedPaymentCount: number;
  prettyExpectedPaymentAmount: string;
  prettyTransactionExpectedPaymentDifference: string;
  expectedPaymentIds: string[];
  prettyAmountUnreconciledToExpectedPayment?: string;
}

export function UnreconcileTransactionModalLoading() {
  return (
    <>
      <ModalHeader className="-mb-4 border-none">
        <ModalTitle>
          <Heading level="h3" size="l">
            Confirm Unreconciliation
          </Heading>
          <ModalDescription>
            By unreconciling this transaction, any associated reconciled items
            will also be unreconciled.
          </ModalDescription>
        </ModalTitle>
      </ModalHeader>
      <ModalContent className="border-none">
        <div className="mb-4 rounded-md border px-4 py-3">
          <div className="mb-4 flex flex-row justify-between text-gray-700">
            <div className="w-40">
              <LoadingLine />
            </div>
            <div className="w-24">
              <LoadingLine />
            </div>
          </div>
          <div className="mb-4 flex flex-row justify-between text-gray-700">
            <div className="w-40">
              <LoadingLine />
            </div>
            <div className="w-24">
              <LoadingLine />
            </div>
          </div>
          <div className="my-4 border-t border-gray-100" />
          <div className="flex flex-row justify-between text-gray-700">
            <div className="w-40">
              <LoadingLine />
            </div>
            <div className="w-24">
              <LoadingLine />
            </div>
          </div>
        </div>
      </ModalContent>
    </>
  );
}

export function UnreconcileTransactionModalContent({
  transactions,
  exitModal,
}: {
  transactions: UnreconcileTransactionData[];
  exitModal: () => void;
}) {
  return (
    <>
      <ModalHeader className="-mb-3 border-none">
        <ModalTitle>
          <Heading level="h3" size="l">
            {transactions.length === 1
              ? "Confirm Unreconciliation"
              : `Unreconcile ${transactions.length} Matches`}
          </Heading>
          <ModalDescription>
            By unreconciling this transaction, any associated reconciled items
            will also be unreconciled.
          </ModalDescription>
        </ModalTitle>
        <ModalActions>
          <Button onClick={exitModal} buttonType="text">
            <Icon
              iconName="clear"
              color="currentColor"
              className="text-gray-500"
            />
          </Button>
        </ModalActions>
      </ModalHeader>
      <ModalContent
        className={`border-none ${
          transactions.length > 3 ? "h-[630px] overflow-y-auto" : ""
        }`}
      >
        {transactions.map((transaction) => (
          <div
            className={`mb-4 rounded-md border px-4 py-3 ${
              transactions.length > 3 ? "overflow-y-auto" : ""
            }`}
            key={transaction.id}
          >
            <div className="mb-4 flex flex-row justify-between text-gray-700">
              <div className="font-medium">Bank Transactions</div>
              <div>{transaction.prettyAmount}</div>
            </div>
            <div className="mb-4 flex flex-row justify-between text-gray-700">
              <div className="font-medium">
                Expected Payments ({transaction.expectedPaymentCount})
              </div>
              <div>{transaction.prettyExpectedPaymentAmount}</div>
            </div>
            <div className="my-4 border-t border-gray-100" />
            <div className="flex flex-row justify-between text-gray-700">
              <div className="font-medium">Differences</div>
              <div>
                {transaction.prettyTransactionExpectedPaymentDifference}
              </div>
            </div>
          </div>
        ))}
      </ModalContent>
    </>
  );
}
```

---
## `UpdateComplianceSettingsForm.tsx.txt`
**Path:** `.`  
```
import { Field, Form, Formik, FormikErrors } from "formik";
import React, { useCallback, useEffect, useState } from "react";
import {
  FormikCheckboxField,
  FormikErrorMessage,
  FormikInputField,
  FormikSelectField,
} from "../../common/formik";
import {
  Button,
  FieldGroup,
  Label,
  SelectGroup,
} from "../../common/ui-components";
import { parse, stringify } from "../../common/utilities/queryString";
import {
  Decision__ScoreEnum,
  useAdminOrganizationComplianceSettingQuery,
  useAdminUpdateOrganizationComplianceSettingMutation,
} from "../../generated/dashboard/graphqlSchema";
import { DECISION_SCORE_OPTIONS } from "../constants";
import { useDispatchContext } from "../MessageProvider";

interface FormValues {
  sardineClientId: string;
  sardineApiKey: string;
  middeskApiKey: string;
  userOnboardingEnabled: boolean[];
  transactionMonitoringEnabled: boolean[];
  autoFeedbackOnReturns: boolean[];
  maxAutoApproveScore: Decision__ScoreEnum | null;
  minAutoDenyScore: Decision__ScoreEnum | null;
}

const INITIAL_FORM_VALUES = {
  sardineClientId: "",
  sardineApiKey: "",
  middeskApiKey: "",
  userOnboardingEnabled: [false],
  transactionMonitoringEnabled: [false],
  autoFeedbackOnReturns: [false],
  maxAutoApproveScore: null,
  minAutoDenyScore: null,
};

const ACCOUNT_TYPE_OPTIONS = [
  { value: "true", text: "Live", id: "live" },
  { value: "false", text: "Sandbox", id: "sandbox" },
];

interface UpdateComplianceSettingsFormProps {
  organizationId: string;
}

function UpdateComplianceSettingsForm({
  organizationId,
}: UpdateComplianceSettingsFormProps) {
  const { dispatchError, dispatchSuccess } = useDispatchContext();
  const { liveMode: initialLiveMode } = parse(window.location.search);
  const [initialFormValues, setInitialFormValues] = useState<FormValues>(
    {} as FormValues,
  );
  const [liveMode, setLiveMode] = useState<boolean>(
    initialLiveMode === undefined ? true : initialLiveMode === "true",
  );
  const [adminUpdateOrganizationComplianceSettings] =
    useAdminUpdateOrganizationComplianceSettingMutation({
      refetchQueries: ["AdminOrganizationComplianceSetting"],
    });
  const { data, refetch } = useAdminOrganizationComplianceSettingQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      organizationId,
      liveMode,
    },
  });
  const organizationComplianceSetting =
    data?.adminOrganizationComplianceSetting;
  const decisionScoreOptions = [
    { label: "None", value: null },
    ...DECISION_SCORE_OPTIONS,
  ];

  useEffect(() => {
    if (organizationComplianceSetting) {
      setInitialFormValues({
        sardineClientId: organizationComplianceSetting?.sardineClientId || "",
        sardineApiKey: organizationComplianceSetting?.sardineApiKey || "",
        middeskApiKey: organizationComplianceSetting?.middeskApiKey || "",
        userOnboardingEnabled: [
          organizationComplianceSetting?.userOnboardingEnabled,
        ],
        transactionMonitoringEnabled: [
          organizationComplianceSetting?.transactionMonitoringEnabled,
        ],
        autoFeedbackOnReturns: [
          organizationComplianceSetting?.autoFeedbackOnReturns,
        ],
        maxAutoApproveScore:
          organizationComplianceSetting?.maxAutoApproveScore || null,
        minAutoDenyScore:
          organizationComplianceSetting?.minAutoDenyScore || null,
      });
    } else {
      setInitialFormValues(INITIAL_FORM_VALUES);
    }
  }, [organizationComplianceSetting]);

  const userOnboardingEnabledValue = (userOnboardingEnabled: boolean[]) => {
    const uoValueLength = userOnboardingEnabled?.length;
    const isUserOnboardingEnabled =
      uoValueLength > 0 ? userOnboardingEnabled[uoValueLength - 1] : false;
    return isUserOnboardingEnabled;
  };

  const transactionMonitoringEnabledValue = (
    transactionMonitoringEnabled: boolean[],
  ) => {
    const tmValueLength = transactionMonitoringEnabled?.length;
    const isTransactionMonitoringEnabled =
      tmValueLength > 0
        ? transactionMonitoringEnabled[tmValueLength - 1]
        : false;
    return isTransactionMonitoringEnabled;
  };

  const autoFeedbackOnReturnsValue = (autoFeedbackOnReturns: boolean[]) => {
    const afValueLength = autoFeedbackOnReturns?.length;
    const isAutoFeedbackOnReturns =
      afValueLength > 0 ? autoFeedbackOnReturns[afValueLength - 1] : false;
    return isAutoFeedbackOnReturns;
  };

  const updateComplianceSettings = async (values: FormValues) => {
    const userOnboardingEnabled = userOnboardingEnabledValue(
      values.userOnboardingEnabled,
    );
    const transactionMonitoringEnabled = transactionMonitoringEnabledValue(
      values.transactionMonitoringEnabled,
    );

    const autoFeedbackOnReturns = autoFeedbackOnReturnsValue(
      values.autoFeedbackOnReturns,
    );

    const updateComplianceSettingsInput = {
      organizationId,
      liveMode,
      sardineClientId: values.sardineClientId,
      sardineApiKey: values.sardineApiKey,
      middeskApiKey: values.middeskApiKey,
      userOnboardingEnabled,
      transactionMonitoringEnabled,
      autoFeedbackOnReturns,
      maxAutoApproveScore: values.maxAutoApproveScore,
      minAutoDenyScore: values.minAutoDenyScore,
    };

    const response = await adminUpdateOrganizationComplianceSettings({
      variables: {
        input: {
          input: updateComplianceSettingsInput,
        },
      },
    });

    if (response?.data?.adminUpdateOrganizationComplianceSetting?.errors) {
      dispatchError("Sorry, but something went wrong.");
    } else {
      dispatchSuccess("The organization settings were updated successfully.");
    }
  };

  const validate = (values: FormValues) => {
    let errors: FormikErrors<FormValues> = {};
    const userOnboardingEnabled = userOnboardingEnabledValue(
      values.userOnboardingEnabled,
    );
    const transactionMonitoringEnabled = transactionMonitoringEnabledValue(
      values.transactionMonitoringEnabled,
    );

    if ((userOnboardingEnabled || transactionMonitoringEnabled) && liveMode) {
      if (values.sardineApiKey === "") {
        errors.sardineApiKey = "This field is required";
      }
      if (values.sardineClientId === "") {
        errors.sardineClientId = "This field is required";
      }
    }

    if (userOnboardingEnabled && !transactionMonitoringEnabled && liveMode) {
      if (
        values.sardineApiKey === "" &&
        values.sardineClientId === "" &&
        values.middeskApiKey !== ""
      ) {
        errors = {};
      }
    }

    return errors;
  };

  const onSelect = useCallback(
    (value) => {
      setLiveMode(value === "true");

      const parsedQueryString = parse(window.location.search);
      const newQuery = {
        ...parsedQueryString,
        liveMode: value === "true",
      };

      refetch({
        liveMode: value === "true",
      })
        .then(() => {
          window.history.replaceState(null, "", `?${stringify(newQuery)}`);
        })
        .catch(() => {});
    },
    [setLiveMode, refetch],
  );

  return (
    <>
      <SelectGroup
        label="Account Type"
        selectClasses="w-1/4"
        onChange={onSelect}
        value={liveMode.toString()}
        selectOptions={ACCOUNT_TYPE_OPTIONS}
      />
      <Formik
        initialValues={initialFormValues}
        onSubmit={updateComplianceSettings}
        validate={validate}
        validateOnMount
        enableReinitialize
      >
        {({ isSubmitting }) => (
          <Form className="w-1/2">
            {liveMode && (
              <>
                <FieldGroup>
                  <Label
                    id="sardineClientId"
                    helpText="Required for KYC and Transaction Monitoring
                    Activation"
                  >
                    Sardine Client ID
                  </Label>
                  <Field
                    id="sardineClientId"
                    name="sardineClientId"
                    component={FormikInputField}
                  />
                  <FormikErrorMessage name="sardineClientId" />
                </FieldGroup>
                <FieldGroup>
                  <Label
                    id="sardineApiKey"
                    helpText="Required for KYC and Transaction Monitoring
                    Activation"
                  >
                    Sardine API Key
                  </Label>
                  <Field
                    id="sardineApiKey"
                    name="sardineApiKey"
                    component={FormikInputField}
                  />
                  <FormikErrorMessage name="sardineApiKey" />
                </FieldGroup>
                <FieldGroup>
                  <Label
                    id="middeskApiKey"
                    helpText="Required for KYB Activation"
                  >
                    Middesk API Key
                  </Label>
                  <Field
                    id="middeskApiKey"
                    name="middeskApiKey"
                    component={FormikInputField}
                  />
                  <FormikErrorMessage name="middeskApiKey" />
                </FieldGroup>
              </>
            )}
            <FieldGroup>
              <div
                className={`flex flex-1 items-center gap-1 ${
                  !liveMode ? "mt-4" : ""
                }`}
              >
                <div className="mb-2">
                  <Field
                    id="userOnboardingEnabled"
                    type="checkbox"
                    name="userOnboardingEnabled"
                    value
                    component={FormikCheckboxField}
                  />
                </div>
                <Label id="userOnboardingEnabled">Enable User Onboarding</Label>
                <FormikErrorMessage name="userOnboardingEnabled" />
              </div>
              <div className="flex flex-1 items-center gap-1">
                <div className="mb-2">
                  <Field
                    id="transactionMonitoringEnabled"
                    type="checkbox"
                    name="transactionMonitoringEnabled"
                    value
                    component={FormikCheckboxField}
                  />
                </div>
                <Label id="transactionMonitoringEnabled">
                  Enable Transaction Monitoring
                </Label>
                <FormikErrorMessage name="transactionMonitoringEnabled" />
              </div>
              <div className="flex flex-1 items-center gap-1">
                <div className="mb-2">
                  <Field
                    id="autoFeedbackOnReturns"
                    type="checkbox"
                    name="autoFeedbackOnReturns"
                    value
                    component={FormikCheckboxField}
                  />
                </div>
                <Label id="autoFeedbackOnReturns">
                  Automatically Submit Decision Feedback on ACH Returns
                </Label>
                <FormikErrorMessage name="autoFeedbackOnReturns" />
              </div>
            </FieldGroup>
            <FieldGroup>
              <Label
                id="maxAutoApproveScore"
                helpText="Disables auto-approval when set to None."
              >
                Maximum Auto-approve Score
              </Label>
              <Field
                id="maxAutoApproveScore"
                type="select"
                name="maxAutoApproveScore"
                value
                component={FormikSelectField}
                options={decisionScoreOptions}
              />
              <FormikErrorMessage name="maxAutoApproveScore" />
            </FieldGroup>
            <FieldGroup>
              <Label
                id="minAutoDenyScore"
                helpText="Disables auto-denial when set to None."
              >
                Minimum Auto-deny Score
              </Label>
              <Field
                id="minAutoDenyScore"
                type="select"
                name="minAutoDenyScore"
                value
                component={FormikSelectField}
                options={decisionScoreOptions}
              />
              <FormikErrorMessage name="minAutoDenyScore" />
            </FieldGroup>
            <Button buttonType="primary" isSubmit disabled={isSubmitting}>
              Update
            </Button>
          </Form>
        )}
      </Formik>
    </>
  );
}

export default UpdateComplianceSettingsForm;
```

---
## `UpdateOrganizationForm.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { Field, Form, Formik } from "formik";
import {
  FormikCheckboxField,
  FormikErrorMessage,
  FormikInputField,
  FormikNumberFormatField,
} from "../../common/formik";
import {
  Button,
  ConfirmModal,
  CopyableText,
  FieldGroup,
  Label,
} from "../../common/ui-components";
import { isChecked } from "../utilities/CheckboxUtils";

export interface FormValues {
  name: string;
  live: boolean;
  domainName: string;
  billingCustomerId: string;
  billingSubscriptionId: string;
  mtInternalAdminTags: string;
  webhookEndpointsLimit: number;
  webhookEndpointsThrottlingEnabled: boolean[];
  sendEmailsEnabled: boolean[];
  authorizeAdminPaymentOrderApproval: boolean[];
  authorizePrebuiltUisWhitelabeling: boolean[];
  adminApprovalRuleEnabled: boolean[];
}

interface UpdateOrganizationFormProps {
  initialValues: FormValues;
  onSubmit: (values: FormValues) => Promise<void>;
  cell: string;
}

function UpdateOrganizationForm({
  initialValues,
  onSubmit,
  cell,
}: UpdateOrganizationFormProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const handleModalSubmit = (values: FormValues) => {
    setIsModalOpen(false);
    return onSubmit(values);
  };

  return (
    <Formik
      initialValues={initialValues}
      onSubmit={handleModalSubmit}
      enableReinitialize
    >
      {({ values, isSubmitting, handleSubmit }) => (
        <Form className="mb-4 flex w-1/2 flex-col gap-4">
          <FieldGroup>
            <Label id="name">Name</Label>
            <Field id="name" name="name" component={FormikInputField} />
            <FormikErrorMessage name="name" />
          </FieldGroup>
          <FieldGroup>
            <Label>Cell</Label>
            <CopyableText text={cell}>{cell}</CopyableText>
          </FieldGroup>
          <FieldGroup>
            <Label id="domainName">Organization Domain</Label>
            <Field
              id="domainName"
              name="domainName"
              component={FormikInputField}
            />
            <FormikErrorMessage name="domainName" />
          </FieldGroup>
          <FieldGroup>
            <Label id="billingCustomerId">Ordway Customer ID</Label>
            <Field
              id="billingCustomerId"
              name="billingCustomerId"
              component={FormikInputField}
            />
            <FormikErrorMessage name="billingCustomerId" />
          </FieldGroup>
          <FieldGroup>
            <Label id="billingSubscriptionId">Ordway Subscription ID</Label>
            <Field
              id="billingSubscriptionId"
              name="billingSubscriptionId"
              component={FormikInputField}
            />
            <FormikErrorMessage name="billingSubscriptionId" />
          </FieldGroup>
          <FieldGroup>
            <Label id="mtInternalAdminTags">
              Internal Tags (comma-separated)
            </Label>
            <Field
              id="mtInternalAdminTags"
              name="mtInternalAdminTags"
              component={FormikInputField}
            />
            <FormikErrorMessage name="mtInternalAdminTags" />
          </FieldGroup>
          <FieldGroup>
            <Label id="webhookEndpointsLimit">Webhook Endpoint Limit</Label>
            <Field
              id="webhookEndpointsLimit"
              name="webhookEndpointsLimit"
              component={FormikNumberFormatField}
            />
            <FormikErrorMessage name="webhookEndpointsLimit" />
          </FieldGroup>
          <FieldGroup>
            <div className="flex flex-1 items-center gap-1">
              <div>
                <Field
                  id="webhookEndpointsThrottlingEnabled"
                  type="checkbox"
                  name="webhookEndpointsThrottlingEnabled"
                  value
                  component={FormikCheckboxField}
                />
              </div>
              <Label id="webhookEndpointsThrottlingEnabled">
                Enable Webhook Endpoints Throttling
              </Label>
              <FormikErrorMessage name="webhookEndpointsThrottlingEnabled" />
            </div>
            {isChecked(initialValues.webhookEndpointsThrottlingEnabled) && (
              <Label className="-mt-2 text-xs">
                Note: Throttling can only be disabled if all endpoints for the
                organization have no rate limit.
              </Label>
            )}
            <div className="flex flex-1 items-center gap-1">
              <div>
                <Field
                  id="sendEmailsEnabled"
                  type="checkbox"
                  name="sendEmailsEnabled"
                  value
                  component={FormikCheckboxField}
                />
              </div>
              <Label id="sendEmailsEnabled">Send Emails Enabled</Label>
              <FormikErrorMessage name="sendEmailsEnabled" />
            </div>
            <div className="flex flex-1 items-center gap-1">
              <div>
                <Field
                  id="authorizeAdminPaymentOrderApproval"
                  type="checkbox"
                  name="authorizeAdminPaymentOrderApproval"
                  value
                  component={FormikCheckboxField}
                />
              </div>
              <Label id="authorizeAdminPaymentOrderApproval">
                Enable Admin Rule Overriding
              </Label>
              <FormikErrorMessage name="authorizeAdminPaymentOrderApproval" />
            </div>
            <div className="flex flex-1 items-center gap-1">
              <div>
                <Field
                  id="adminApprovalRuleEnabled"
                  type="checkbox"
                  name="adminApprovalRuleEnabled"
                  value
                  component={FormikCheckboxField}
                />
              </div>
              <Label id="adminApprovalRuleEnabled">
                Enable Admin Approval Rule
              </Label>
              <FormikErrorMessage name="adminApprovalRuleEnabled" />
            </div>
            <div className="flex flex-1 items-center gap-1">
              <div>
                <Field
                  id="authorizePrebuiltUisWhitelabeling"
                  type="checkbox"
                  name="authorizePrebuiltUisWhitelabeling"
                  value
                  component={FormikCheckboxField}
                />
              </div>
              <Label id="authorizePrebuiltUisWhitelabeling">
                Enable removal of MT branding from Pre-built UIs
              </Label>
              <FormikErrorMessage name="authorizePrebuiltUisWhitelabeling" />
            </div>
          </FieldGroup>
          <Button
            buttonType="primary"
            onClick={() => setIsModalOpen(true)}
            disabled={isSubmitting}
            className="mt-4 w-fit"
          >
            Update
          </Button>
          <ConfirmModal
            isOpen={isModalOpen}
            setIsOpen={setIsModalOpen}
            onConfirm={handleSubmit}
            title={`Are you sure you want to update ${
              values.name ?? ""
            }âs internal settings?`}
          />
        </Form>
      )}
    </Formik>
  );
}

export default UpdateOrganizationForm;
```

---
## `UserGroupSelect.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import {
  useUserGroupSelectQuery,
  OrganizationUser,
} from "../../generated/dashboard/graphqlSchema";
import { AsyncSelectField } from "../../common/ui-components";

interface UserGroupSelectProps {
  onChange: (
    value?: OrganizationUser & { typename: "OrganizationUser" },
  ) => void;
  placeholder?: string;
  selectValue?: { value: { user: { id: string } }; label: string };
  label?: string;
  disabled?: boolean;
}

// TODO: support optional groups
function UserGroupSelect({
  onChange,
  placeholder,
  selectValue,
  label,
  disabled,
}: UserGroupSelectProps) {
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState<string | null>(null);

  const { refetch } = useUserGroupSelectQuery({
    skip: true,
  });

  const loadOptions = (newValue: string) =>
    new Promise((resolve, reject) => {
      const cleanedValue = newValue.replace(/,/g, "");
      refetch({
        first: 10,
        after: searchTerm !== cleanedValue ? null : nextCursor,
        searchTerm: cleanedValue,
      })
        .then(({ data: newData }) => {
          const newOrgUsers = newData.organizationUsers.edges.map(
            ({ node }) => node,
          );
          // Save next cursor for the following graphql query
          setNextCursor(newData.organizationUsers.pageInfo.endCursor ?? null);
          setSearchTerm(cleanedValue);

          // Return the options to react-select
          resolve({
            hasMore: newData.organizationUsers.pageInfo.hasNextPage,
            options: newOrgUsers.map((orgUser) => ({
              value: orgUser,
              label: `${orgUser.user.name ?? ""} (${orgUser.user.email})`,
            })),
          });
        })
        .catch((e) => reject(e));
    });

  return (
    <AsyncSelectField
      placeholder={placeholder || "Select User"}
      loadOptions={loadOptions}
      handleChange={(selectedOption: { value }) =>
        onChange(
          selectedOption?.value as OrganizationUser & {
            typename: "OrganizationUser";
          },
        )
      }
      cacheUniq={searchTerm}
      selectValue={selectValue}
      label={label}
      disabled={disabled}
      isClearable
      className="min-w-36"
    />
  );
}

export default UserGroupSelect;
```

---
## `UserInvitationsTableView.tsx.txt`
**Path:** `.`  
```
import React, { SyntheticEvent, useState } from "react";
import _ from "lodash";
import {
  useUserInvitationsHomeQuery,
  useDeleteUserInvitationMutation,
  useResendUserInvitationMutation,
  UserInvitation,
  UserInvitationConnection,
} from "../../generated/dashboard/graphqlSchema";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import {
  BadgeAction,
  Button,
  ButtonClickEventTypes,
  ConfirmModal,
  DateTime,
} from "../../common/ui-components";
import {
  getUserInvitationSearchComponents,
  UserInvitationQueryFilter,
} from "../../common/search_components/userInvitationSearchComponents";
import { useDispatchContext } from "../MessageProvider";
import { handleLinkClick } from "../../common/utilities/handleLinkClick";

const MAPPING = {
  email: "Email",
  createdAt: "Sent On",
  expiresAt: "Expires On",
  status: "Status",
  actions: "Actions",
};

const STYLE_MAPPING = {
  actions: "!py-1",
};

const expired = (expiresAt: string) => new Date(expiresAt) <= new Date();

function UserInvitationsTableView({
  fromUserManagement,
}: {
  fromUserManagement?: boolean;
}) {
  const { dispatchError, dispatchSuccess } = useDispatchContext();
  const [inviteToDelete, setInviteToDelete] = useState<UserInvitation | null>(
    null,
  );

  const [resendUserInvitation, { loading: resendMutationLoading }] =
    useResendUserInvitationMutation();
  const [deleteUserInvitation, { loading: deleteMutationLoading }] =
    useDeleteUserInvitationMutation({
      update(cache, { data }) {
        cache.modify({
          id: "ROOT_QUERY",
          fields: {
            userInvitations(
              userInvitationRefs: UserInvitationConnection,
              { readField },
            ) {
              return userInvitationRefs.edges.filter(
                (userInvitationRef) =>
                  data?.deleteUserInvitation?.userInvitation?.id !==
                  readField("id", userInvitationRef),
              );
            },
          },
        });
      },
    });
  const {
    loading,
    data,
    error: queryError,
    refetch,
  } = useUserInvitationsHomeQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: INITIAL_PAGINATION.perPage,
    },
  });

  const onResend = (id: string) => {
    resendUserInvitation({
      variables: { input: { id } },
    })
      .then((response) => {
        const errors = response.data?.resendUserInvitation?.errors ?? [];
        if (errors.length) {
          dispatchError(errors.toString());
        } else {
          dispatchSuccess("User Invite Resent");
        }
      })
      .catch((error: Error) => {
        dispatchError(error.message);
      });
  };

  const handleDeleteUserInvitation = () => {
    if (inviteToDelete) {
      const { id } = inviteToDelete;
      deleteUserInvitation({
        variables: { input: { id } },
      })
        .then((response) => {
          const errors = response?.data?.deleteUserInvitation?.errors ?? [];
          if (errors.length) {
            dispatchError(errors.toString());
          }
          setInviteToDelete(null);
        })
        .catch((error: Error) => {
          dispatchError(error.message);
        });
    }
  };

  const getActions = (node: UserInvitation, pending: boolean) => [
    {
      label: "Resend",
      onClick: () => onResend(node.id),
    },
    {
      label: "Edit",
      onClick: (event: ButtonClickEventTypes) => {
        handleLinkClick(
          fromUserManagement
            ? `/settings/user_management/user_invitations/${node.id}/edit`
            : `/settings/users/user_invitations/${node.id}/edit`,
          event,
        );
      },
    },
    ...(pending
      ? [
          {
            label: "Delete",
            onClick: () => setInviteToDelete(node),
            type: "danger",
          },
        ]
      : []),
  ];

  const invites =
    loading || !data || queryError
      ? []
      : data.userInvitations.edges.map(({ node }) => {
          const actions = getActions(
            node as UserInvitation,
            !expired(node.expiresAt),
          ) as BadgeAction[];
          return {
            ...node,
            createdAt: <DateTime timestamp={node.createdAt} />,
            expiresAt: <DateTime timestamp={node.expiresAt} />,
            status: expired(node.expiresAt) ? "Expired" : "Pending",
            actions: (
              <div className="flex items-center gap-1">
                {actions.map((a) => (
                  <Button
                    key={a.label}
                    disabled={resendMutationLoading || deleteMutationLoading}
                    onClick={(e: SyntheticEvent) => {
                      a.onClick();
                      e.stopPropagation();
                    }}
                  >
                    {a.label}
                  </Button>
                ))}
              </div>
            ),
          };
        });

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
    query: UserInvitationQueryFilter;
  }) => {
    const { cursorPaginationParams, query } = options;
    await refetch({
      email: query.email,
      showExpired:
        typeof query.show_expired === "string"
          ? query.show_expired === "true"
          : query.show_expired,
      ...cursorPaginationParams,
    });
  };

  const searchComponents = getUserInvitationSearchComponents();

  const overrideRowLinkClickHandler = (url: string): void => {
    const urlEnd = _.takeRight(url.split("/"), 2).join("/");
    window.location.href =
    `/settings/user_management/user_invitations/${urlEnd}`;
  };

  return (
    <>
      <ConfirmModal
        isOpen={!!inviteToDelete}
        setIsOpen={(open: boolean) => {
          if (!open) {
            setInviteToDelete(null);
          }
        }}
        title={`Are you sure you want to delete ${
          inviteToDelete?.email ?? ""
        }?`}
        onConfirm={handleDeleteUserInvitation}
        confirmType="delete"
      />
      <EntityTableView
        data={invites}
        loading={loading}
        dataMapping={MAPPING}
        styleMapping={STYLE_MAPPING}
        overrideRowLinkClickHandler={
          fromUserManagement ? overrideRowLinkClickHandler : undefined
        }
        defaultSearchComponents={searchComponents.defaultComponents}
        onQueryArgChange={handleRefetch}
        cursorPagination={data?.userInvitations?.pageInfo}
      />
    </>
  );
}

export default UserInvitationsTableView;
```

---
## `UsersTableView.tsx.txt`
**Path:** `.`  
```
import React, { useState } from "react";
import { useUsersHomeDeprecatedQuery } from
"../../generated/dashboard/graphqlSchema";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import {
  getUserSearchComponents,
  ROLES,
  UserQueryFilter,
} from "../../common/search_components/userSearchComponents";
import SourceIcon from "./SourceIcon";
import { ORGANIZATION_USER } from "../../generated/dashboard/types/resources";

function UsersTableView() {
  const [params, setParams] = useState<UserQueryFilter>({});
  const { loading, data, error, refetch } = useUsersHomeDeprecatedQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      first: INITIAL_PAGINATION.perPage,
    },
  });

  const MAPPING = {
    name: "Name",
    email: "Email",
    ...(data?.currentOrganization.scimActive
      ? { createdFromDirectory: "" }
      : {}),
  };

  const users =
    loading || !data || error
      ? []
      : data.users.edges.map(({ node }) => ({
          ...node,
          createdFromDirectory: (
            <SourceIcon
              createdFromDirectory={node.createdFromDirectory}
              entityType="user"
            />
          ),
        }));

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
    query: UserQueryFilter;
  }) => {
    const { cursorPaginationParams, query } = options;
    const newQuery = {
      name: query.name,
      id: query.id,
      email: query.email,
      showDeleted:
        typeof query.show_deleted === "string"
          ? query.show_deleted === "true"
          : query.show_deleted,
      roles: Object.keys(ROLES)
        .filter((role) => !!query[role])
        .map((role) => `${role}:${query[role] as string}`),
    };
    setParams(newQuery);
    await refetch({
      ...newQuery,
      ...cursorPaginationParams,
    });
  };

  const searchComponents = getUserSearchComponents();

  return (
    <EntityTableView
      data={users}
      loading={loading}
      dataMapping={MAPPING}
      defaultSearchComponents={searchComponents.defaultComponents}
      additionalSearchComponents={searchComponents.additionalComponents}
      onQueryArgChange={handleRefetch}
      cursorPagination={data?.users?.pageInfo}
      resource={ORGANIZATION_USER}
      enableExportData
      exportDataParams={{ params }}
    />
  );
}

export default UsersTableView;
```

---
## `VirtualAccountsTable.tsx.txt`
**Path:** `.`  
```
import React from "react";
import { omit } from "lodash";
import { getDrawerContent } from "~/common/utilities/getDrawerContent";
import CreateVirtualAccountModal from
"../containers/virtual_account_form/CreateVirtualAccountModal";
import EntityTableView from "./EntityTableView";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import { SearchComponent } from
"../../common/search_components/searchComponentsHelper";
import {
  VirtualAccountsTableFragment,
  PageInfo,
} from "../../generated/dashboard/graphqlSchema";
import { VIRTUAL_ACCOUNT } from "../../generated/dashboard/types/resources";

export const MAPPING = {
  account: "Internal Account",
  fullAccountName: "Virtual Account",
  counterparty: "Counterparty",
};

interface VirtualAccountsTableProps {
  virtualAccounts: Array<VirtualAccountsTableFragment>;
  loading: boolean;
  pagination?: PageInfo;
  handleRefetch: (options: {
    cursorPaginationParams: CursorPaginationInput;
    query: Record<string, unknown>;
  }) => Promise<void>;
  additionalSearchComponents?: Array<SearchComponent>;
  defaultSearchComponents?: Array<SearchComponent>;
  omitColumns?: Array<string>;
  isVACreationModalOpen: boolean;
  setIsVACreationModalOpen: (isVACreationModalOpen: boolean) => void;
}

function VirtualAccountsTable({
  virtualAccounts,
  loading,
  handleRefetch,
  pagination = { hasNextPage: false, hasPreviousPage: false },
  additionalSearchComponents,
  defaultSearchComponents,
  omitColumns = [],
  isVACreationModalOpen,
  setIsVACreationModalOpen,
}: VirtualAccountsTableProps) {
  return (
    <div>
      {isVACreationModalOpen && (
        <CreateVirtualAccountModal setIsOpen={setIsVACreationModalOpen} />
      )}
      <EntityTableView
        data={virtualAccounts.map((virtualAccount) => ({
          ...virtualAccount,
          account: virtualAccount.internalAccount.longName,
          counterparty: virtualAccount.counterparty?.name,
        }))}
        loading={loading}
        dataMapping={
          omitColumns.length > 0 ? omit(MAPPING, omitColumns) : MAPPING
        }
        onQueryArgChange={handleRefetch}
        cursorPagination={pagination}
        additionalSearchComponents={additionalSearchComponents}
        defaultSearchComponents={defaultSearchComponents}
        customizableColumns
        resource={VIRTUAL_ACCOUNT}
        renderDrawerContent={getDrawerContent}
      />
    </div>
  );
}

export default VirtualAccountsTable;
```

---
## `WebhookDeliveryAttemptsView.tsx.txt`
**Path:** `.`  
```
import React from "react";
import reduce from "lodash/reduce";
import ReactJson from "react-json-view";
import {
  TimeFormatEnum,
  TimeUnitEnum,
  useScheduleWebhookEventMutation,
  useWebhookDeliveryAttemptsViewQuery,
} from "../../generated/dashboard/graphqlSchema";
import { CursorPaginationInput } from "../types/CursorPaginationInput";
import EntityTableView, { INITIAL_PAGINATION } from "./EntityTableView";
import { dateSearchMapper } from "./search/DateSearch";
import { Clickable, DateTime } from "../../common/ui-components";
import { ExportDataParams } from "./ExportDataButton";
import {
  getWebhookDeliveryAttemptSearchComponents,
  WebhookDeliveryAttemptQueryFilter,
} from "../../common/search_components/webhookDeliveryAttemptSearchComponents";
import { WEBHOOK_DELIVERY_ATTEMPT } from
"../../generated/dashboard/types/resources";
import { useDispatchContext } from "../MessageProvider";
import ArchivedRecordsBanner from "./exporting/ArchivedRecordsBanner";

interface WebhookDeliveryAttemptsViewProps {
  queryArgs: {
    webhookEndpointId?: string;
    eventId?: string;
  };
}

function WebhookDeliveryAttemptsView({
  queryArgs,
}: WebhookDeliveryAttemptsViewProps) {
  const { dispatchError, dispatchSuccess } = useDispatchContext();
  const { loading, data, error, refetch } = useWebhookDeliveryAttemptsViewQuery(
    {
      notifyOnNetworkStatusChange: true,
      variables: {
        first: INITIAL_PAGINATION.perPage,
        webhookEndpointId: queryArgs.webhookEndpointId,
        eventId: queryArgs.eventId,
      },
    },
  );
  const [scheduleWebhookEvent] = useScheduleWebhookEventMutation();

  const deliveryAttempts =
    loading || !data || error
      ? []
      : data.webhookDeliveryAttempts.edges.map(({ node }) => {
          const headers = (
            <ReactJson
              src={JSON.parse(node.headers) as Record<string, unknown>}
              name={null}
              displayObjectSize={false}
              displayDataTypes={false}
            />
          );
          const body = (
            <ReactJson
              src={
                node.body
                  ? (JSON.parse(node.body) as Record<string, unknown>)
                  : {}
              }
              name={null}
              displayObjectSize={false}
              displayDataTypes={false}
            />
          );
          const resendButton = (
            <Clickable
              id="resend_button_test_id"
              onClick={() => {
                if (!node.objectId) {
                  return;
                }
                void scheduleWebhookEvent({
                  variables: {
                    input: {
                      input: {
                        eventId: node.objectId,
                        webhookId: node.webhookEndpointId,
                      },
                    },
                  },
                }).then((res) => {
                  if (
                    (res.data?.scheduleWebhookEvent?.errors?.length ?? 0) > 0
                  ) {
                    dispatchError(
                      `Error resending webhook: ${
                        res.data?.scheduleWebhookEvent?.errors?.join(", ") ?? ""
                      }`,
                    );
                  } else {
                    dispatchSuccess(
                      `Webhook sent: ${
                        res.data?.scheduleWebhookEvent?.webhookEvent
                          ?.webhookEndpointId ?? ""
                      }`,
                    );
                  }
                });
              }}
            >
              <span className="ml-2 text-green-500 hover:text-green-600">
                Resend
              </span>
            </Clickable>
          );
          const dataObj = [
            { key: "Resend", value: resendButton },
            { key: "Delivery URL", value: node.webhookUrl },
            { key: "Headers", value: headers },
            { key: "Body", value: body },
          ];

          return {
            ...node,
            data: dataObj,
            createdAt: <DateTime timestamp={node.createdAt} />,
          };
        });

  const handleRefetch = async (options: {
    cursorPaginationParams: CursorPaginationInput;
    query: WebhookDeliveryAttemptQueryFilter;
  }) => {
    const { cursorPaginationParams, query } = options;
    await refetch({
      createdAt: dateSearchMapper(query.created_at),
      ...cursorPaginationParams,
    });
  };
  const expandedData = reduce(
    deliveryAttempts,
    (acc, curr) => {
      acc[curr.id] = curr.data;
      return acc;
    },
    {},
  );

  const searchComponents = getWebhookDeliveryAttemptSearchComponents();

  const exportDataParams: ExportDataParams = {
    params: {
      webhook_endpoint_id: queryArgs.webhookEndpointId,
    },
  };

  return (
    <>
      {!loading && !!data?.relatedRecordsAreArchived && (
        <ArchivedRecordsBanner
          liveMode={!!data?.currentOrganization?.currentLiveMode}
          resourceType="WebhookDeliveryAttempt"
        />
      )}
      <EntityTableView
        data={deliveryAttempts}
        dataMapping={{
          objectId: "Object ID",
          topic: "Topic",
          eventName: "Event",
          status: "Status",
          createdAt: "Time",
        }}
        styleMapping={{
          objectId: "table-entry-wide",
        }}
        loading={loading}
        onQueryArgChange={handleRefetch}
        cursorPagination={data?.webhookDeliveryAttempts?.pageInfo}
        defaultPerPage={25}
        expandedData={expandedData}
        enableActions
        disableQueryURLParams
        additionalSearchComponents={searchComponents.additionalComponents}
        resource={WEBHOOK_DELIVERY_ATTEMPT}
        enableExportData
        exportDataParams={exportDataParams}
        initialQuery={{
          created_at: {
            inTheLast: { unit: TimeUnitEnum.Weeks, amount: "1" },
            format: TimeFormatEnum.Duration,
          },
        }}
      />
    </>
  );
}

export default WebhookDeliveryAttemptsView;
```

---
## `WebhookEndpointForm.jsx.txt`
**Path:** `.`  
```
import React from "react";
import { Field, reduxForm, formValueSelector, getFormValues } from "redux-form";
import { ClipLoader } from "react-spinners";
import { compose } from "redux";
import { connect } from "react-redux";
import { minValue, required } from "../../common/ui-components/validations";
import webhookEventTypes from "../constants/webhookEventTypes";
import ReduxCheckbox from "../../common/deprecated_redux/ReduxCheckbox";
import ReduxInputField from "../../common/deprecated_redux/ReduxInputField";
import {
  Alert,
  Label,
  SelectField,
  Button,
  Icon,
  FieldGroup,
  Stack,
} from "../../common/ui-components";
import { useActiveComplianceQuery } from
"../../generated/dashboard/graphqlSchema";

export const ALL_EVENTS_KEY = "allEvents";
export const SPECIFIC_EVENTS_KEY = "specificEvents";
const MINIMUM_RATE_LIMIT = 20; // Matches value n on backend

// Redux Form does not play nicely with webhook resources that contain dots
(e.g. expected_payment.async).
// See: https://stackoverflow.com/questions/47536618/is-there-any-way-to-have-
redux-form-ignore-dots-in-a-field-name
const reduxFormString = (entity) => entity.replace(".", "/");
export const webhookEventString = (entity, event) =>
  `${reduxFormString(entity)}-${event}`;
const validateRateLimit = (value) => minValue(MINIMUM_RATE_LIMIT)(value);

function EntityCard({
  entity,
  entityName,
  webhookEvents,
  onSelectEntity,
  selectedEntities,
  reduxChange,
}) {
  const handleCardHeaderSelect = () => {
    const newValue = !selectedEntities.includes(entity);
    onSelectEntity(newValue, entity);
    reduxChange(reduxFormString(entity), newValue);
  };

  return (
    <div className="entity-card rounded-md border border-gray-200 text-
    gray-800">
      <div
        className="border-b border-gray-100"
        onClick={handleCardHeaderSelect}
        onKeyPress={handleCardHeaderSelect}
        role="button"
        tabIndex="0"
        id={entity}
      >
        <div className="flex items-center justify-between gap-4 p-4">
          <div className="flex items-center">
            <Field
              component={ReduxCheckbox}
              name={reduxFormString(entity)}
              onClick={(e) => e.stopPropagation()}
              onChange={(e, checked) => {
                onSelectEntity(checked, entity);
              }}
            />
            <p className="pl-2 font-medium">{entityName}</p>
          </div>
          <a
            href={webhookEventTypes[entity].documentationUrl}
            target="_blank"
            rel="noopener noreferrer"
            onClick={(event) => event.stopPropagation()}
          >
            <Icon
              className="text-gray-500"
              iconName="help_outlined"
              size="s"
              color="currentColor"
            />
          </a>
        </div>
      </div>
      <Stack className="gap-2 p-4">
        {webhookEvents.map((webhookEvent) => (
          <div
            key={webhookEventString(entity, webhookEvent)}
            className="flex items-center"
          >
            <Field
              component={ReduxCheckbox}
              name={webhookEventString(entity, webhookEvent)}
            />
            <div className="pl-2 font-mono text-gray-800">
              {entity}.{webhookEvent}
            </div>
          </div>
        ))}
      </Stack>
    </div>
  );
}

function WebhookEndpointForm({
  reduxChange,
  selectedEntities,
  showWebhookEvents,
  webhookEndpointsThrottlingEnabled,
  throttlingEnabledForEndpoint,
  basicAuthEnabled,
  formValues,
  activeCompliance,
}) {
  const handleSelectEntity = (checked, entity) => {
    webhookEventTypes[entity].events.forEach((webhookEvent) =>
      reduxChange(webhookEventString(entity, webhookEvent), checked),
    );
  };
  const basicAuthSelectOptions = basicAuthEnabled
    ? ["Enabled", "Disabled", "Edit"]
    : ["Disabled", "Edit"];
  return (
    <div className="webhook-form">
      <Stack className="form-section gap-4">
        <div className="form-group webhook-url-input">
          <Field
            name="url"
            type="text"
            component={ReduxInputField}
            label="Webhook URL"
            validate={[required]}
            required
          />
        </div>
        <FieldGroup direction="left-to-right">
          <Label id="override-decision-checkbox">Basic Authentication</Label>
          <Field
            component={SelectField}
            required
            placeholder={basicAuthSelectOptions[0]}
            name="basicAuthSelection"
            options={basicAuthSelectOptions.map((o) => ({
              value: o,
              label: o,
            }))}
            selectValue={formValues.basicAuthSelection}
          />
        </FieldGroup>
        {formValues.basicAuthSelection === "Edit" && (
          <>
            <div className="form-group webhook-url-input">
              <Field
                name="username"
                type="text"
                component={ReduxInputField}
                label="Username"
              />
            </div>
            <div className="form-group webhook-url-input">
              <Field
                name="password"
                type="password"
                component={ReduxInputField}
                label="Password"
              />
            </div>
          </>
        )}
        {webhookEndpointsThrottlingEnabled && (
          <div className="flex items-center pb-2.5">
            <Field
              name="throttlingEnabled"
              type="checkbox"
              component={ReduxCheckbox}
            />
            <p className="pl-2">Enable throttling for this endpoint?</p>
          </div>
        )}
        {throttlingEnabledForEndpoint && (
          <div className="form-group webhook-url-input">
            <Field
              name="rateLimit"
              type="number"
              // Note: stops behaviour where the value changes on scroll
              onFocus={(e) =>
                e.target.addEventListener(
                  "wheel",
                  (ev) => {
                    ev.preventDefault();
                  },
                  { passive: false },
                )
              }
              validate={[validateRateLimit, required]}
              component={ReduxInputField}
              label="Webhook Notification Rate Limit (requests per second)"
            />
          </div>
        )}
        <Stack className="webhook-events-header gap-2">
          <div className="text-base font-medium">Events to send</div>
          <Stack className="webhook-event-configuration gap-1">
            <div className="radio-button flex items-center gap-2">
              <Field
                type="radio"
                name="webhookEventConfiguration"
                value={SPECIFIC_EVENTS_KEY}
                component="input"
                className="action-padding"
                id={SPECIFIC_EVENTS_KEY}
              />
              <Label id={SPECIFIC_EVENTS_KEY}>Select individual events</Label>
            </div>
            <div className="radio-button flex items-center gap-2">
              <Field
                type="radio"
                name="webhookEventConfiguration"
                value={ALL_EVENTS_KEY}
                component="input"
                className="action-padding"
                id={ALL_EVENTS_KEY}
              />
              <Label id={ALL_EVENTS_KEY}>Receive all events</Label>
            </div>
          </Stack>
        </Stack>
        {showWebhookEvents && (
          <Stack className="entity-cards gap-4">
            {Object.keys(webhookEventTypes)
              .filter(
                (webhookEntity) =>
                  activeCompliance ||
                  !["case", "decision"].includes(webhookEntity),
              )
              .map((webhookEntity) => (
                <EntityCard
                  key={webhookEntity}
                  entityName={webhookEventTypes[webhookEntity].name}
                  webhookEvents={webhookEventTypes[webhookEntity].events}
                  entity={webhookEntity}
                  reduxChange={reduxChange}
                  onSelectEntity={handleSelectEntity}
                  selectedEntities={selectedEntities}
                />
              ))}
          </Stack>
        )}
        {!showWebhookEvents && (
          <Alert alertType="warning" iconAlignment="start">
            <p className="mb-2">
              Selecting this option subscribes your Webhook Endpoint to all
              event types Modern Treasury currently supports, as well as any we
              might introduce in the future. Maintaining Endpoints reliably in
              this mode may require more effort since the introduction of new
              types of events may alter the profile of the traffic your Endpoint
              receives.
            </p>
            <p>
              {"Modern Treasury "}
              <a href="https://docs.moderntreasury.com/platform/docs/webhook-
              endpoint-best-practices">
                recommends
              </a>
              {
                " subscribing to the minimal set of events required by your use
                case."
              }
            </p>
          </Alert>
        )}
      </Stack>
    </div>
  );
}

function WebhookEndpointDetails({
  handleSubmit,
  submitting,
  errorMessage,
  change: reduxChange,
  selectedEntities,
  showWebhookEvents,
  webhookEndpointsThrottlingEnabled,
  throttlingEnabledForEndpoint,
  basicAuthEnabled,
  formValues,
}) {
  const { data: activeComplianceData } = useActiveComplianceQuery();
  const activeCompliance = activeComplianceData?.products.totalCount === 1;

  return (
    <div className="webhook-form-container">
      <form autoComplete="off" className="form-create webhook-form">
        <WebhookEndpointForm
          reduxChange={reduxChange}
          selectedEntities={selectedEntities}
          formValues={formValues}
          showWebhookEvents={showWebhookEvents}
          basicAuthEnabled={basicAuthEnabled}
          webhookEndpointsThrottlingEnabled={webhookEndpointsThrottlingEnabled}
          throttlingEnabledForEndpoint={throttlingEnabledForEndpoint}
          activeCompliance={activeCompliance}
        />

        <div className="form-group form-group-submit">
          <Button
            buttonType="primary"
            onClick={handleSubmit}
            disabled={submitting}
          >
            Save
          </Button>
          {submitting ? (
            <ClipLoader
              loaderStyle={{ verticalAlign: "middle", marginLeft: "1rem" }}
            />
          ) : undefined}
          {errorMessage && (
            <span className="error-message">{errorMessage}</span>
          )}
        </div>
      </form>
    </div>
  );
}

const selector = formValueSelector("webhookEndpoint");

const mapStateToProps = (state, ownProps) => {
  const selectedEntities = Object.keys(webhookEventTypes).reduce(
    (acc, entity) => {
      if (
        webhookEventTypes[entity].events.every(
          (event) => !!selector(state, webhookEventString(entity, event)),
        )
      ) {
        acc.push(entity);
      }
      return acc;
    },
    [],
  );
  const initialValues = Object.fromEntries(
    Object.entries(ownProps.initialValues).map(([key, value]) => [
      reduxFormString(key),
      value,
    ]),
  );
  return {
    formValues: getFormValues("webhookEndpoint")(state) || {},
    selectedEntities,
    showWebhookEvents:
      selector(state, "webhookEventConfiguration") === SPECIFIC_EVENTS_KEY,
    initialValues,
    basicAuthEnabled: initialValues.basicAuthEnabled,
    throttlingEnabledForEndpoint: selector(state, "throttlingEnabled"),
  };
};

export default compose(
  connect(mapStateToProps),
  reduxForm({ form: "webhookEndpoint" }),
)(WebhookEndpointDetails);
```

---
## `WithAsyncJob.tsx.txt`
**Path:** `.`  
```
import React, { useState, useEffect, ReactNode } from "react";
import { useJobStatusQuery } from "../../generated/dashboard/graphqlSchema";

interface WithBackgroundJobStatusProps {
  jobKey: string;
  children: (props: {
    loading: boolean;
    progress: number | undefined;
    message: string;
    onStartJob: () => void;
  }) => ReactNode;
}

const ONE_MINUTE = 60 * 1000;
const FIVE_MINUTES = 5 * 60 * 1000;

export default function WithBackgroundJobStatus({
  jobKey,
  children,
}: WithBackgroundJobStatusProps) {
  // start with a 2 second polling interval
  // Should we do an exponential backoff? Maybe after a minute?
  const startingPollInterval = 2 * 1000;
  const [pollInterval, setPollInterval] = useState(startingPollInterval);
  const [totalPollingTime, setTotalPollingTime] = useState(0); // Total time
  spent polling
  const [localLoading, setLocalLoading] = useState(false);

  const { data, loading, startPolling, stopPolling } = useJobStatusQuery({
    variables: {
      jobStatusKey: jobKey,
    },
  });

  // if job status is not present, set localloading to false
  useEffect(() => {
    if (!data?.jobStatus) {
      setLocalLoading(false);
    }
  }, [data]);

  useEffect(() => {
    // Only call startPolling on first render or when the pollInterval changes
    startPolling(pollInterval);

    const intervalId = setInterval(() => {
      setTotalPollingTime((prevTime) => prevTime + pollInterval);
      // Check if we have been polling for more than a minute
      if (
        totalPollingTime >= ONE_MINUTE &&
        pollInterval === startingPollInterval
      ) {
        stopPolling(); // Stop the old polling
        setPollInterval(10 * 1000); // Set the interval to every 10s
      }
    }, pollInterval);

    return () => {
      stopPolling(); // Stop polling when unmounting or changing the interval
      clearInterval(intervalId);
    };
  }, [
    pollInterval,
    startPolling,
    stopPolling,
    totalPollingTime,
    startingPollInterval,
  ]);

  useEffect(() => {
    if (totalPollingTime > FIVE_MINUTES) {
      stopPolling(); // Stop polling after 5 minutes
    }
  }, [totalPollingTime, stopPolling]);

  const onStartJob = () => {
    // stop the old poll and restart at the initial cadence
    stopPolling();
    setLocalLoading(true);
    setTotalPollingTime(0);
    setPollInterval(startingPollInterval);
  };

  const progress = data?.jobStatus?.progress || undefined;
  const message = data?.jobStatus?.message || "";

  return (
    <>
      {children({
        loading: localLoading || loading || Boolean(progress),
        progress,
        message,
        onStartJob,
      })}
    </>
  );
}
```

---
## `account_number/AccountDetailAccountNumber.tsx.txt`
**Path:** `account_number`  
```
import React from "react";
import { useFullAccountNumberLazyQuery } from
"../../../generated/dashboard/graphqlSchema";
import AuditableTextField from "../auditable_fields/AuditableTextField";

interface AccountNumberProps {
  accountDetailId: string;
  partialAccountNumber: string;
}

function AccountDetailAccountNumber({
  accountDetailId,
  partialAccountNumber,
}: AccountNumberProps): JSX.Element {
  const partialDisplayedAccountNumber = `â¢â¢â¢â¢ ${partialAccountNumber.slice(
    partialAccountNumber.length - 4,
    partialAccountNumber.length,
  )}`;

  return (
    <AuditableTextField
      graphqlQuery={useFullAccountNumberLazyQuery}
      queryVariables={{
        accountDetailId,
      }}
      fieldName="fullAccountNumber"
      defaultText={partialDisplayedAccountNumber}
      allowCopy
    />
  );
}

export default AccountDetailAccountNumber;
```

---
## `account_number/PaymentOrderAttemptAccountNumber.tsx.txt`
**Path:** `account_number`  
```
import React from "react";
import { useFullPaymentOrderAttemptAccountNumberLazyQuery } from
"../../../generated/dashboard/graphqlSchema";
import AuditableTextField from "../auditable_fields/AuditableTextField";

interface PaymentOrderAttemptAccountNumberProps {
  paymentOrderAttemptId: string;
  receivingEntityId: string;
  partialAccountNumber: string;
}

function PaymentOrderAttemptAccountNumber({
  paymentOrderAttemptId,
  receivingEntityId,
  partialAccountNumber,
}: PaymentOrderAttemptAccountNumberProps): JSX.Element {
  const partialDisplayedAccountNumber = `â¢â¢â¢â¢ ${partialAccountNumber.slice(
    partialAccountNumber.length - 4,
    partialAccountNumber.length,
  )}`;

  return (
    <AuditableTextField
      graphqlQuery={useFullPaymentOrderAttemptAccountNumberLazyQuery}
      queryVariables={{
        currentPaymentOrderAttemptId: paymentOrderAttemptId,
        receivingEntityId,
      }}
      fieldName="fullPaymentOrderAttemptAccountNumber"
      defaultText={partialDisplayedAccountNumber}
      allowCopy
    />
  );
}

export default PaymentOrderAttemptAccountNumber;
```

---
## `auditable_fields/AuditableJsonField.tsx.txt`
**Path:** `auditable_fields`  
```
import { LazyQueryExecFunction, OperationVariables } from "@apollo/client";
import React, { useState } from "react";
import ReactJson from "react-json-view";
import {
  ButtonClickEventTypes,
  Clickable,
} from "../../../common/ui-components";

interface AuditableJsonFieldProps {
  graphqlQuery: unknown;
  queryVariables: object;
  fieldName: string;
}

type LazyQueryFunctionType = (
  queryArgs: Record<string, unknown>,
) => [getFullField: LazyQueryExecFunction<ResponseType, OperationVariables>];

type ResponseType = { [key: string]: string };

function AuditableJsonField({
  graphqlQuery,
  queryVariables,
  fieldName,
}: AuditableJsonFieldProps) {
  const [showFullField, setShowFullField] = useState<boolean>(false);
  const [displayedFullField, setDisplayedFullField] = useState<string>("");

  const [getFullField] = (graphqlQuery as LazyQueryFunctionType)({
    variables: queryVariables,
  });

  async function handleClick(event: ButtonClickEventTypes) {
    event.stopPropagation();

    if (showFullField) {
      setDisplayedFullField("");
    } else {
      await getFullField().then((result) => {
        if (result.data === undefined) {
          setDisplayedFullField("");
        } else {
          setDisplayedFullField(result.data[fieldName]);
        }
      });
    }
    setShowFullField(!showFullField);
  }

  return showFullField && displayedFullField ? (
    <ReactJson
      src={JSON.parse(displayedFullField) as Record<string, unknown>}
      name={null}
      displayObjectSize={false}
      displayDataTypes={false}
    />
  ) : (
    <>
      <div className="mr-2">{`{ â¢â¢â¢â¢ }`}</div>
      <Clickable
        onClick={(e) => {
          handleClick(e).catch(() => {});
        }}
        id="show-pii-field-btn"
      >
        <span
          className="text-green-500 hover:text-green-600"
          data-dd-action-name="show/hide action"
        >
          {showFullField ? "Hide" : "Show"}
        </span>
      </Clickable>
    </>
  );
}

export default AuditableJsonField;
```

---
## `auditable_fields/AuditableTextField.tsx.txt`
**Path:** `auditable_fields`  
```
import { LazyQueryExecFunction, OperationVariables } from "@apollo/client";
import React from "react";
import { ShowableText } from "../../../common/ui-components";

interface AuditableTextFieldProps {
  graphqlQuery: unknown;
  queryVariables: object;
  fieldName: string;
  defaultText?: string;
  allowCopy?: boolean;
}

type LazyQueryFunctionType = (
  queryArgs: Record<string, unknown>,
) => [getFullField: LazyQueryExecFunction<ResponseType, OperationVariables>];

type ResponseType = { [key: string]: string };

function AuditableTextField({
  graphqlQuery,
  queryVariables,
  fieldName,
  defaultText,
  allowCopy,
}: AuditableTextFieldProps) {
  const [getFullField] = (graphqlQuery as LazyQueryFunctionType)({
    variables: queryVariables,
  });

  async function fetchFullField() {
    const result = await getFullField();

    if (result.data === undefined) {
      return "";
    }

    return result.data[fieldName];
  }

  return (
    <ShowableText
      defaultText={defaultText || "â¢â¢â¢â¢"}
      fullText=""
      onClick={fetchFullField}
      allowCopy={allowCopy || false}
    />
  );
}

export default AuditableTextField;
```

---
## `bulk_imports/formatValidators.ts.txt`
**Path:** `bulk_imports`  
```
import { FlatfileListener } from "@flatfile/listener";
import { FlatfileRecord, bulkRecordHook } from "@flatfile/plugin-record-hook";
import {
  numericRegex,
  decimalStringRegex,
  dateRegex,
  dateTimeRegex,
  metadataLegacyRegex,
  booleanRegex,
  numericValidatorError,
  decimalStringValidatorError,
  dateValidatorError,
  dateTimeValidatorError,
  metadataLegacyValidatorError,
  booleanValidatorError,
  RESOURCE_FLATFILE_FIELDS,
} from "./utils/flatfileUtils";

export const numericValidator = (
  listener: FlatfileListener,
  resource: string,
) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validNumber = new RegExp(numericRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.NUMERICAL[resource].forEach((amountType) => {
          const amount = record.get(amountType) as string;
          if (!!amount && !validNumber.test(amount)) {
            record.addError(amountType, numericValidatorError);
          }
        });
        return record;
      });
    }),
  );

export const decimalStringValidator = (
  listener: FlatfileListener,
  resource: string,
) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validDecimalString = new RegExp(decimalStringRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.DECIMAL_STRING[resource].forEach(
          (decimalStringType) => {
            const amount = record.get(decimalStringType) as string;
            if (!!amount && !validDecimalString.test(amount)) {
              record.addError(decimalStringType, decimalStringValidatorError);
            }
          },
        );
        return record;
      });
    }),
  );

export const dateValidator = (listener: FlatfileListener, resource: string) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validDate = new RegExp(dateRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.DATE[resource].forEach((dateType) => {
          const date = record.get(dateType) as string;
          if (!!date && !validDate.test(date)) {
            record.addError(dateType, dateValidatorError);
          }
        });
        return record;
      });
    }),
  );

export const dateTimeValidator = (
  listener: FlatfileListener,
  resource: string,
) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validDateTime = new RegExp(dateTimeRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.DATETIME[resource].forEach((dateTimeType) => {
          const date = record.get(dateTimeType) as string;
          if (!!date && !validDateTime.test(date)) {
            record.addError(dateTimeType, dateTimeValidatorError);
          }
        });
        return record;
      });
    }),
  );

export const metadataValidator = (
  listener: FlatfileListener,
  resource: string,
) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validMetadata = new RegExp(metadataLegacyRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.METADATA[resource].forEach((metadataType) => {
          const metadata = record.get(metadataType) as string;

          if (!!metadata && !validMetadata.test(metadata)) {
            record.addError(metadataType, metadataLegacyValidatorError);
          }
        });
        return record;
      });
    }),
  );

export const booleanValidator = (
  listener: FlatfileListener,
  resource: string,
) =>
  listener.use(
    bulkRecordHook(resource, (records: FlatfileRecord[]) => {
      const validBoolean = new RegExp(booleanRegex);

      records.forEach((record) => {
        RESOURCE_FLATFILE_FIELDS.BOOLEAN[resource].forEach((booleanType) => {
          const boolean = record.get(booleanType) as string;

          if (!!boolean && !validBoolean.test(boolean)) {
            record.addError(booleanType, booleanValidatorError);
          }
        });
        return record;
      });
    }),
  );
```

---
## `bulk_imports/listener.ts.txt`
**Path:** `bulk_imports`  
```
import api from "@flatfile/api";
import {
  CellValueUnion,
  RecordsWithLinks,
  RecordWithLinks,
} from "@flatfile/api/api";
import { FlatfileListener, FlatfileEvent } from "@flatfile/listener";
import {
  RecordRejections,
  SheetRejections,
} from "@flatfile/util-response-rejection";
import {
  flattenFlatfileData,
  sanitizeRecordMetadata,
} from "./utils/flatfileUtils";
import {
  numericValidator,
  decimalStringValidator,
  dateValidator,
  dateTimeValidator,
  metadataValidator,
  booleanValidator,
} from "./formatValidators";

// Highlights cells with errors by updating each record with any validation
errors
const updateSheet = async (sheet: SheetRejections): Promise<void> => {
  if (!sheet.rejectedRecords?.length) {
    return;
  }

  const rejectedRecordsIds = sheet.rejectedRecords.map((record) => record.id);
  const sheetRecords = await api.records.get(sheet.sheetId);

  const rejectedSheetRecords: RecordsWithLinks =
    sheetRecords.data.records?.filter((record: RecordWithLinks) =>
      rejectedRecordsIds.includes(record.id),
    );

  (rejectedSheetRecords || []).forEach((sheetRecord) => {
    const record = sheetRecord;
    const rejectedRecord: RecordRejections | undefined =
      sheet.rejectedRecords.find((item) => item.id === record.id) || undefined;
    if (rejectedRecord) {
      rejectedRecord.values.forEach((value) => {
        if (record.values[value.field]) {
          record.values[value.field].messages = [
            {
              type: "error",
              message: value.message,
            },
          ];
        }
      });
    }
  });
  await api.records.update(sheet.sheetId, rejectedSheetRecords);
};

const getSheetId = async (workbookId: string): Promise<string> => {
  const { data: workbookSheets } = await api.sheets.list({ workbookId });

  // only one sheet of data should be uploaded at one time
  return workbookSheets[0]?.id;
};

const getSheetRecords = async (
  workbookSheetId: string,
  jobId: string,
  resource: string,
): Promise<RecordsWithLinks> => {
  const { data: sheetRecords } = await api.records.get(workbookSheetId);

  const records = sheetRecords?.records;

  if (!records) {
    await api.jobs.fail(jobId, {
      outcome: {
        message: "Upload is empty.",
      },
    });
    return [];
  }

  if (resource !== "invoices" && records.length > 1000) {
    await api.jobs.fail(jobId, {
      outcome: {
        message: `Too many rows (max is 1000, ${records.length} submitted).`,
      },
    });
    return [];
  }
  return sheetRecords?.records;
};

const getSanitizedData = (
  jobId: string,
  resource: string,
  sheetRecords: RecordsWithLinks,
  fieldKeySet: Set<string>,
): Record<string, CellValueUnion | null>[] => {
  // turn into the shape that our validation mutation accepts
  const normalizedData = flattenFlatfileData(sheetRecords);

  // sanitize data before attempting validation
  const { sanitizedRecordData } = sanitizeRecordMetadata(
    normalizedData,
    fieldKeySet,
  );

  return sanitizedRecordData;
};

const tryValidate = async (
  sanitizedRecordData: Record<string, CellValueUnion | null>[],
  sheetRecords: RecordsWithLinks,
  jobId: string,
  sheetId: string,
  validate: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    sheetRecords: RecordsWithLinks,
  ) => Promise<RecordRejections[]>,
): Promise<boolean> => {
  try {
    const rejectedRecords = await validate(sanitizedRecordData, sheetRecords);

    if (rejectedRecords.length > 0) {
      await updateSheet({
        rejectedRecords,
        sheetId,
      });

      await api.jobs.fail(jobId, {
        outcome: {
          message: `Submission failed. Please correct all errors before
          submitting again.`,
        },
      });

      return false;
    }
    return true;
  } catch (err) {
    await api.jobs.fail(jobId, {
      outcome: {
        message: "Bulk import validation failed.",
      },
    });

    return false;
  }
};

const trySubmit = async (
  sanitizedRecordData: Record<string, CellValueUnion | null>[],
  workbookSheetId: string,
  jobId: string,
  spaceId: string,
  resource: string,
  onSubmit: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => Promise<Record<string, string | boolean>>,
): Promise<void> => {
  try {
    const response = await onSubmit(
      sanitizedRecordData,
      workbookSheetId,
      spaceId,
    );
    if (response.success) {
      let path = "";
      if (response.path) {
        path = response.path as string;
      } else if (response.bulkImportId) {
        path = `/bulk_imports/${response.bulkImportId as string}`;
      } else {
        path = `/${resource}`;
      }

      await api.jobs.complete(jobId, {
        outcome: {
          heading: "Bulk Import Submitted",
          message:
            "Thank you, we are processing your file and will send you an email
            upon completion.",
          acknowledge: true,
          next: {
            type: "url",
            url: `${window.location.origin}${path}`,
            label: "View Bulk Import",
          },
        },
      });
    }
  } catch (err) {
    await api.jobs.fail(jobId, {
      outcome: {
        message: "Bulk import creation failed.",
      },
    });
  }
};

const getFlatfileListener = (
  resource: string,
  fieldKeySet: Set<string>,
  validate: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    sheetRecords: RecordsWithLinks,
  ) => Promise<RecordRejections[]>,
  onSubmit: (
    resultsData: Array<Record<string, CellValueUnion | null>>,
    flatfileSheetId: string,
    flatfileSpaceId: string,
  ) => Promise<Record<string, string | boolean>>,
) =>
  FlatfileListener.create((listener) => {
    // Format validator listeners
    numericValidator(listener, resource);
    decimalStringValidator(listener, resource);
    dateValidator(listener, resource);
    dateTimeValidator(listener, resource);
    metadataValidator(listener, resource);
    booleanValidator(listener, resource);

    // Upload submission listener
    listener.on(
      "job:ready",
      { job: "workbook:submitActionFg" },
      async ({ context: { jobId, workbookId, spaceId } }: FlatfileEvent) => {
        const sheetId = await getSheetId(workbookId as string);
        const sheetRecords = await getSheetRecords(
          sheetId,
          jobId as string,
          resource,
        );

        if (sheetRecords.length) {
          const sanitizedRecordData = getSanitizedData(
            jobId as string,
            resource,
            sheetRecords,
            fieldKeySet,
          );

          // try validating the data
          const valid = await tryValidate(
            sanitizedRecordData,
            sheetRecords,
            jobId as string,
            sheetId,
            validate,
          );

          if (valid) {
            // submit the data to the bulk create resource mutation
            await trySubmit(
              sanitizedRecordData,
              sheetId,
              jobId as string,
              spaceId as string,
              resource,
              onSubmit,
            );
          }
        }
      },
    );
  });

export default getFlatfileListener;
```

---
## `bulk_imports/blueprints/accountACHSettingBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

export const accountACHSettingBlueprint: Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Account ACH Setting",
  labels: [],
  sheets: [
    {
      name: "Account ACH Settings",
      slug: "account_ach_settings",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Internal Account ID",
          key: "internalAccountId",
          type: "string",
        },
        {
          label: "Immediate Origin",
          key: `immediateOrigin`,
          type: "string",
        },
        {
          label: `Immediate Origin Name`,
          key: "immediateOriginName",
          type: "string",
        },
        {
          label: `Immediate Destination`,
          key: `immediateDestination`,
          type: "string",
        },
        {
          label: `Immediate Destination Name`,
          key: `immediateDestinationName`,
          type: "string",
        },
        {
          label: `Direction`,
          key: `direction`,
          type: "string",
          description: "Leave blank for both 'credit' and 'debit'",
        },
        {
          label: `Connection Endpoint Label`,
          key: `connectionEndpointLabel`,
          type: "string",
        },
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const accountACHSettingBlueprintFields =
  accountACHSettingBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/accountCapabilityBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

export const accountCapabilityBlueprint: Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Account Capabilities",
  labels: [],
  sheets: [
    {
      name: "Account Capabilities",
      slug: "account_capabilities",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Internal Account ID",
          key: "internalAccountId",
          type: "string",
        },
        {
          label: "Direction",
          key: "direction",
          type: "string",
          description: "Must be 'credit' or 'debit'.",
        },
        {
          label: "Payment Type",
          key: "paymentType",
          type: "string",
        },
        {
          label: "Identifier",
          key: "identifier",
          type: "string",
          description: "For ACH, this is the ACH Company ID.",
        },
        {
          label: "Payment Subtypes",
          key: "paymentSubtypes",
          type: "string",
          description:
            "A comma-separated list of payment subtypes to allow.  Leave blank
            for all subtypes.",
        },
        {
          label: "Any Currency",
          key: "anyCurrency",
          type: "string",
          description:
            "When 'true', allows payments of this type for any currency.",
        },
        {
          label: "Currencies",
          key: "currencies",
          type: "string",
          description:
            "A comma-separated list of currencies for which this type of payment
            can initiate.",
        },
        {
          label: "Connection ID",
          key: "connectionId",
          type: "string",
        },
        {
          label: "Party Name",
          key: "partyName",
          type: "string",
          description:
            "Overrides the legal name of the entity which owns the account when
            initiating payments.",
        },
        {
          label: "Address Line 1",
          key: "addressLine1",
          type: "string",
        },
        {
          label: "Address Line 2",
          key: "addressLine2",
          type: "string",
        },
        {
          label: "Address Locality",
          key: "addressLocality",
          type: "string",
          description:
            "The address locality. A locality is typically a city or town",
        },
        {
          label: "Address Region",
          key: "addressRegion",
          type: "string",
          description:
            "The address region. For 'US' addresses, this is the state",
        },
        {
          label: "Address Postal Code",
          key: "addressPostalCode",
          type: "string",
        },
        {
          label: "Address Country",
          key: "addressCountry",
          type: "string",
          description: "A two-digit ISO country code for the address country",
        },
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const accountCapabilityBlueprintFields =
  accountCapabilityBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/counterpartyBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { CreateWorkbookConfig } from "@flatfile/api/api";

export const counterpartyBlueprint: Pick<
  CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Counterparties",
  labels: [],
  sheets: [
    {
      name: "Counterparties",
      slug: "counterparties",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Name",
          key: "name",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "The legal name that is attached to counterparty's bank account.",
        },
        {
          label: "Email",
          key: "email",
          type: "string",
          description: "The counterparty's email address.",
        },
        {
          label: "Account Number",
          key: "accountNumber",
          type: "string",
          description:
            "The last four digits of the account number for the bank account.",
        },
        {
          label: "Account Number Type",
          key: "accountNumberType",
          type: "string",
          description:
            "One of `iban`, `clabe`, `wallet_address`, `hk_number`, `nz_number`
            or `other`. Use `other` if the bank account number is in a generic
            format. For international payments, use `iban`.",
        },
        {
          label: "Routing Number",
          key: "routingNumber",
          type: "string",
          description: "The routing number of the bank.",
        },
        {
          label: "Routing Number Type",
          key: "routingNumberType",
          type: "string",
          description:
            "Should be one of `aba`, `swift`, `ca_cpa`, `au_bsb`,
            `gb_sort_code`, `in_ifsc`.",
        },
        {
          label: "Routing Number 2",
          key: "routingNumber2",
          type: "string",
          description:
            "There are some types of international bank accounts that require
            two routing numbers: one SWIFT code and one local routing number
            (e.g. `au_bsb`, `in_ifsc`, `ca_cpa`, etc.)",
        },
        {
          label: "Routing Type 2",
          key: "routingNumberType2",
          type: "string",
          description: "The type of the second routing number.",
        },
        {
          label: "Account Type",
          key: "accountType",
          type: "string",
          description: "Can be `checking`, `savings` or other.",
        },
        {
          label: "Party Name",
          key: "partyName",
          type: "string",
        },
        {
          label: "Party Type",
          key: "partyType",
          type: "string",
          description:
            "Either `individual` or `business`.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Address Line 1",
          key: "addressLine1",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Address Line 2",
          key: "addressLine2",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Address Locality",
          key: "addressLocality",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Address Region",
          key: "addressRegion",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Address Postal Code",
          key: "addressPostalCode",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Address Country",
          key: "addressCountry",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Metadata",
          key: "metadata",
          type: "string",
          description:
            "Additional data represented as key-value pairs separated by a `|`
            (pipe character). Do not include special characters outside of `:`
            and `|`.",
        },
        {
          label: "Send Remittance Advice",
          key: "sendRemittanceAdvice",
          type: "string",
          description:
            "If `true`, Modern Treasury will send an email to the counterparty
            whenever an associated payment order is sent to the bank.",
        },
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const counterpartyBlueprintFields =
  counterpartyBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/expectedPaymentBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

export function getExpectedPaymentBlueprint(
  useLegacyMatchFilters: boolean,
): Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> {
  const commonFields = [
    {
      label: "Internal Account ID",
      key: "internalAccountId",
      type: "string",
      constraints: [
        {
          type: "required",
        },
      ],
      description: "The ID for the account you expect the funds to land in.",
    },
    {
      label: "Amount Lower Bound",
      key: "amountLowerBound",
      type: "string",
      constraints: [
        {
          type: "required",
        },
      ],
      description:
        "The lowest amount this expected payment may be equal to. The value is
        in the specified currency's smallest unit, e.g. $10 would be represented
        as 1000.",
    },
    {
      label: "Amount Upper Bound",
      key: "amountUpperBound",
      type: "string",
      constraints: [
        {
          type: "required",
        },
      ],
      description:
        "The highest amount this expected payment may be equal to. The value is
        in the specified currency's smallest unit, e.g. $10 would be represented
        as 1000.",
    },
    {
      label: "Direction",
      key: "direction",
      type: "string",
      constraints: [
        {
          type: "required",
        },
      ],
      description:
        "The direction of the expected payment.\n\nCase sensitive - either
        `credit` or `debit`.",
    },
    {
      label: "Type",
      key: "type",
      type: "string",
      description:
        "The expected payment type (eg. ACH, wire, check, etc.)\n\nCase
        sensitive - use lowercase.",
    },
    {
      label: "Currency",
      key: "currency",
      type: "string",
      description:
        "The currency that the expected payment is denominated in. Must conform
        to ISO 4217.",
    },
    {
      label: "Date Lower Bound",
      key: "dateLowerBound",
      type: "string",
      description:
        "The earliest date the payment may come in.\n\nFormat: YYYY-MM-DD",
    },
    {
      label: "Date Upper Bound",
      key: "dateUpperBound",
      type: "string",
      description:
        "The latest date the payment may come in.\n\nFormat: YYYY-MM-DD",
    },
    {
      label: "Counterparty ID",
      key: "counterpartyId",
      type: "string",
      description: "The ID of the counterparty you expect for this payment.",
    },
    {
      label: "Description",
      key: "description",
      type: "string",
      description:
        "An optional description of the expected payment for internal usage. It
        does not affect how the expected payment is matched.",
    },
    {
      label: "Metadata",
      key: "metadata",
      type: "string",
      description:
        "Additional data represented as key-value pairs separated by a `|` (pipe
        character). Do not include special characters outside of `:` and `|`.",
    },
  ];

  const legacyFields = [
    {
      label: "Statement Descriptor",
      key: "statementDescriptor",
      type: "string",
      description:
        "This should reflect the statement description you expect to see on the
        transaction.",
    },
  ];

  const nonLegacyFields = [
    {
      label: "Custom Identifiers",
      key: "customIdentifiers",
      type: "string",
      description:
        "Custom data represented as key-value pairs separated by a `|` (pipe
        character). Do not include special characters outside of `:` and `|`.",
    },
  ];

  const fields = useLegacyMatchFilters
    ? commonFields.concat(legacyFields)
    : commonFields.concat(nonLegacyFields);

  return {
    name: "Bulk Import Expected Payments",
    labels: [],
    sheets: [
      {
        name: "Expected Payments",
        slug: "expected_payments",
        readonly: false,
        allowAdditionalFields: false,
        fields: fields as Flatfile.Property[],
      },
    ],
    actions: [
      {
        operation: "submitActionFg",
        mode: "foreground",
        label: "Submit uploaded data",
        type: "string",
        description: "Submit this data to Modern Treasury",
        primary: true,
        constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
      },
    ],
  };
}

export const expectedPaymentBlueprintFields =
  getExpectedPaymentBlueprint(false).sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/internalAccountBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

const NUM_CAPABILITIES = 5;
const NUM_ACH_SETTINGS = 2;

const accountNumberFields = (): Flatfile.Property[] => [
  {
    label: "Account Number",
    key: "accountNumber1",
    type: "string",
  },
  {
    label: "Account Number Type",
    key: "accountNumber1Type",
    type: "string",
    description:
      "One of `iban`, `clabe`, `wallet_address`, `hk_number`, `nz_number` or
      `other`. Use `other` if the bank account number is in a generic format.
      For international payments, use `iban`.",
  },
  {
    label: "Account Number 2",
    key: "accountNumber2",
    type: "string",
    description: "If necessary, a additional account number.",
  },
  {
    label: "Account Number 2 Type",
    key: "accountNumber2Type",
    type: "string",
    description: "The type of the the additional account number.",
  },
];

const routingNumberFields = (): Flatfile.Property[] => [
  {
    label: "Routing Number",
    key: "routingNumber1",
    type: "string",
    description: "The routing number of the bank.",
  },
  {
    label: "Routing Number Type",
    key: "routingNumber1Type",
    type: "string",
    description:
      "The type of the routing number. One of `aba`, `swift`, `ca_cpa`,
      `au_bsb`, `gb_sort_code`, `in_ifsc`.",
  },
  {
    label: "Routing Number 2",
    key: "routingNumber2",
    type: "string",
    description:
      "There are some types of international bank accounts that require two
      routing numbers: one SWIFT code and one local routing number (e.g.
      `au_bsb`, `in_ifsc`, `ca_cpa`, etc.)",
  },
  {
    label: "Routing Number 2 Type",
    key: "routingNumber2Type",
    type: "string",
    description: "The type of the second routing number.",
  },
];

const partyAddressFields = (): Flatfile.Property[] => [
  {
    label: "Party Address Line1",
    key: "partyAddressLine1",
    type: "string",
  },
  {
    label: "Party Address Line2",
    key: "partyAddressLine2",
    type: "string",
  },
  {
    label: "Party Address Locality",
    key: "partyAddressLocality",
    type: "string",
    description:
      "The party address locality. A locality is typically a city or town",
  },
  {
    label: "Party Address Region",
    key: "partyAddressRegion",
    type: "string",
    description:
      "The party address region. For 'US' addresses, this is the state",
  },
  {
    label: "Party Address Postal Code",
    key: "partyAddressPostalCode",
    type: "string",
  },
  {
    label: "Party Address Country",
    key: "partyAddressCountry",
    type: "string",
    description: "A two-digit ISO country codes for the party address country",
  },
];

const capabilityFields = (capabilityNumber: number): Flatfile.Property[] => {
  const labelPrefix = `Account Capability ${capabilityNumber}`;
  const keyPrefix = `capability${capabilityNumber}`;

  return [
    {
      label: `${labelPrefix} Direction`,
      key: `${keyPrefix}Direction`,
      type: "string",
      description: "Must be 'credit' or 'debit'.",
    },
    {
      label: `${labelPrefix} Payment Type`,
      key: `${keyPrefix}PaymentType`,
      type: "string",
    },
    {
      label: `${labelPrefix} Identifier`,
      key: `${keyPrefix}Identifier`,
      type: "string",
      description: "For ACH, this is the ACH Company ID.",
    },
    {
      label: `${labelPrefix} Payment Subtypes`,
      key: `${keyPrefix}PaymentSubtypes`,
      type: "string",
      description:
        "A comma-separated list of payment subtypes to allow.  Leave blank for
        all subtypes.",
    },
    {
      label: `${labelPrefix} Any Currency`,
      key: `${keyPrefix}AnyCurrency`,
      type: "string",
      description:
        "When 'true', allows payments of this type for any currency.",
    },
    {
      label: `${labelPrefix} Currencies`,
      key: `${keyPrefix}Currencies`,
      type: "string",
      description:
        "A comma-separated list of currencies for which this type of payment can
        initiate.",
    },
    {
      label: `${labelPrefix} Connection ID`,
      key: `${keyPrefix}ConnectionId`,
      type: "string",
    },
    {
      label: `${labelPrefix} Party Name`,
      key: `${keyPrefix}PartyName`,
      type: "string",
      description:
        "Overrides the legal name of the entity which owns the account when
        initiating payments.",
    },
    {
      label: `${labelPrefix} Address Line 1`,
      key: `${keyPrefix}AddressLine1`,
      type: "string",
    },
    {
      label: `${labelPrefix} Address Line 2`,
      key: `${keyPrefix}AddressLine2`,
      type: "string",
    },
    {
      label: `${labelPrefix} Address Locality`,
      key: `${keyPrefix}AddressLocality`,
      type: "string",
      description:
        "The address locality. A locality is typically a city or town",
    },
    {
      label: `${labelPrefix} Address Region`,
      key: `${keyPrefix}AddressRegion`,
      type: "string",
      description: "The address region. For 'US' addresses, this is the state",
    },
    {
      label: `${labelPrefix} Address Postal Code`,
      key: `${keyPrefix}AddressPostalCode`,
      type: "string",
    },
    {
      label: `${labelPrefix} Address Country`,
      key: `${keyPrefix}AddressCountry`,
      type: "string",
      description: "A two-digit ISO country code for the address country",
    },
  ];
};

const achSettingFields = (achSettingNumber: number): Flatfile.Property[] => {
  const labelPrefix = `ACH Setting ${achSettingNumber}`;
  const keyPrefix = `achSetting${achSettingNumber}`;

  return [
    {
      label: `${labelPrefix} Immediate Origin`,
      key: `${keyPrefix}ImmediateOrigin`,
      type: "string",
    },
    {
      label: `${labelPrefix} Immediate Origin Name`,
      key: `${keyPrefix}ImmediateOriginName`,
      type: "string",
    },
    {
      label: `${labelPrefix} Immediate Destination`,
      key: `${keyPrefix}ImmediateDestination`,
      type: "string",
    },
    {
      label: `${labelPrefix} Immediate Destination Name`,
      key: `${keyPrefix}ImmediateDestinationName`,
      type: "string",
    },
    {
      label: `${labelPrefix} Direction`,
      key: `${keyPrefix}Direction`,
      type: "string",
      description: "Leave blank for both 'credit' and 'debit'",
    },
    {
      label: `${labelPrefix} Connection Endpoint Label`,
      key: `${keyPrefix}ConnectionEndpointLabel`,
      type: "string",
    },
  ];
};

export const internalAccountBlueprint: Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Internal Accounts",
  labels: [],
  sheets: [
    {
      name: "Internal Accounts",
      slug: "internal_accounts",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Name",
          key: "name",
          type: "string",
          description: "A nickname for the account.",
        },
        {
          label: "Currency",
          key: "currency",
          type: "string",
          description:
            "The currency of the account.  Must be three-letter ISO currency
            code.",
        },
        {
          label: "Party Name",
          key: "partyName",
          type: "string",
          description: "The legal name of the entity which owns the account.",
        },
        ...partyAddressFields(),
        ...accountNumberFields(),
        ...routingNumberFields(),
        ...[...Array(NUM_CAPABILITIES).keys()].flatMap((_, i) =>
          capabilityFields(i + 1),
        ),
        ...[...Array(NUM_ACH_SETTINGS).keys()].flatMap((_, i) =>
          achSettingFields(i + 1),
        ),
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const internalAccountBlueprintFields =
  internalAccountBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/invoiceBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

export const invoiceBlueprint: Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Invoices",
  labels: [],
  sheets: [
    {
      name: "Invoices",
      slug: "invoices",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Invoice Identifier",
          key: "invoiceIdentifier",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "A string identifier to indicate which invoice the line items belong
            to. Can be used to verify correct creation of the invoice.",
        },
        {
          label: "Due Date",
          key: "dueDate",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "A date in the future when the invoice is due.\n\nFormat: YYYY-MM-
            DD",
        },
        {
          label: "Originating Account ID",
          key: "originatingAccountId",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "The ID of the internal account the invoice amount should be paid
            to.",
        },
        {
          label: "Counterparty ID",
          key: "counterpartyId",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description: "The ID of the counterparty receiving the invoice.",
        },
        {
          label: "Currency",
          key: "currency",
          type: "string",
          description:
            "The currency that the invoice is denominated in. Must conform to
            ISO 4217.",
        },
        {
          label: "Description",
          key: "description",
          type: "string",
          description: "An optional free-form description of the invoice.",
        },
        {
          label: "Auto Advance",
          key: "autoAdvance",
          type: "string",
          description:
            "When true, the invoice will progress to `unpaid` automatically and
            cannot be edited after entering that state.",
        },
        {
          label: "Payment Method",
          key: "paymentMethod",
          type: "string",
          description:
            "When opening an invoice, whether to show the embedded payment UI,
            automatically create a payment, or rely on manual payment from the
            recipient.\n\nCase sensitive - one of `ui`, `automatic`, or
            `manual`.\n\nDefault: `manual`",
        },
        {
          label: "Fallback Payment Method",
          key: "fallbackPaymentMethod",
          type: "string",
          description:
            "When `payment_method` is `automatic`, the fallback `payment_method`
            to use when an automatic payment fails.\n\nCase sensitive - one of
            `ui` or `manual`.",
        },
        {
          label: "Payment Effective Date",
          key: "paymentEffectiveDate",
          type: "string",
          description:
            "When `payment_method` is` `automatic`, the date transactions are to
            be posted to the participants' account. Defaults to the current
            business day or the next business day if the current day is a bank
            holiday or weekend.",
        },
        {
          label: "Payment Type",
          key: "paymentType",
          type: "string",
          description:
            "When `payment_method` is `automatic`, the `payment_type` on the
            automatically created payment order.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Receiving Account ID",
          key: "receivingAccountId",
          type: "string",
          description:
            "When `payment_method` is `automatic`, one of the receiving
            counterparty's bank account IDs.",
        },
        {
          label: "Invoicer Email",
          key: "invoicerEmail",
          type: "string",
          description:
            "The email in the invoicer's contact details displayed at the top of
            the invoice.",
        },
        {
          label: "Invoicer Phone Number",
          key: "invoicerPhoneNumber",
          type: "string",
          description:
            "The phone number in the invoicer's contact details displayed at the
            top of the invoice.",
        },
        {
          label: "Invoicer Website",
          key: "invoicerWebsite",
          type: "string",
          description:
            "The website in the invoicer's contact details displayed at the top
            of the invoice.",
        },
        {
          label: "Notifications Enabled",
          key: "notificationsEnabled",
          type: "string",
          description:
            "If `true`, the invoice will send email notifications to the invoice
            recipients about invoice status changes.",
        },
        {
          label: "Notification Email Addresses",
          key: "notificationEmailAddresses",
          type: "string",
          description:
            "Emails (comma separated) in addition to the counterparty email to
            send invoice status notifications to. At least one email is required
            if notifications are enabled and the counterparty doesn't have an
            email.",
        },
        {
          label: "Recipient Name",
          key: "recipientName",
          type: "string",
          description:
            "The name of the recipient of the invoice. Leaving this value blank
            will fallback to using the counterparty's name.",
        },
        {
          label: "Recipient Email",
          key: "recipientEmail",
          type: "string",
          description:
            "The email of the recipient of the invoice. Leaving this value blank
            will fallback to using the counterparty's email.",
        },
        {
          label: "Metadata",
          key: "metadata",
          type: "string",
          description:
            "Additional data represented as key-value pairs separated by a `|`
            (pipe character). Do not include special characters outside of `:`
            and `|`.",
        },
        {
          label: "Invoicer Address Line 1",
          key: "invoicerAddressLine1",
          type: "string",
        },
        {
          label: "Invoicer Address Line 2",
          key: "invoicerAddressLine2",
          type: "string",
        },
        {
          label: "Invoicer Address Locality",
          key: "invoicerAddressLocality",
          type: "string",
        },
        {
          label: "Invoicer Address Region",
          key: "invoicerAddressRegion",
          type: "string",
        },
        {
          label: "Invoicer Address Postal Code",
          key: "invoicerAddressPostalCode",
          type: "string",
        },
        {
          label: "Invoicer Address Country",
          key: "invoicerAddressCountry",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Line 1",
          key: "counterpartyBillingAddressLine1",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Line 2",
          key: "counterpartyBillingAddressLine2",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Locality",
          key: "counterpartyBillingAddressLocality",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Region",
          key: "counterpartyBillingAddressRegion",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Postal Code",
          key: "counterpartyBillingAddressPostalCode",
          type: "string",
        },
        {
          label: "Counterparty Billing Address Country",
          key: "counterpartyBillingAddressCountry",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Line 1",
          key: "counterpartyShippingAddressLine1",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Line 2",
          key: "counterpartyShippingAddressLine2",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Locality",
          key: "counterpartyShippingAddressLocality",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Region",
          key: "counterpartyShippingAddressRegion",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Postal Code",
          key: "counterpartyShippingAddressPostalCode",
          type: "string",
        },
        {
          label: "Counterparty Shipping Address Country",
          key: "counterpartyShippingAddressCountry",
          type: "string",
        },
        {
          label: "Line Item Name",
          key: "lineItemName",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "Name of the line item, typically a product or SKU name.",
        },
        {
          label: "Line Item Description",
          key: "lineItemDescription",
          type: "string",
          description: "An optional free-form description of the line item.",
        },
        {
          label: "Line Item Quantity",
          key: "lineItemQuantity",
          type: "string",
          description:
            "The number of units of a product or service that this line item is
            for. Must be a whole number.\n\nDefault: 1",
        },
        {
          label: "Line Item Unit Amount",
          key: "lineItemUnitAmount",
          type: "string",
          description:
            "The cost per unit of the product or service that this line item is
            for, specified in the invoice currency's smallest unit.\n\nOnly use
            line item unit amount OR line item decimal unit amount.",
        },
        {
          label: "Line Item Decimal Unit Amount",
          key: "lineItemUnitAmountDecimal",
          type: "string",
          description:
            "The cost per unit of the product or service that this line item is
            for, specified in the invoice currency's smallest unit. Accepts
            decimal strings with up to 12 decimal places.\n\nOnly use line item
            unit amount OR line item decimal unit amount.",
        },
        {
          label: "Line Item Direction",
          key: "lineItemDirection",
          type: "string",
          description:
            "If `debit`, indicates that the counterparty owes the business money
            and increases the Invoice's `total_amount` due. If `credit`, has the
            opposite intention and effect.\n\nCase sensitive - use lowercase.",
        },
        {
          label: "Line Item Metadata",
          key: "lineItemMetadata",
          type: "string",
          description:
            "Additional data represented as key-value pairs separated by a `|`
            (pipe character). Do not include special characters outside of `:`
            and `|`.",
        },
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const invoiceBlueprintFields = invoiceBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/blueprints/paymentOrderBlueprint.ts.txt`
**Path:** `bulk_imports/blueprints`  
```
import { Flatfile } from "@flatfile/api";

export const paymentOrderBlueprint: Pick<
  Flatfile.CreateWorkbookConfig,
  "name" | "labels" | "sheets" | "actions"
> = {
  name: "Bulk Import Payment Orders",
  labels: [],
  sheets: [
    {
      name: "Payment Orders",
      slug: "payment_orders",
      readonly: false,
      allowAdditionalFields: false,
      fields: [
        {
          label: "Ultimate Originating Party Name",
          key: "ultimateOriginatingPartyName",
          type: "string",
        },
        {
          label: "Ultimate Originating Party Address Line 1",
          key: "ultimateOriginatingPartyAddressLine1",
          type: "string",
        },
        {
          label: "Ultimate Originating Party Locality",
          key: "ultimateOriginatingPartyLocality",
          type: "string",
        },
        {
          label: "Ultimate Originating Party Region",
          key: "ultimateOriginatingPartyRegion",
          type: "string",
        },
        {
          label: "Ultimate Originating Party Postal Code",
          key: "ultimateOriginatingPartyPostalCode",
          type: "string",
        },
        {
          label: "Ultimate Originating Party Country",
          key: "ultimateOriginatingPartyCountry",
          type: "string",
        },
        {
          label: "Originating Account ID",
          key: "originatingAccountId",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "The ID of your organization's internal account that will originate
            this payment order.",
        },
        {
          label: "Type",
          key: "type",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "Designates the payment type you would like to request for the
            payment orders (e.g. ACH, wire, book, etc).\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Priority",
          key: "priority",
          type: "string",
          description:
            "Either `normal` or `high`. For ACH and EFT payments, `high`
            represents a same-day ACH or EFT transfer, respectively. For check
            payments, `high` can mean an overnight check rather than standard
            mail.\n\nDefault: `normal`",
        },
        {
          label: "Process After",
          key: "processAfter",
          type: "string",
          description:
            "If present, Modern Treasury will not process the payment until
            after this time. If `process_after` is past the cutoff for
            `effective_date`, `process_after` will take precedence and
            `effective_date` will automatically update to reflect the earliest
            possible sending date after `process_after`.\n\nFormat: ISO8601
            timestamp",
        },
        {
          label: "Purpose",
          key: "purpose",
          type: "string",
          description:
            "For wires, this is usually the purpose which is transmitted via the
            `InstrForDbtrAgt` field in the ISO20022 file. For EFT, this field is
            the 3 digit CPA Code that will be attached to the payment.",
        },
        {
          label: "Amount",
          key: "amount",
          type: "string",
          description:
            "The payment order's value in specified currency's smallest unit.
            E.g. $10 USD would be represented as 1000. If you use this
            attribute, do not use the `dollar_amount` attribute.",
        },
        {
          label: "Dollar Amount",
          key: "dollarAmount",
          type: "string",
          description:
            "Alternate way to specify USD amounts only. E.g., $10 is represented
            as 10.00. If you use this attribute, do not use the `amount`
            attribute",
        },
        {
          label: "Currency",
          key: "currency",
          type: "string",
          description:
            "Must conform to ISO 4217. Defaults to the currency of the
            originating account.",
        },
        {
          label: "Direction",
          key: "direction",
          type: "string",
          constraints: [
            {
              type: "required",
            },
          ],
          description:
            "If `credit`, moves money from your account to someone else's. If
            `debit`, pulls money from someone else's account to your own. Note:
            wire and check payment types will always be `credit`.\n\nCase
            sensitive - use lowercase.",
        },
        {
          label: "Effective Date",
          key: "effectiveDate",
          type: "string",
          description:
            "The date transactions are to be posted to the counterparty's
            account. If you wish to future date a payment order, you will want
            to fill in this attribute. If this attribute is not filled, it will
            default to the next business date.\n\nFormat: YYYY-MM-DD",
        },
        {
          label: "Description",
          key: "description",
          type: "string",
          description:
            "An optional description for internal use only. This will not be
            visible to the counterparty.",
        },
        {
          label: "Statement Descriptor",
          key: "statementDescriptor",
          type: "string",
          description:
            "An optional descriptor which will appear in the receiver's
            statement. The bank statement description should be used for your
            counterparties to see more detail within their bank statement.",
        },
        {
          label: "Remittance Information",
          key: "remittanceInformation",
          type: "string",
          description:
            "Remittance information is typically another attribute that can be
            utilized to describe the money that is being sent. For ACH, this
            field will be passed through on an addenda record. For wire payments
            the field will be passed through as the `Originator to Beneficiary
            Information`. If this field is left blank then an addenda record
            will not be created.",
        },
        {
          label: "Counterparty Account ID",
          key: "counterpartyAccountId",
          type: "string",
          description:
            "The ID of an existing counterparty's account (internal or external)
            that will receive this payment order. Including this will override
            the other counterparty information you provide.",
        },
        {
          label: "Counterparty Name",
          key: "counterpartyName",
          type: "string",
        },
        {
          label: "Counterparty Routing Number",
          key: "counterpartyRoutingNumber",
          type: "string",
          description: "The routing number of the counterparty.",
        },
        {
          label: "Counterparty Routing Type",
          key: "counterpartyRoutingType",
          type: "string",
          description:
            "Either `aba`, `swift` or `ca_cpa`.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Counterparty Routing Number 2",
          key: "counterpartyRoutingNumber2",
          type: "string",
          description: "The counterparty's second routing number.",
        },
        {
          label: "Counterparty Routing Type 2",
          key: "counterpartyRoutingType2",
          type: "string",
          description:
            "Either `aba`, `swift` or `ca_cpa`.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Counterparty Account Number",
          key: "counterpartyAccountNumber",
          type: "string",
          description: "The account number of the counterparty.",
        },
        {
          label: "Counterparty Account Number Type",
          key: "counterpartyAccountNumberType",
          type: "string",
          description:
            "Supports `iban` and `clabe`. Leave blank if the bank account number
            is in a generic format.\n\nCase sensitive - use lowercase.",
        },
        {
          label: "Counterparty Account Type",
          key: "counterpartyAccountType",
          type: "string",
          description:
            "Can be `checking`, `savings`, or other.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Counterparty Party Type",
          key: "counterpartyPartyType",
          type: "string",
          description:
            "Either `individual` or `business`.\n\nCase sensitive - use
            lowercase.",
        },
        {
          label: "Counterparty Address Line 1",
          key: "counterpartyAddressLine1",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Counterparty Address Line 2",
          key: "counterpartyAddressLine2",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Counterparty Address Locality",
          key: "counterpartyAddressLocality",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Counterparty Address Region",
          key: "counterpartyAddressRegion",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Counterparty Address Postal Code",
          key: "counterpartyAddressPostalCode",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Counterparty Address Country",
          key: "counterpartyAddressCountry",
          type: "string",
          description: "Required for wire payment orders.",
        },
        {
          label: "Foreign Exchange Contract",
          key: "foreignExchangeContract",
          type: "string",
          description:
            "If present, indicates a specific foreign exchange contract number
            that has been generated by your financial institution.",
        },
        {
          label: "Foreign Exchange Indicator",
          key: "foreignExchangeIndicator",
          type: "string",
          description:
            "Indicates the type of FX transfer to initiate if the payment order
            currency matches the originating account currency. Can be either
            `variable_to_fixed`, `fixed_to_variable`, or null.\n\nCase sensitive
            - use lowercase.",
        },
        {
          label: "Charge Bearer",
          key: "chargeBearer",
          type: "string",
          description:
            "The party that will pay the fees for the payment order. Only
            applies to wire payment orders. Can be one of `SHA` (shared), `OUR`
            (sender), or `BEN` (beneficiary).\n\nCase sensitive - use
            uppercase.",
        },
        {
          label: "Subtype",
          key: "subtype",
          type: "string",
          description:
            "For ACH payment orders, the subtype represents the SEC code. We
            currently support `CCD`, `PPD`, `IAT`, `CTX`, `WEB`, `CIE`, and
            `TEL`. When Modern Treasury initiates an ACH payment on your behalf,
            the SEC Code is set automatically. When the receiving account's
            `party_type` is `individual`, the `PPD` code is used. When
            `party_type` is `business` or isn't set, `CCD` is used.\n\nCase
            sensitive - use uppercase.",
        },
        {
          label: "Metadata",
          key: "metadata",
          type: "string",
          description:
            "Additional data represented as key-value pairs separated by a `|`
            (pipe character). Do not include special characters outside of `:`
            and `|`.",
        },
        {
          label: "Accounting Class Name",
          key: "accountingClassName",
          type: "string",
          description:
            "These names can be found in the organization settings page. You
            should only use accounting class ID or accounting class name, not
            both.",
        },
        {
          label: "Accounting Account Name",
          key: "accountingAccountName",
          type: "string",
          description:
            "These names can be found in the organization settings page. You
            should only use accounting account ID or accounting account name,
            not both.",
        },
        {
          label: "Accounting Class ID",
          key: "accountingClassId",
          type: "string",
          description:
            "These IDs can be found in the organization settings page. You
            should only use accounting class ID or accounting class name, not
            both.",
        },
        {
          label: "Accounting Account ID",
          key: "accountingAccountId",
          type: "string",
          description:
            "These IDs can be found in the organization settings page. You
            should only use accounting account ID or accounting account name,
            not both.",
        },
      ],
    },
  ],
  actions: [
    {
      operation: "submitActionFg",
      mode: "foreground",
      label: "Submit uploaded data",
      type: "string",
      description: "Submit this data to Modern Treasury",
      primary: true,
      constraints: [{ type: "hasData" }, { type: "hasAllValid" }],
    },
  ],
};

export const paymentOrderBlueprintFields =
  paymentOrderBlueprint.sheets?.[0].fields || [];
```

---
## `bulk_imports/utils/flatfileUtils.ts.txt`
**Path:** `bulk_imports/utils`  
```
import { CellValueUnion, RecordsWithLinks } from "@flatfile/api/api";

type FlatfileRecord = Record<string, CellValueUnion | null>;

const metadataRegex = /^metadata\[(?<metadataKey>.+)\]$/i;

export const numericRegex = "^[0-9]+$";
export const decimalStringRegex = "^[0-9]+\\.[0-9]+$";
export const dateRegex = "^\\d{4}-[01]\\d-[0-3]\\d$";
export const dateTimeRegex =
  "^2\\d{3}-([0][1-9]|[1][0-2])-([0][1-9]|[1-2]\\d|[3][01])T([01]\\d|[2][0-
  3]):[0-5]\\d:[0-5]\\d(\\.\\d+)?(([+-]([01]\\d|[2][0-3]):[0-5]\\d)|Z)?$";
export const metadataLegacyRegex = "^([\\w ]+:[\\w\\- ]+\\|?)*$";
export const booleanRegex = "^\\s*(true|false|TRUE|FALSE)\\s*$";

// Maps resource columns to data format validators (resources have different
columns to validate)
export const RESOURCE_FLATFILE_FIELDS: Record<
  string,
  Record<string, string[]>
> = {
  NUMERICAL: {
    payment_orders: ["amount"],
    expected_payments: ["amountLowerBound", "amountUpperBound"],
    counterparties: [],
    invoices: ["lineItemUnitAmount", "lineItemQuantity"],
  },
  DECIMAL_STRING: {
    payment_orders: [],
    expected_payments: [],
    counterparties: [],
    invoices: ["lineItemUnitAmountDecimal"],
  },
  DATE: {
    payment_orders: ["effectiveDate"],
    expected_payments: ["dateLowerBound", "dateUpperBound"],
    counterparties: [],
    invoices: ["dueDate", "paymentEffectiveDate"],
  },
  DATETIME: {
    payment_orders: ["processAfter"],
    expected_payments: [],
    counterparties: [],
    invoices: [],
  },
  METADATA: {
    payment_orders: ["metadata"],
    expected_payments: ["metadata", "customIdentifiers"],
    counterparties: ["metadata"],
    invoices: ["metadata", "lineItemMetadata"],
  },
  BOOLEAN: {
    payment_orders: [],
    expected_payments: [],
    counterparties: ["sendRemittanceAdvice"],
    invoices: ["autoAdvance", "notificationsEnabled"],
  },
};

// Basic validation needed for GraphQL types.
export const numericValidatorError = "Must be only numerical values";
export const decimalStringValidatorError =
  "Must be only numerical decimal values";
export const dateValidatorError = "Must be in ISO 8601, YYYY-MM-DD format";
export const dateTimeValidatorError =
  "Must be in ISO 8601, YYYY-MM-DDThh:mm:ssTZD format";
export const metadataLegacyValidatorError = "Must be in k1:v1|k2:v2 format";
export const booleanValidatorError = "Must be true or false";

/** Flattens the record values into one simple object */
export const flattenFlatfileData = (records: RecordsWithLinks) => {
  const normalizedList: Array<FlatfileRecord> = [];
  if (records.length) {
    for (let i = 0; i < records.length; i += 1) {
      const record = records[i];
      const data = record.values;
      const normalized: FlatfileRecord = {};
      Object.keys(data).forEach((key) => {
        normalized[key] = data[key].value || null;
      });
      normalizedList.push(normalized);
    }
  }

  return normalizedList;
};

/**
 * We allow custom fields from the user to support metadata[key] inputs.
 * Because any field can be inputed, we should restrict it to only
 * the fields we have defined and the custom metadata fields,
 * returning helpful errors if the custom columns are malformed.
 *
 */
export const sanitizeRecordMetadata = (
  recordData: FlatfileRecord[],
  expectedFields: Set<string>,
): {
  sanitizedRecordData: Array<Record<string, CellValueUnion | null>>;
  errors?: Array<string>;
} => {
  const errors: Array<string> = [];
  const sanitizedRecordData = recordData.map((record) => {
    const sanitizedRecord: FlatfileRecord = {};
    const recordKeys = Object.keys(record);
    const specifiedKeySet = new Set(recordKeys);

    recordKeys.forEach((key: string) => {
      if (
        key === "metadata" ||
        key === "lineItemMetadata" ||
        key === "customIdentifiers"
      ) {
        const unparsedMetadata = record[key] as string;
        if (!unparsedMetadata) {
          sanitizedRecord[key] = null;
        } else {
          // Parse k1:v1|k2:v2 into json object
          const metadataObj = unparsedMetadata
            .split("|")
            .reduce((acc, keyValue) => {
              const keyValuePair = keyValue.split(":");
              return {
                ...acc,
                [keyValuePair[0]?.trim()]: keyValuePair[1]?.trim(),
              };
            }, {});
          sanitizedRecord[key] = JSON.stringify(metadataObj);
        }
      } else if (key === "$custom") {
        const metadataObj = Object.keys(record[key] || {}).reduce(
          (acc, customKey) => {
            const m = metadataRegex.exec(customKey);
            // If the custom key matches the metadata regex and there is a value
            for that metadata key, parse it.
            if (m?.groups?.metadataKey && record[key]?.[customKey]) {
              // Cannot have both custom and legacy metadata formats.
              if (specifiedKeySet.has("metadata")) {
                errors.push(
                  "Cannot use both legacy metadata field and custom
                  metadata[key] fields",
                );
              }
              return {
                ...acc,
                [m.groups.metadataKey]: record[key]?.[customKey] as string,
              };
            }

            // If the custom key does not match the metadata regex, record error
            to show.
            if (!m?.groups?.metadataKey) {
              errors.push(
                `Custom field ${customKey} is not in format: metadata[key]`,
              );
            }
            return acc;
          },
          {},
        );
        sanitizedRecord.metadata = JSON.stringify(metadataObj);
      } else if (expectedFields.has(key)) {
        sanitizedRecord[key] = record[key] === "" ? null : record[key];
      }
    });
    return sanitizedRecord;
  });

  return { sanitizedRecordData, errors: Array.from(new Set(errors)) };
};
```

---
## `compliance/BusinessRegistration.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import { Verification } from "../../../generated/dashboard/graphqlSchema";
import RiskLevelIndicator from "./RiskLevelIndicator";
import {
  IndexTable,
  KeyValueTableSkeletonLoader,
  OverflowTip,
} from "../../../common/ui-components";

const BUSINESS_REGISTRATION_DATA_MAPPING = {
  state: "State",
  businessName: "Business Name",
  addresses: "Address",
  type: "Type",
  registrationDate: "Registration Date",
  status: "Status",
};

interface VerificationResult {
  other: OtherVerificationResult;
}

type RiskLevel = "low" | "high";

interface Risk {
  level: RiskLevel;
  reason: string;
}

interface OtherVerificationResult {
  registrations: {
    state: string;
    name: string;
    addresses: string[];
    entityType: string;
    registrationDate: string;
    risks: Risk[];
  }[];
}

interface BusinessRegistrationProps {
  verification: Verification | null;
}

function BusinessRegistration({ verification }: BusinessRegistrationProps) {
  if (!verification || !verification.result) {
    return <KeyValueTableSkeletonLoader />;
  }

  const verificationResult = JSON.parse(
    verification.result,
  ) as VerificationResult;
  const businessRegistrations = verificationResult?.other?.registrations || [];

  const businessRegistrationsData = businessRegistrations.map(
    (businessRegistration) => {
      const risk =
        businessRegistration.risks.length > 0
          ? businessRegistration.risks[0]
          : null;
      const status = risk?.reason || "Unknown";
      const statusRiskLevel = risk?.level || "N/A";

      const statusComponent = (
        <RiskLevelIndicator
          formatterOrText={status}
          riskLevel={statusRiskLevel}
        />
      );

      const addresses = businessRegistration.addresses.map((address) => (
        <OverflowTip message={address} className="truncate">
          {address}
        </OverflowTip>
      ));

      return {
        state: businessRegistration.state,
        businessName: businessRegistration.name,
        type: businessRegistration.entityType,
        registrationDate: businessRegistration.registrationDate,
        status: statusComponent,
        addresses,
      };
    },
  );

  return (
    <IndexTable
      data={businessRegistrationsData}
      dataMapping={BUSINESS_REGISTRATION_DATA_MAPPING}
      styleMapping={{ addresses: "table-entry-wide" }}
    />
  );
}

export default BusinessRegistration;
```

---
## `compliance/ComplianceEntityDetails.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import {
  Clickable,
  Drawer,
  Icon,
  IndexTable,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
  OverflowTip,
} from "../../../common/ui-components";
import IdentityDetailsView from "./IdentityDetailsView";
import PaymentOrderView from
"../../containers/payment_order_details/PaymentOrderView";
import IncomingPaymentDetailsView from
"../../containers/IncomingPaymentDetailsView";
import {
  Decision,
  Verification,
  VerificationProviderEnum,
  Verification__TypeEnum,
} from "../../../generated/dashboard/graphqlSchema";
import RiskLevelIndicator, { RiskLevel } from "./RiskLevelIndicator";
import { DECISIONS_SCORES } from "../../constants";

const PAYMENT_ORDER_DETAILS_DATA_MAPPING = {
  id: "Payment Order ID",
};

const INCOMING_PAYMENT_DETAIL_DATA_MAPPING = {
  id: "Incoming Payment Detail ID",
};

const COUNTERPARTY_DETAILS_DATA_MAPPING = {
  id: "Counterparty ID",
  userOnboarding: "User Onboarding ID",
};

const WEBSITE_DATA_MAPPING = {
  website: "Website",
  status: "Status",
  domainRegistrar: "Domain Registrar",
  createdAt: "Created At",
  registeredAt: "Registered At",
};

interface ComplianceEntityDetailsProps {
  decision: Decision;
  showUserOnboardingOnly?: boolean;
}

interface MiddeskVerificationResult {
  other: OtherVerificationResult;
}

interface SardineVerificationResult {
  overall: {
    overallRisk: {
      value: RiskLevel;
    };
  };
}

interface Risk {
  level: RiskLevel;
  reason: string;
}

interface OtherVerificationResult {
  website: {
    url: string;
    status: string;
    domainRegistrar: string;
    createdAt: string;
    registeredAt: string;
    risks: Risk[];
  };
  names: { name: string; sources: string[]; risks: Risk[] }[];
  tin: {
    tin: string;
    risks: Risk[];
  };
  addresses: {
    fullAddress: string;
    sources: string[];
    risks: Risk[];
  }[];
  formation: {
    formationDate: string;
    formationState: string;
    entityType: string;
  };
  phoneNumbers: {
    phoneNumbers: string[];
    risks: Risk[];
  };
}

function getVerification(
  verifications: Decision["verifications"],
  provider: VerificationProviderEnum,
) {
  return (
    verifications.find((verification) => verification.provider === provider) ||
    null
  );
}

function renderRiskLevel(risks: Risk[], addLeftRight?: boolean) {
  if (!risks || risks.length === 0) {
    return null;
  }

  const riskRows = risks.map((risk) => (
    <div className={`${addLeftRight ? " mr-6" : ""}`}>
      <RiskLevelIndicator
        riskLevel={risk.level}
        formatterOrText={risk.reason}
      />
    </div>
  ));

  return <div className="my-auto">{riskRows}</div>;
}

function parseOtherVerificationResults(
  decision: Decision,
): OtherVerificationResult | null {
  const middeskVerification =
    decision.verifications.find(
      (verification) =>
        verification.provider === VerificationProviderEnum.Middesk,
    ) || null;

  const middeskVerificationResult = middeskVerification?.result
    ? (JSON.parse(middeskVerification.result) as MiddeskVerificationResult)
    : null;
  return middeskVerificationResult?.other || null;
}

function parseAddresses(
  otherVerificationResult: OtherVerificationResult | null,
) {
  if (!otherVerificationResult || !otherVerificationResult.addresses) {
    return null;
  }

  const { addresses } = otherVerificationResult;

  return addresses.reduce(
    (addressesRows, address, index) => {
      const risks = address.risks || [];

      addressesRows.push({
        id: `address-${index}`,
        address: (
          <>
            <OverflowTip message={address.fullAddress} className="truncate">
              {address.fullAddress}
            </OverflowTip>

            {address.sources?.length > 0 && (
              <div className="flex">
                <div className="mr-2">Sources:</div>
                <div>{address.sources.join(", ").replace("_", " ")}</div>
              </div>
            )}
          </>
        ),
        risks: <div>{renderRiskLevel(risks, true)}</div>,
      });

      return addressesRows;
    },
    [] as { id: string; address: JSX.Element; risks: JSX.Element }[],
  );
}

function parseWebPresence(
  otherVerificationResult: OtherVerificationResult | null,
) {
  if (!otherVerificationResult || !otherVerificationResult.website) {
    return null;
  }

  const { website } = otherVerificationResult;
  const { risks } = website;

  return {
    website: (
      <div className="my-auto flex bg-white">
        {website.url}
        <Clickable
          onClick={() => {
            window.open(website.url, "_blank")?.focus();
          }}
        >
          <span className="ml-2">
            <Icon
              iconName="external_link"
              color="currentColor"
              className="text-gray-600"
              size="s"
            />
          </span>
        </Clickable>
      </div>
    ),
    status: (
      <div className="my-auto flex bg-white">{renderRiskLevel(risks)}</div>
    ),
    domainRegistrar: website.domainRegistrar || "N/A",
    createdAt: website.createdAt || "N/A",
    registeredAt: website.registeredAt || "N/A",
  };
}

function getBankAccountRisks(sardineVerification: Verification | null) {
  if (!sardineVerification) {
    return null;
  }

  const sardineVerificationResult = JSON.parse(
    sardineVerification.result,
  ) as SardineVerificationResult;

  const kybBankVerification =
    sardineVerification.verificationType === Verification__TypeEnum.BankAccount;

  if (!kybBankVerification) {
    return null;
  }

  const bankRiskLevel = sardineVerificationResult.overall.overallRisk.value;
  const bankRiskReason = DECISIONS_SCORES[bankRiskLevel];

  return [
    {
      level: bankRiskLevel,
      reason: `${bankRiskReason} Risk`,
    },
  ];
}

function addressesComponent(
  otherVerificationResult: OtherVerificationResult | null,
) {
  const addresses = parseAddresses(otherVerificationResult);

  if (!addresses) {
    return null;
  }

  return (
    <div>
      <IndexTable
        data={addresses}
        styleMapping={{
          address: "table-entry-wide",
          risks: "table-entry-wide",
        }}
        dataMapping={{
          address: "Address",
          risks: "Risks",
        }}
        renderHeader={false}
      />
    </div>
  );
}

function webPresenceComponent(
  otherVerificationResult: OtherVerificationResult | null,
) {
  const website = parseWebPresence(otherVerificationResult);

  if (!website) {
    return null;
  }

  return (
    <div id="web-presence-table">
      <IndexTable data={[website]} dataMapping={WEBSITE_DATA_MAPPING} />
    </div>
  );
}

function ComplianceEntityDetails({
  decision,
  showUserOnboardingOnly,
}: ComplianceEntityDetailsProps) {
  if (!decision) {
    return null;
  }

  const { decisionable } = decision;

  const verifications = decision.verifications || [];

  switch (decisionable?.__typename) {
    case "UserOnboarding": {
      const userOnboarding = decisionable;
      const userOnboardingId = userOnboarding?.id;

      if (showUserOnboardingOnly) {
        return (
          <IdentityDetailsView
            loading={!userOnboarding}
            userOnboarding={userOnboarding}
            showUserOnboardingOnly
          />
        );
      }

      const sardineVerification = getVerification(
        verifications,
        VerificationProviderEnum.Sardine,
      );

      const bankAccountRisks = getBankAccountRisks(sardineVerification);
      const otherVerificationResult = parseOtherVerificationResults(decision);
      const addressesTable = addressesComponent(otherVerificationResult);
      const webPresenceTable = webPresenceComponent(otherVerificationResult);

      const kybDetails = {
        names: otherVerificationResult?.names,
        formation: otherVerificationResult?.formation,
        addresses: otherVerificationResult?.addresses,
        tin: otherVerificationResult?.tin,
        phoneNumbers: otherVerificationResult?.phoneNumbers,
        bankAccountRisks: bankAccountRisks || undefined,
      };

      return (
        <>
          <IdentityDetailsView
            loading={!userOnboardingId}
            userOnboarding={userOnboarding}
            kybDetails={kybDetails}
          />
          {addressesTable && (
            <>
              <div className="font-app mb-8 mt-14 w-full text-base font-medium">
                Address
              </div>
              {addressesTable}
            </>
          )}
          {webPresenceTable && (
            <>
              <div className="font-app mb-8 mt-14 w-full text-base font-medium">
                Web Presence
              </div>
              {webPresenceTable}
            </>
          )}
        </>
      );
    }

    case "PaymentOrder": {
      const paymentOrder = decisionable;
      const paymentOrderPath = paymentOrder?.path;
      const paymentOrderId = paymentOrder?.id;

      const trigger = (
        <div className="cursor-pointer text-blue-500 hover:text-blue-600">
          {paymentOrderId}
        </div>
      );

      return (
        <>
          {!paymentOrderId && (
            <KeyValueTableSkeletonLoader
              dataMapping={PAYMENT_ORDER_DETAILS_DATA_MAPPING}
            />
          )}
          {paymentOrderId && (
            <KeyValueTable
              data={{
                id: paymentOrderPath ? (
                  <Drawer trigger={trigger} path={paymentOrderPath}>
                    <PaymentOrderView
                      match={{
                        params: {
                          payment_order_id: paymentOrderId,
                        },
                      }}
                    />
                  </Drawer>
                ) : null,
              }}
              dataMapping={PAYMENT_ORDER_DETAILS_DATA_MAPPING}
            />
          )}
        </>
      );
    }

    case "IncomingPaymentDetail": {
      const incomingPaymentDetail = decisionable;
      const incomingPaymentDetailPath = incomingPaymentDetail?.path;
      const incomingPaymentDetailId = incomingPaymentDetail?.id;

      const trigger = (
        <div className="cursor-pointer text-blue-500 hover:text-blue-600">
          {incomingPaymentDetailId}
        </div>
      );

      return (
        <>
          {!incomingPaymentDetailId && (
            <KeyValueTableSkeletonLoader
              dataMapping={INCOMING_PAYMENT_DETAIL_DATA_MAPPING}
            />
          )}
          {incomingPaymentDetailId && (
            <KeyValueTable
              data={{
                id: incomingPaymentDetailPath ? (
                  <Drawer trigger={trigger} path={incomingPaymentDetailPath}>
                    <IncomingPaymentDetailsView
                      match={{
                        params: {
                          incoming_payment_detail_id: incomingPaymentDetailId,
                        },
                      }}
                    />
                  </Drawer>
                ) : null,
              }}
              dataMapping={INCOMING_PAYMENT_DETAIL_DATA_MAPPING}
            />
          )}
        </>
      );
    }

    case "Counterparty": {
      const {
        path: counterpartyPath,
        id: counterpartyId,
        userOnboarding,
      } = decisionable;

      const userOnboardingPath = userOnboarding?.decision?.path;
      const userOnboardingId = userOnboarding?.id;

      return (
        <>
          {!counterpartyId && (
            <KeyValueTableSkeletonLoader
              dataMapping={COUNTERPARTY_DETAILS_DATA_MAPPING}
            />
          )}
          {counterpartyId && (
            <KeyValueTable
              data={{
                id: counterpartyPath ? (
                  <a href={counterpartyPath}>{counterpartyId}</a>
                ) : null,
                userOnboarding: userOnboardingPath ? (
                  <a href={userOnboardingPath}>{userOnboardingId}</a>
                ) : null,
              }}
              dataMapping={COUNTERPARTY_DETAILS_DATA_MAPPING}
            />
          )}
        </>
      );
    }

    default:
      return null;
  }
}

export default ComplianceEntityDetails;
```

---
## `compliance/ComplianceStatusBadge.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import { Badge, BadgeType } from "../../../common/ui-components";
import { Decision__StatusEnum } from
"../../../generated/dashboard/graphqlSchema";
import { PRETTY_DECISION_STATUSES } from "../../constants";

interface ComplianceStatusBadgeProps {
  status?: Decision__StatusEnum;
}

function ComplianceStatusBadge({ status }: ComplianceStatusBadgeProps) {
  let badgeType;
  switch (status) {
    case Decision__StatusEnum.Approved:
      badgeType = BadgeType.Success;
      break;
    case Decision__StatusEnum.NeedsApproval:
      badgeType = BadgeType.Cool;
      break;
    case Decision__StatusEnum.Denied:
      badgeType = BadgeType.Critical;
      break;
    case Decision__StatusEnum.Cancelled:
      badgeType = BadgeType.Warning;
      break;
    case Decision__StatusEnum.Completed:
      badgeType = BadgeType.Cool;
      break;
    default:
      badgeType = BadgeType.Default;
      break;
  }

  return (
    <Badge
      text={(status && PRETTY_DECISION_STATUSES[status]) || "N/A"}
      type={badgeType as BadgeType}
      keepCaseFormat
      className="w-fit"
    />
  );
}

export default ComplianceStatusBadge;
```

---
## `compliance/DeprecatedRiskProfileView.tsx.txt`
**Path:** `compliance`  
```
import React, { useEffect, useState } from "react";
import { isEmpty, startCase, merge } from "lodash";
import {
  ExpandableCard,
  Drawer,
  IndexTable,
  IndexTableSkeletonLoader,
  OverflowTip,
} from "../../../common/ui-components";
import RiskIndicator from "./RiskLevelIndicator";
import {
  Decision,
  DecisionableTypeEnum,
  Flow__PartyTypeEnum,
  UserOnboarding,
  Verification__TypeEnum,
  VendorCheckEnum,
} from "../../../generated/dashboard/graphqlSchema";
import SardineRuleView from "./SardineRuleView";

const RISK_PROFILE_MAPPING = {
  category: "Category",
  riskLevel: "Risk Level",
  reason: "Reason",
};

const KYB_IDENTITY_CHECKS = {
  overallRisk: "Overall",
  watchlist: "Watchlist",
  addressVerification: "Address Verification",
  phone: "Phone",
  name: "Name",
  addressDeliverability: "Address Deliverability",
  addressPropertyType: "Address Property Type",
  sosMatch: "SOS Match",
  sosActive: "SOS Active",
  sosDomestic: "SOS Domestic",
  tin: "TIN",
  industry: "Industry",
  websiteStatus: "Website Status",
  websiteVerification: "Website Verification",
  bankruptcies: "Bankruptcies",
  beneficialOwners: "Beneficial Owners",
};

const KYC_EMAIL = {
  emailLevel: "Email",
  emailDomainLevel: "Email Domain",
};

const KYC_PHONE = {
  phoneLevel: "Phone",
};

const KYC_TAX_ID_VERIFICATION = {
  taxIdLevel: "Tax ID",
};

const KYC_SANCTIONS = {
  sanctionLevel: "Sanction",
};

const KYC_POLITICALLY_EXPOSED_PERSON = {
  pepLevel: "Politically Exposed Person",
};

const KYC_ADVERSE_MEDIA = {
  adverseMediaLevel: "Adverse Media",
};

const KYC_DEVICE_AND_BEHAVIOR = {
  OSAnomaly: "OS Anomaly",
  RemoteSoftwareLevel: "Remote Software",
  behaviorBiometricLevel: "Behavior Biometric",
  Proxy: "Proxy",
  VPN: "VPN",
};

const KYC_BANK_RISK_CHECK = {
  bankLevel: "Bank",
  nsfLevel: "Non-Sufficient Funds",
  amlLevel: "Anti-Money Laundering",
  riskLevel: "Transaction Risk",
};

export const VENDOR_CHECKS_DATA_MAPPING = {
  [VendorCheckEnum.KybIdentity]: KYB_IDENTITY_CHECKS,
  [VendorCheckEnum.Email]: KYC_EMAIL,
  [VendorCheckEnum.Phone]: KYC_PHONE,
  [VendorCheckEnum.TaxIdVerification]: KYC_TAX_ID_VERIFICATION,
  [VendorCheckEnum.Sanction]: KYC_SANCTIONS,
  [VendorCheckEnum.PoliticallyExposedPerson]: KYC_POLITICALLY_EXPOSED_PERSON,
  [VendorCheckEnum.AdverseMedia]: KYC_ADVERSE_MEDIA,
  [VendorCheckEnum.DeviceAndBehavior]: KYC_DEVICE_AND_BEHAVIOR,
  [VendorCheckEnum.BankRisk]: KYC_BANK_RISK_CHECK,
};

interface Signal {
  key?: string;
  value: string;
  rawValue: string;
  reasonCodes: [string];
}

interface OtherVerificationResult {
  website: {
    url: string;
    status: string;
    domainRegistrar: string;
    createdAt: string;
    registeredAt: string;
    risks: Risk[];
  };
  names: { name: string; sources: string[]; risks: Risk[] }[];
  tin: {
    tin: string;
    risks: Risk[];
  };
  addresses: {
    fullAddress: string;
    sources: string[];
    risks: Risk[];
  }[];
  formation: {
    formationDate: string;
    formationState: string;
    entityType: string;
  };
  phoneNumbers: {
    phoneNumbers: string[];
    risks: Risk[];
  };
}

interface ParsedSignal {
  other: OtherVerificationResult;
  overall: { overallRisk: Signal[] };
  signals: Signal[];
}

type RiskProfile = {
  category: string;
  riskLevel: React.ReactElement | string;
  reason: React.ReactElement[] | string;
};

interface Risk {
  overallProfile: RiskProfile;
  profiles: RiskProfile[];
}

interface RiskProfileTabProps {
  loading: boolean;
  data: Decision;
  expandable?: boolean;
  hideTitle?: boolean;
}

interface AdditionalSignals {
  [key: string]: Signal;
}

const RISK_LEVELS = ["low", "medium", "high", "very_high", "unknown"];

function formatReasonCodes(reasonCodes: string[]): JSX.Element[] {
  return reasonCodes.map((reasonCode: string) => {
    const ruleHasDescription = reasonCode.indexOf(":") !== -1;
    const [ruleName, ruleDescription] = reasonCode.split(":");
    const ruleId = ruleName.substring(5, ruleName.length);

    return (
      <div className="mt-1 h-fit w-full" key={reasonCode}>
        <OverflowTip message={reasonCode} className="truncate">
          {!ruleHasDescription ? (
            reasonCode
          ) : (
            <>
              <Drawer
                trigger={
                  <span className="cursor-pointer underline">{ruleName}</span>
                }
              >
                <SardineRuleView ruleId={ruleId} />
              </Drawer>
              {`: ${ruleDescription || "No description provided"}`}
            </>
          )}
        </OverflowTip>
      </div>
    );
  });
}

function formatSignals(
  signalsString: string | undefined,
  key: string,
  provider: string,
  additionalSignals?: AdditionalSignals, // Adds additional signal to list
  vendorChecks?: VendorCheckEnum[],
): RiskProfile[] {
  let riskProfile: RiskProfile[] = [];
  const parsedSignals: ParsedSignal = JSON.parse(
    signalsString || "{}",
  ) as ParsedSignal;
  const isMiddesk = provider === "middesk";

  const riskProfileDataMapping = {
    // overallRisk is used for Rule #'s
    overallRisk: "Overall",
  };

  vendorChecks?.forEach((checks) => {
    merge(riskProfileDataMapping, VENDOR_CHECKS_DATA_MAPPING[checks]);
  });

  // Adds additional signals to the list of checks
  if (additionalSignals) {
    Object.keys(additionalSignals).forEach((k) => {
      parsedSignals.signals[k] = additionalSignals[k];
    });
  }

  if (key in parsedSignals) {
    riskProfile = Object.entries(parsedSignals[key] as Signal[]).map(
      ([categoryName, categoryValue]) => {
        const { value, reasonCodes, rawValue } = categoryValue;
        const category =
          categoryName in riskProfileDataMapping
            ? (riskProfileDataMapping[categoryName] as string)
            : "-";

        const riskLevelRawValue = isMiddesk ? rawValue : undefined;
        const riskLevel = RISK_LEVELS.includes(value) ? (
          <RiskIndicator
            riskLevel={value || ""}
            formatterOrText={riskLevelRawValue}
          />
        ) : (
          "-"
        );

        let reason: string | JSX.Element[] = "-";
        if (reasonCodes && reasonCodes.length > 0) {
          // middesk only has one reason code in plain text with no need to
          format
          reason = isMiddesk ? reasonCodes[0] : formatReasonCodes(reasonCodes);
        }
        return { category, riskLevel, reason };
      },
    );
  }

  return riskProfile.filter(
    (riskSignal) =>
      riskSignal?.riskLevel !== "-" && riskSignal?.category !== "-",
  );
}

function DeprecatedRiskProfileView({
  loading,
  data,
  expandable = false,
  hideTitle = false,
}: RiskProfileTabProps) {
  const [risks, setRisks] = useState<Risk>();
  let signals = "";
  let provider = "";

  // default case is for checks with only 1 verification
  // add proper handling when specific check has more than 1 verification
  switch (data?.decisionableType) {
    case DecisionableTypeEnum.UserOnboarding:
      if (
        (data?.decisionable as UserOnboarding)?.partyType ===
        Flow__PartyTypeEnum.Business
      ) {
        const comprehensiveKybVerification = data.verifications.find(
          ({ verificationType }) =>
            verificationType === Verification__TypeEnum.ComprehensiveKyb,
        );

        if (!comprehensiveKybVerification) {
          signals = data?.verifications[0]?.result;
          provider = data?.verifications[0]?.provider;
        }

        if (comprehensiveKybVerification?.result) {
          signals = comprehensiveKybVerification.result;
        }

        if (comprehensiveKybVerification?.provider) {
          provider = comprehensiveKybVerification?.provider;
        }
      } else {
        signals = data?.verifications[0]?.result;
        provider = data?.verifications[0]?.provider;
      }
      break;

    case DecisionableTypeEnum.Counterparty:
    case DecisionableTypeEnum.IncomingPaymentDetail:
    case DecisionableTypeEnum.PaymentOrder:
    default:
      signals = data?.verifications[0]?.result;
      provider = data?.verifications[0]?.provider;
      break;
  }

  let additionalSignals: AdditionalSignals;

  // additionalSignals keys need to be added to data map to show in list
  if (data?.highestBoScore) {
    additionalSignals = {
      beneficialOwners: {
        value: data.highestBoScore,
        rawValue: startCase(data.highestBoScore),
        reasonCodes: ["See People tab for more information"],
      },
    };
  }

  const parsedSignals = JSON.parse(signals || "{}") as Signal[];
  const noVerificationsRequested = data?.verifications?.length === 0;

  useEffect(() => {
    if (!isEmpty(parsedSignals)) {
      const overallSignal = formatSignals(signals, "overall", provider);
      const riskProfiles = formatSignals(
        signals,
        "signals",
        provider,
        additionalSignals,
        data?.decisionable?.vendorChecks,
      );

      setRisks({
        overallProfile: overallSignal[0],
        profiles: riskProfiles,
      });
    }
    // mchaudhry05: parsedSignals causes unintended re-renders
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [signals]);

  if (noVerificationsRequested) {
    return <h2 className="text-lg">No verification was requested</h2>;
  }

  if (loading) {
    return (
      <IndexTableSkeletonLoader
        headers={Object.keys(RISK_PROFILE_MAPPING)}
        numRows={14}
      />
    );
  }

  if (isEmpty(parsedSignals)) {
    return (
      <h2 className="text-lg">Processing risk profile for this decision</h2>
    );
  }

  const content = (
    <>
      <div className="mb-6 flex flex-col items-start">
        <div
          className={`flex flex-row items-center ${hideTitle ? "hidden" : ""}`}
        >
          <h1 className="font-app mr-4 text-base font-medium">Overall Risk</h1>
          <RiskIndicator riskLevel={data.score} />
        </div>
        {risks?.overallProfile?.reason !== "-" && (
          <div id="rules" className="mt-2 h-fit w-fit">
            {risks?.overallProfile?.reason}
          </div>
        )}
      </div>
      <div className="mb-4 mt-8">
        <IndexTable
          dataMapping={RISK_PROFILE_MAPPING}
          data={risks?.profiles || []}
          styleMapping={{ reason: "table-entry-wide" }}
        />
      </div>
    </>
  );

  return expandable ? (
    <ExpandableCard expandable={expandable}>
      <div className={`px-6 py-1 ${hideTitle ? "-my-2" : ""}`}>{content}</div>
    </ExpandableCard>
  ) : (
    content
  );
}

export default DeprecatedRiskProfileView;
```

---
## `compliance/IdentityDetailsView.tsx.txt`
**Path:** `compliance`  
```
import { LazyQueryExecFunction } from "@apollo/client";
import React from "react";
import {
  KeyValueTable,
  KeyValueTableSkeletonLoader,
  ShowableText,
} from "../../../common/ui-components";
import { counterpartyDrawer } from "../CounterpartyDrawer";
import {
  Exact,
  ShowUserOnboardingAccountNumberQuery,
  ShowUserOnboardingTaxpayerIdentifierQuery,
  UserOnboarding,
  Flow__PartyTypeEnum,
  useShowUserOnboardingAccountNumberLazyQuery,
  useShowUserOnboardingTaxpayerIdentifierLazyQuery,
} from "../../../generated/dashboard/graphqlSchema";
import RiskLevelIndicator, { RiskLevel } from "./RiskLevelIndicator";

const NOT_COLLECTED = "Not Collected";
const UNKNOWN = "N/A";

const IDENTITY_DETAILS_DATA_MAPPING: {
  [key: string]: string;
} = {
  counterpartyId: "Counterparty ID",
  name: "Name",
  names: "Names",
  formationDate: "Formation Date",
  formationState: "Formation State",
  entityType: "Entity Type",
  website: "Website",
  firstName: "First Name",
  lastName: "Last Name",
  birthdate: "Birthdate",
  phoneNumber: "Phone Number",
  phoneNumbers: "Phone Numbers",
  email: "Email",
  address: "Address",
  address2: "Address 2",
  city: "City",
  state: "State",
  zipCode: "Zip Code",
  ssn: "SSN",
  taxId: "Tax ID",
  routingNumber: "Routing Number",
  accountNumber: "Account Number",
};

interface UserOnboardingDetails {
  party_details: {
    first_name?: string;
    last_name?: string;
    company_name?: string;
    date_of_birth?: string;
    phone_number: string;
    email: string;
    address: {
      line1: string;
      line2: string;
      locality: string;
      region: string;
      postal_code: string;
    };
  };
  taxpayer_identifier: string;
  external_account: {
    account_details: { account_number: string; account_number_type: string }[];
    routing_details: { routing_number: string; routing_number_type: string }[];
  };
}

interface Risk {
  level: RiskLevel;
  reason: string;
}

interface Name {
  name: string;
  sources: string[];
  risks: Risk[];
}

interface PhoneNumbers {
  phoneNumbers: string[];
  risks: Risk[];
}

interface Address {
  fullAddress: string;
  sources: string[];
  risks: Risk[];
}

interface Formation {
  formationDate: string;
  formationState: string;
  entityType: string;
}

interface Tin {
  tin: string;
  risks: Risk[];
}

interface KybDetails {
  names?: Name[];
  tin?: Tin;
  addresses?: Address[];
  formation?: Formation;
  phoneNumbers?: PhoneNumbers;
  bankAccountRisks?: Risk[];
}

interface IdentityDetailsTabProps {
  loading: boolean;
  userOnboarding?: UserOnboarding | null;
  kybDetails?: KybDetails | null;
  showUserOnboardingOnly?: boolean;
}

function renderRisks(risks: Risk[]) {
  if (!risks || risks.length === 0) {
    return null;
  }

  const riskIndicators = risks.map((risk) => (
    <RiskLevelIndicator riskLevel={risk.level} formatterOrText={risk.reason} />
  ));

  return <div className="ml-6 flex">{riskIndicators}</div>;
}

function taxpayerIdentifierComponent(
  getShowUserOnboardingTaxpayerIdentifier: LazyQueryExecFunction<
    ShowUserOnboardingTaxpayerIdentifierQuery,
    Exact<{ id: string }>
  >,
  userOnboardingId: string,
  redactedTaxpayerIdentifier: string,
  risks: Risk[],
) {
  if (redactedTaxpayerIdentifier === "") {
    return NOT_COLLECTED;
  }

  async function fetchTaxpayerIdentifier() {
    const result = await getShowUserOnboardingTaxpayerIdentifier({
      variables: { id: userOnboardingId },
    });

    return (
      result?.data?.userOnboardingShowTaxpayerIdentifier?.taxpayerIdentifier ||
      UNKNOWN
    );
  }

  return (
    <div className="flex">
      <ShowableText
        defaultText="â¢â¢â¢-â¢â¢â¢-â¢â¢â¢â¢"
        fullText="000000000"
        onClick={fetchTaxpayerIdentifier}
        allowCopy
      />
      {renderRisks(risks)}
    </div>
  );
}

function namesComponent(names?: Name[]) {
  if (!names || names.length === 0) {
    return null;
  }

  const namesRows = names.map((name, index) => (
    <div className="flex">
      <div>
        <div className={`flex ${index > 0 ? " mt-2" : ""}`} key={name.name}>
          {name.name}
        </div>
        <div className="flex">
          <div className="mr-2">Sources:</div>
          <div>{name.sources.join(", ").replace("_", " ")}</div>
        </div>
      </div>
      <div className="my-auto">{renderRisks(name.risks)}</div>
    </div>
  ));

  return <div>{namesRows}</div>;
}

function phoneNumberComponent(phoneNumbers?: PhoneNumbers) {
  if (!phoneNumbers) {
    return null;
  }

  const phoneNumbersList = phoneNumbers.phoneNumbers.join(", ");
  const { risks } = phoneNumbers;

  return (
    <div className="flex">
      <div>{phoneNumbersList}</div>
      {renderRisks(risks)}
    </div>
  );
}

function accountNumberComponent(
  getShowUserOnboardingAccountNumber: LazyQueryExecFunction<
    ShowUserOnboardingAccountNumberQuery,
    Exact<{ id: string }>
  >,
  accountNum: string,
  userOnboardingId: string,
  bankAccountRisks: Risk[] = [],
) {
  if (accountNum === NOT_COLLECTED) {
    return NOT_COLLECTED;
  }

  async function accountNumber() {
    const result = await getShowUserOnboardingAccountNumber({
      variables: { id: userOnboardingId },
    });
    return (
      result?.data?.userOnboardingShowAccountNumber?.accountNumber || UNKNOWN
    );
  }

  return (
    <div className="flex">
      <ShowableText
        defaultText={`â¢â¢â¢â¢ ${accountNum?.slice(
          accountNum.length - 4,
          accountNum.length,
        )}`}
        fullText={accountNum}
        onClick={accountNumber}
        allowCopy
      />
      {renderRisks(bankAccountRisks)}
    </div>
  );
}

function filterMissingDataInDataMapping(data: { [key: string]: unknown }) {
  const filteredDataMapping = {};

  Object.keys(IDENTITY_DETAILS_DATA_MAPPING).forEach((key) => {
    if (data[key]) {
      filteredDataMapping[key] = IDENTITY_DETAILS_DATA_MAPPING[key];
    }
  });

  return filteredDataMapping;
}

function IdentityDetailsView({
  loading,
  userOnboarding,
  kybDetails,
  showUserOnboardingOnly = false,
}: IdentityDetailsTabProps) {
  const [getShowUserOnboardingTaxpayerIdentifier] =
    useShowUserOnboardingTaxpayerIdentifierLazyQuery();
  const [getShowUserOnboardingAccountNumber] =
    useShowUserOnboardingAccountNumberLazyQuery();

  if (loading) {
    <KeyValueTableSkeletonLoader dataMapping={IDENTITY_DETAILS_DATA_MAPPING} />;
  }

  const userOnboardingData = userOnboarding?.data as string;
  const userOnboardingId = userOnboarding?.id;
  const uoDetails: UserOnboardingDetails = JSON.parse(
    userOnboardingData || "{}",
  ) as UserOnboardingDetails;
  const accountDetails = uoDetails?.external_account?.account_details;
  const accountNumber =
    accountDetails?.length > 0 && accountDetails[0].account_number
      ? accountDetails[0].account_number
      : NOT_COLLECTED;
  const routingDetails = uoDetails?.external_account?.routing_details;
  const routingNumber =
    routingDetails?.length > 0 && routingDetails[0].routing_number
      ? routingDetails[0].routing_number
      : NOT_COLLECTED;
  const redactedTaxpayerIdentifier = uoDetails?.taxpayer_identifier;

  const tinRisks = kybDetails?.tin?.risks || [];

  const bankAccountRisks = kybDetails?.bankAccountRisks;

  const showableAccountNumber = userOnboardingId
    ? accountNumberComponent(
        getShowUserOnboardingAccountNumber,
        accountNumber,
        userOnboardingId,
        bankAccountRisks,
      )
    : null;
  const showableTaxpayerIdentifier = userOnboardingId
    ? taxpayerIdentifierComponent(
        getShowUserOnboardingTaxpayerIdentifier,
        userOnboardingId,
        redactedTaxpayerIdentifier,
        tinRisks,
      )
    : null;

  const counterpartyId = userOnboarding?.counterpartyId;

  const isKyb = userOnboarding?.partyType === Flow__PartyTypeEnum.Business;
  const names = namesComponent(kybDetails?.names);
  const phoneNumbers = phoneNumberComponent(kybDetails?.phoneNumbers);
  const formation = kybDetails?.formation;
  const showAddressField = showUserOnboardingOnly || !isKyb;
  const showFormationField = !showUserOnboardingOnly && isKyb;

  const data = {
    counterpartyId: counterpartyId
      ? counterpartyDrawer(counterpartyId)
      : "Created upon case approval",
    names: isKyb && names,
    name: !isKyb && uoDetails?.party_details?.company_name,
    firstName: !isKyb && uoDetails?.party_details?.first_name,
    lastName: !isKyb && uoDetails?.party_details?.last_name,
    phoneNumbers: isKyb && phoneNumbers,
    phoneNumber: !isKyb && uoDetails?.party_details?.phone_number,
    email: !isKyb && uoDetails?.party_details?.email,
    address: showAddressField && uoDetails?.party_details?.address?.line1,
    address2: showAddressField && uoDetails?.party_details?.address?.line2,
    city: showAddressField && uoDetails?.party_details?.address?.locality,
    state: showAddressField && uoDetails?.party_details?.address?.region,
    zipCode: showAddressField && uoDetails?.party_details?.address?.postal_code,
    birthdate: !isKyb && uoDetails?.party_details?.date_of_birth,
    formationDate: showFormationField && formation?.formationDate,
    formationState: showFormationField && formation?.formationState,
    entityType: showFormationField && formation?.entityType,
    taxId: isKyb && showableTaxpayerIdentifier,
    ssn: !isKyb && showableTaxpayerIdentifier,
    routingNumber,
    accountNumber: showableAccountNumber,
  };

  const filteredDataMapping = filterMissingDataInDataMapping(data);

  return <KeyValueTable data={data} dataMapping={filteredDataMapping} />;
}

export default IdentityDetailsView;
```

---
## `compliance/People.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import {
  Verification,
  VerificationStatusEnum,
  Decision,
  UserOnboarding,
  BeneficialOwnersVendorCheckEnum,
} from "../../../generated/dashboard/graphqlSchema";
import {
  IndexTable,
  KeyValueTableSkeletonLoader,
} from "../../../common/ui-components";
import RiskIndicator from "./RiskLevelIndicator";
import DeprecatedRiskProfileView from "./DeprecatedRiskProfileView";

const PEOPLE_DATA_MAPPING = {
  name: "Name",
  title: "Title",
  sources: "Sources",
  risks: "Risk",
};

interface VerificationResult {
  other: OtherVerificationResult;
}

interface Risk {
  overall?: {
    overallRisk?: {
      value?: string;
    };
  };
}

interface OtherVerificationResult {
  people: {
    name: string;
    title: string;
    sources: string[];
    risks?: Risk;
  }[];
}

interface PeopleProps {
  data?: Decision;
  verification: Verification | null;
  boVerifications: Verification[] | null;
  userOnboarding?: UserOnboarding["data"];
  hasBeneficialOwnerCheck?: boolean;
}

interface Address {
  country: string;
  line1: string;
  line2: string;
  locality: string;
  postal_code: string;
  region: string;
}

interface BeneficialOwnersData {
  beneficial_owners: {
    address: Address;
    beneficial_owner_id: string;
    date_of_birth: string;
    email: string;
    first_name: string;
    last_name: string;
    is_control_person: boolean;
    phone_number: string;
    taxpayer_identifier: string;
  }[];
}

interface VerificationRiskObj {
  verifications: Verification[];
  decisionable: {
    vendorChecks: BeneficialOwnersVendorCheckEnum[];
  };
}

function People({
  data,
  verification,
  boVerifications,
  userOnboarding = "{}", // used to show BO's while middesk is processing
  hasBeneficialOwnerCheck = false, // determines whether to show "N/A" or
  "Pending"
}: PeopleProps) {
  const expandedData = {};
  if (!verification || !verification.result) {
    return <KeyValueTableSkeletonLoader />;
  }

  const userOnboardingData = JSON.parse(userOnboarding) as BeneficialOwnersData;

  const beneficialOwners = userOnboardingData?.beneficial_owners;

  const pendingBeneficialOwners = beneficialOwners?.map((bo) => ({
    name: `${bo.first_name} ${bo.last_name}`,
    sources: [],
    risk: [],
    title: [],
  }));

  const verificationResult = JSON.parse(
    verification.result,
  ) as VerificationResult;

  const people = verificationResult?.other?.people || pendingBeneficialOwners;
  if (boVerifications?.length) {
    boVerifications?.forEach((boVerification, index) => {
      if (people?.length && people[index]?.risks) {
        people[index].risks = JSON.parse(boVerification.result) as Risk;
      }

      // Format data to be consumed by RiskProfileView
      const verificationRiskObj: VerificationRiskObj = {
        verifications: [boVerifications?.[index]],
        decisionable: {
          vendorChecks: (data?.decisionable as UserOnboarding)
            ?.beneficialOwnersVendorChecks,
        },
      };

      expandedData[index] = (
        <DeprecatedRiskProfileView
          loading={false}
          data={verificationRiskObj as unknown as Decision}
          expandable
          hideTitle
        />
      );
    });
  }

  const peoplesData = people?.map((person, index) => {
    const { name, sources, risks } = person;
    const title = person.title || "N/A";

    // If middesk verifications aren't done yet, show
    // "Pending" if BO checks are on, and "N/A" if not.
    const overallRisk = (
      <RiskIndicator
        riskLevel={
          risks?.overall?.overallRisk?.value ||
          (hasBeneficialOwnerCheck ? VerificationStatusEnum.Pending : "N/A")
        }
      />
    );

    const sourcesComponents = sources?.map((source) => <div>{source}</div>);

    return {
      id: index.toString(),
      name,
      title,
      sources: sourcesComponents,
      risks: overallRisk,
    };
  });

  return (
    <IndexTable
      enableActions
      data={peoplesData || []}
      dataMapping={PEOPLE_DATA_MAPPING}
      expandedData={
        verificationResult?.other?.people?.length ? expandedData : false
      }
    />
  );
}

export default People;
```

---
## `compliance/RiskLevelIndicator.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import { DECISIONS_SCORES } from "../../constants";
import { OverflowTip } from "../../../common/ui-components";

interface RiskLevelIndicatorProps {
  formatterOrText?: Record<string, string> | string;
  riskLevel?: string | null;
}

export type RiskLevel = "low" | "medium" | "high" | "very_high";

function RiskLevelIndicator({
  formatterOrText = DECISIONS_SCORES,
  riskLevel,
}: RiskLevelIndicatorProps) {
  let indicatorColor;
  let textColor;
  switch (riskLevel) {
    case "low":
      indicatorColor = "bg-green-400";
      textColor = "text-green-600";
      break;
    case "medium":
      indicatorColor = "bg-yellow-300";
      textColor = "text-yellow-400";
      break;
    case "high":
      indicatorColor = "bg-orange-400";
      textColor = "text-orange-600";
      break;
    case "very_high":
      indicatorColor = "bg-red-500";
      textColor = "text-red-700";
      break;
    default:
      indicatorColor = "bg-gray-500";
      textColor = "text-gray-800";
      break;
  }

  let label = "N/A";
  if (formatterOrText) {
    label =
      typeof formatterOrText === "string"
        ? formatterOrText
        : formatterOrText[riskLevel || ""] || "N/A";
  }

  return (
    <div className="flex items-center">
      <div className="mr-1">
        <div
          className={`${indicatorColor as string} h-1.5 w-1.5 rounded-full`}
        />
      </div>
      <OverflowTip
        id="risk-score"
        message={label}
        className={`truncate text-xs ${textColor as string}`}
      >
        {label}
      </OverflowTip>
    </div>
  );
}

export default RiskLevelIndicator;
```

---
## `compliance/RiskProfileView.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import {
  Drawer,
  ExpandableCard,
  IndexTable,
  IndexTableSkeletonLoader,
  LoadingLine,
  OverflowTip,
} from "../../../common/ui-components";
import SardineRuleView from "./SardineRuleView";
import RiskIndicator from "./RiskLevelIndicator";
import {
  VendorCheckEnum,
  Verification,
  VerificationStatusEnum,
  Verification__TypeEnum,
  Decision__ScoreEnum,
} from "../../../generated/dashboard/graphqlSchema";
import { VENDOR_CHECKS_DATA_MAPPING } from "./DeprecatedRiskProfileView";

const RISK_PROFILE_MAPPING = {
  categoryName: "Category",
  score: "Risk Level",
  reasonCodes: "Reason",
};

const PROCESSING_STATUSES = [
  VerificationStatusEnum.Processing,
  VerificationStatusEnum.Pending,
];

const SCORES = [
  Decision__ScoreEnum.Low,
  Decision__ScoreEnum.Medium,
  Decision__ScoreEnum.High,
  Decision__ScoreEnum.VeryHigh,
];

const OVERALL_RISK_CATEGORY = "overallRisk";

type OverallRisk = {
  score: Decision__ScoreEnum | undefined;
  reasonCodes: string[];
};

function getOverallRisk(verifications: Verification[]): OverallRisk {
  const overallResults = verifications
    .flatMap((verification) => verification.riskProfileVerificationResult)
    .filter(
      (verificationResult) =>
        verificationResult.categoryName === OVERALL_RISK_CATEGORY,
    );

  const overallRiskScore = overallResults.sort(
    (resultA, resultB) =>
      SCORES.indexOf(resultB.score as Decision__ScoreEnum) -
      SCORES.indexOf(resultA.score as Decision__ScoreEnum),
  )[0]?.score as Decision__ScoreEnum;

  const reasonCodes = overallResults.flatMap(
    (verificationResult) => verificationResult.reasonCodes,
  );

  return {
    score: overallRiskScore,
    reasonCodes,
  };
}

interface ReasonCodesProps {
  reasonCodes: string[];
}

function ReasonCodes({ reasonCodes }: ReasonCodesProps) {
  const formattedReasonCodes = reasonCodes.map((reasonCode: string) => {
    const ruleHasDescription = reasonCode.indexOf(":") !== -1;
    const [ruleName, ruleDescription] = reasonCode.split(":");
    const ruleId = ruleName.substring(5, ruleName.length);
    return {
      reasonCode,
      ruleHasDescription,
      ruleDescription,
      ruleName,
      ruleId,
    };
  });

  return (
    <div>
      {formattedReasonCodes?.map(
        ({
          reasonCode,
          ruleHasDescription,
          ruleDescription,
          ruleName,
          ruleId,
        }) => (
          <div className="h-fit w-full" key={reasonCode}>
            <OverflowTip message={reasonCode} className="truncate">
              {!ruleHasDescription ? (
                reasonCode
              ) : (
                <>
                  <Drawer
                    trigger={
                      <span className="cursor-pointer underline">
                        {ruleName}
                      </span>
                    }
                  >
                    <SardineRuleView ruleId={ruleId} />
                  </Drawer>
                  {`: ${ruleDescription || "No description provided"}`}
                </>
              )}
            </OverflowTip>
          </div>
        ),
      )}
    </div>
  );
}

function getVerificationRows(
  verifications: Verification[],
  vendorChecks: VendorCheckEnum[],
) {
  const categoryNameByPermittedCheck: Record<string, string> =
    vendorChecks.reduce(
      (acc, vendorCheck) => ({
        ...acc,
        ...VENDOR_CHECKS_DATA_MAPPING[vendorCheck],
      }),
      {},
    );
  const results = verifications
    .filter(
      (verification) =>
        verification.verificationType !==
        Verification__TypeEnum.BeneficialOwner,
    )
    .flatMap((verification) => verification.riskProfileVerificationResult)
    .filter(
      (verificationResult) =>
        verificationResult.categoryName !== OVERALL_RISK_CATEGORY,
    )
    .filter(
      (verificationResult) =>
        verificationResult.categoryName in categoryNameByPermittedCheck,
    )
    .sort(
      (verificationResultA, verificationResultB) =>
        SCORES.indexOf(verificationResultB.score as Decision__ScoreEnum) -
        SCORES.indexOf(verificationResultA.score as Decision__ScoreEnum),
    );

  return results.map(({ categoryName, score, reasonCodes }) => {
    const formattedReasonCodes =
      reasonCodes.length > 0 ? <ReasonCodes reasonCodes={reasonCodes} /> : "-";

    return {
      categoryName: categoryNameByPermittedCheck[categoryName],
      score: <RiskIndicator riskLevel={score} />,
      reasonCodes: formattedReasonCodes,
    };
  });
}

interface RiskProfileViewProps {
  verifications: Verification[] | undefined;
  vendorChecks: VendorCheckEnum[];
  loading: boolean;
  hideTitle?: boolean;
  expandable?: boolean;
}

function RiskProfileView({
  verifications,
  vendorChecks,
  loading,
  expandable = false,
  hideTitle = false,
}: RiskProfileViewProps) {
  const loadingContent = (
    <>
      <div className="mb-6 flex flex-col items-start">
        <div
          className={`flex flex-row items-center ${hideTitle ? "hidden" : ""}`}
        >
          <h1 className="font-app mr-4 text-base font-medium">Overall Risk</h1>
          <div className="w-12">
            <LoadingLine />
          </div>
        </div>
        <div className="mt-2 flex w-48 flex-col space-y-2">
          <LoadingLine />
          <LoadingLine />
          <LoadingLine />
          <LoadingLine />
        </div>
      </div>
      <div className="mb-4 mt-8">
        <IndexTableSkeletonLoader
          headers={Object.keys(RISK_PROFILE_MAPPING)}
          numRows={14}
        />
      </div>
    </>
  );

  if (loading || !verifications) {
    return expandable ? (
      <ExpandableCard expandable={expandable}>
        <div className={`px-6 py-1 ${hideTitle ? "-my-2" : ""}`}>
          {loadingContent}
        </div>
      </ExpandableCard>
    ) : (
      loadingContent
    );
  }

  if (!loading && verifications.length === 0) {
    return <h2 className="text-lg">No verification was requested</h2>;
  }

  const hasProcessingVerifications = verifications.some((verification) =>
    PROCESSING_STATUSES.includes(verification.status),
  );

  if (!loading && hasProcessingVerifications) {
    return (
      <h2 className="text-lg">Processing risk profile for this decision</h2>
    );
  }

  const overallRisk = getOverallRisk(verifications);
  const verificationDataRows = getVerificationRows(verifications, vendorChecks);

  const content = (
    <>
      <div className="mb-6 flex flex-col items-start">
        <div
          className={`flex flex-row items-center ${hideTitle ? "hidden" : ""}`}
        >
          <div className="mr-4 text-base font-medium">Overall Risk</div>
          <RiskIndicator riskLevel={overallRisk.score} />
        </div>
        {overallRisk.reasonCodes && (
          <div id="rules" className="mt-2 h-fit w-fit">
            <ReasonCodes reasonCodes={overallRisk.reasonCodes} />
          </div>
        )}
      </div>
      <div className="mb-4 mt-8">
        <IndexTable
          dataMapping={RISK_PROFILE_MAPPING}
          data={verificationDataRows}
          styleMapping={{ reason: "table-entry-wide" }}
        />
      </div>
    </>
  );

  return expandable ? (
    <ExpandableCard expandable={expandable}>
      <div className={`px-6 py-1 ${hideTitle ? "-my-2" : ""}`}>{content}</div>
    </ExpandableCard>
  ) : (
    content
  );
}

export default RiskProfileView;
```

---
## `compliance/SardineRuleView.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import {
  Heading,
  KeyValueTable,
  KeyValueTableSkeletonLoader,
} from "../../../common/ui-components";
import { useSardineRuleViewQuery } from
"../../../generated/dashboard/graphqlSchema";
import RiskLevelIndicator from "./RiskLevelIndicator";

const SARDINE_RULE_DATA_MAPPING = {
  ruleId: "Rule ID",
  name: "Rule Name",
  condition: "Rule Condition",
  action: "Action",
  description: "Description",
};

interface SardineRuleViewProps {
  ruleId: string;
}

function replaceRiskLevelStringWithNumber(action: string) {
  const updatedAction = action
    .split("=low ")
    .join("=1 ")
    .split("=medium ")
    .join("=2 ")
    .split("=very_high ")
    .join("=4 ")
    .split("=high ")
    .join("=3 ");

  return updatedAction;
}

function replaceWithRiskLevelIndicator(actionBits: string[]) {
  const riskLevelNumberToStringMapping = {
    "1": "low",
    "2": "medium",
    "3": "high",
    "4": "very_high",
  };
  const excludeActionNames = ["riskCount"];
  const updatedActionBits = actionBits.map((action) => {
    const [actionName, actionRiskValue] = action.split("=");

    const replaceWithIndicator =
      actionRiskValue in riskLevelNumberToStringMapping &&
      !excludeActionNames.includes(actionName);

    const actionRisk = !replaceWithIndicator ? (
      `${actionRiskValue} `
    ) : (
      <div className="mx-2 flex">
        <RiskLevelIndicator
          riskLevel={riskLevelNumberToStringMapping[actionRiskValue] as string}
        />
      </div>
    );

    return [`${actionName}=`, actionRisk];
  });

  const updatedAction = updatedActionBits.flatMap((item) => item);

  return updatedAction;
}

function formatAction(action: string) {
  const reformatAction = `${action} `;
  const actionBits =
    replaceRiskLevelStringWithNumber(reformatAction).split(" ");
  actionBits.pop();
  const updatedAction = replaceWithRiskLevelIndicator(actionBits);

  return updatedAction;
}

function SardineRuleView({ ruleId }: SardineRuleViewProps) {
  const { loading, data } = useSardineRuleViewQuery({
    variables: { ruleId },
  });
  return (
    <div id="payment-order-details-panel">
      <div className="w-full px-2 py-5">
        <Heading level="h1" size="l">
          {`Details of Rule #${ruleId}`}
        </Heading>
      </div>
      {(loading || !data) && (
        <KeyValueTableSkeletonLoader dataMapping={SARDINE_RULE_DATA_MAPPING} />
      )}
      {!loading && data && (
        <KeyValueTable
          dataMapping={SARDINE_RULE_DATA_MAPPING}
          data={{
            ...data?.sardineRule,
            ruleId: data?.sardineRule?.id,
            action: formatAction(data?.sardineRule?.action || ""),
          }}
          altRowClassNames="detail-panel-row"
          altTableClassNames="detail-panel p-6"
        />
      )}
    </div>
  );
}

export default SardineRuleView;
```

---
## `compliance/WatchlistProfileView.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import { ExpandableCard } from "../../../common/ui-components";
import RiskLevelIndicator from "./RiskLevelIndicator";
import Watchlists from "./Watchlists";
import {
  Decision,
  Verification,
} from "../../../generated/dashboard/graphqlSchema";

function WatchlistProfileView({
  decisionable,
  verification = null,
}: {
  decisionable: Decision;
  verification?: Verification | null;
}) {
  return (
    <ExpandableCard>
      <div className="px-6 py-1">
        <div className="mb-6 flex flex-col items-start">
          <div className="flex flex-row items-center">
            <h1 className="font-app mr-4 text-base font-medium">
              Overall Risk
            </h1>
            <RiskLevelIndicator riskLevel={decisionable.score} />
          </div>
        </div>

        <div className="mb-4 mt-8">
          <Watchlists verification={verification} />
        </div>
      </div>
    </ExpandableCard>
  );
}

export default WatchlistProfileView;
```

---
## `compliance/Watchlists.tsx.txt`
**Path:** `compliance`  
```
import React from "react";
import {
  Decision__ScoreEnum,
  Verification,
  VerificationProviderEnum,
} from "../../../generated/dashboard/graphqlSchema";
import RiskLevelIndicator from "./RiskLevelIndicator";
import {
  IndexTable,
  KeyValueTableSkeletonLoader,
  KeyValueTable,
} from "../../../common/ui-components";

const KYB_WATCHLISTS_DATA_MAPPING = {
  organization: "Organization",
  title: "Title",
  agency: "Agency",
  status: "Status",
};

const KYC_WATCHLISTS_DATA_MAPPING = {
  sourceName: "Source Name",
  type: "Type",
  description: "Description",
};

const ENTITY_INFORMATION_DATA_MAPPING = {
  entityName: "Entity Name",
  matchScore: "Match Score",
  riskScore: "Risk Score",
  dobs: "Date of Birth(s)",
  countryCodes: "Country Codes",
};

interface KYBWatchlist {
  organization: string;
  title: string;
  agency: string;
  results: {
    entityName: string;
  }[];
}

interface KYBVerificationResult {
  other: OtherKYBVerificationResult;
}

interface OtherKYBVerificationResult {
  watchlist: {
    lists: KYBWatchlist[];
  };
}

const SOURCE_TYPES_MAPPING = {
  sanction: "Sanction",
  pep: "Politically Exposed Person",
  adverseMedia: "Adverse Media",
};

interface Source {
  sourceName: string;
  sourceUrl: string;
  description: string;
  type: string;
}

interface KYCWatchlist {
  entityName: string;
  matchScore: number;
  riskScore: number;
  countryCodes: string[];
  dobs: string[];
  sources: Source[];
}

interface KYCVerificationResult {
  aml: KYCWatchlist;
}

interface WatchlistsProps {
  verification: Verification | null;
}

const getKYBWatchlistsData = (verification: Verification) => {
  const verificationResult = JSON.parse(
    verification.result,
  ) as KYBVerificationResult;
  const watchlists = verificationResult?.other?.watchlist?.lists || [];

  const rows = watchlists.map((watchlist) => {
    const hits = watchlist.results.length > 0;
    const riskLevel = hits
      ? Decision__ScoreEnum.VeryHigh
      : Decision__ScoreEnum.Low;
    const status = hits
      ? watchlist.results.map((result) => result.entityName).join(", ")
      : "No hits";

    const statusComponent = (
      <RiskLevelIndicator formatterOrText={status} riskLevel={riskLevel} />
    );

    return {
      organization: watchlist.organization,
      title: watchlist.title,
      agency: watchlist.agency,
      status: statusComponent,
    };
  });

  return rows;
};

const getKYCWatchlistsData = (verification: Verification) => {
  const verificationResult = JSON.parse(
    verification.result,
  ) as KYCVerificationResult;

  const watchlist = verificationResult?.aml;
  const entityName = watchlist?.entityName;
  const matchScore = watchlist?.matchScore?.toString();
  const riskScore = watchlist?.riskScore?.toString();

  const sources = watchlist?.sources || [];
  const countryCodes = watchlist?.countryCodes?.join(", ");
  const dobs = watchlist?.dobs?.join(", ");

  const formattedSources = sources.map((source) => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const formattedType = SOURCE_TYPES_MAPPING[source.type];

    const sourceNameUrl = <a href={source.sourceUrl}>{source.sourceName}</a>;

    return {
      sourceName: sourceNameUrl,
      description: source.description,
      type: formattedType as string,
    };
  });

  return {
    entityInformation: {
      entityName,
      matchScore,
      riskScore,
      countryCodes,
      dobs,
    },
    formattedSources,
  };
};

function Watchlists({ verification }: WatchlistsProps) {
  if (!verification || !verification.result) {
    return <KeyValueTableSkeletonLoader />;
  }

  const isKyb = verification.provider === VerificationProviderEnum.Middesk;

  const KYCWatchlistsData = getKYCWatchlistsData(verification);

  return (
    <div>
      {isKyb ? (
        <IndexTable
          data={getKYBWatchlistsData(verification)}
          dataMapping={KYB_WATCHLISTS_DATA_MAPPING}
          styleMapping={{
            status: "table-entry-wide",
          }}
        />
      ) : (
        <>
          <div className="kyc-key-value-table">
            <KeyValueTable
              data={KYCWatchlistsData.entityInformation}
              dataMapping={ENTITY_INFORMATION_DATA_MAPPING}
            />
          </div>
          <p className="mb-5 mt-10 text-base font-medium">Sources</p>
          <div className="kyc-index-table">
            <IndexTable
              data={KYCWatchlistsData.formattedSources}
              dataMapping={KYC_WATCHLISTS_DATA_MAPPING}
            />
          </div>
        </>
      )}
    </div>
  );
}

export default Watchlists;
```

---
## `exporting/ArchivedRecordsBanner.tsx.txt`
**Path:** `exporting`  
```
import React from "react";
import { Alert } from "../../../common/ui-components";

type ArchivedResourceType =
  | "AuditRecord"
  | "Event"
  | "RequestLog"
  | "WebhookDeliveryAttempt";

const RESOURCE_TYPE_TO_TEXT: Record<ArchivedResourceType, string> = {
  AuditRecord: "Audit Records",
  Event: "Event data",
  RequestLog: "Request Logs",
  WebhookDeliveryAttempt: "Webhook Delivery Attempts",
};

const DATA_RETENTION_DOCUMENTATION_LINK =
  "https://docs.moderntreasury.com/platform/reference/data-retention";

interface ArchivedRecordsBannerProps {
  liveMode: boolean;
  resourceType: ArchivedResourceType;
  className?: string;
}

export default function ArchivedRecordsBanner({
  className,
  liveMode,
  resourceType,
}: ArchivedRecordsBannerProps) {
  const archivedData = RESOURCE_TYPE_TO_TEXT[resourceType];

  function archivedResourceText(): string {
    if (resourceType === "WebhookDeliveryAttempt") return archivedData;

    return `${liveMode ? "Live" : "Sandbox"} ${archivedData}`;
  }

  function retentionPeriodText(): string {
    switch (resourceType) {
      case "AuditRecord":
        return liveMode ? "four months" : "two months";
      case "Event":
        return liveMode ? "four months" : "two months";
      case "WebhookDeliveryAttempt":
        return "six weeks";
      case "RequestLog":
        return liveMode ? "four months" : "two months";
      default:
        return "";
    }
  }

  function showExportText(): boolean {
    return resourceType !== "WebhookDeliveryAttempt";
  }

  return (
    <Alert alertType="info" className={className}>
      <p>
        {archivedResourceText()}
        {` older than ${retentionPeriodText()} `}
        {resourceType === "Event" ? "is" : "are"}{" "}
        {resourceType === "WebhookDeliveryAttempt" ? "deleted" : "archived"} as
        per our{" "}
        <a
          href={DATA_RETENTION_DOCUMENTATION_LINK}
          target="_blank"
          rel="noreferrer"
        >
          data retention policy
        </a>
        .
        {showExportText() &&
          ` Initiate a CSV export to retrieve archived data.`}
      </p>
    </Alert>
  );
}
```

---
## `filter/AppliedFilterDropdown.tsx.txt`
**Path:** `filter`  
```
import React, { useEffect, useRef } from "react";
import { Popover as HeadlessPopover } from "@headlessui/react";
import invariant from "ts-invariant";
import {
  LogicalForm__InputTypeEnum,
  TimeFormatEnum,
} from "~/generated/dashboard/graphqlSchema";
import { cn } from "~/common/utilities/cn";
import { AppliedFilterType } from "./util";
import { Popover, PopoverPanel } from "../../../common/ui-components";
import FilterInputTypeRenderer from "./FilterInputRenderer";

/**
 * Hook that alerts clicks outside of the passed ref
 */
function useOutsideAlerter(
  ref: React.MutableRefObject<HTMLDivElement | null>,
  handler: () => void,
  handleClickAddFilter: () => void,
  shouldBindListener: boolean,
  filterSelectorDropdownRef: React.MutableRefObject<HTMLButtonElement | null>,
) {
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (
        filterSelectorDropdownRef?.current &&
        filterSelectorDropdownRef?.current.contains(event.target as Node)
      ) {
        handleClickAddFilter();
      } else if (ref?.current && !ref?.current.contains(event.target as Node)) {
        handler();
      }
    }

    if (shouldBindListener) {
      // Bind the event listener
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        // Unbind the event listener on clean up
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }
    return () => {};
  }, [
    ref,
    handler,
    shouldBindListener,
    filterSelectorDropdownRef,
    handleClickAddFilter,
  ]);
}

/**
 * Hook that alerts when the Enter or Escape key is pressed.
 * Prevents the default event action to prevent conflict with text inputs
 */
function useKeyPressAlerter(handler: () => void) {
  useEffect(() => {
    function handleKeyPress(event: KeyboardEvent) {
      if (event.key === "Escape" || event.key === "Enter") {
        event.preventDefault();
        handler();
      }
    }

    document.addEventListener("keydown", handleKeyPress);

    return () => {
      document.removeEventListener("keydown", handleKeyPress);
    };
  }, [handler]);
}

interface AppliedFilterDropdownProps {
  onChange: (filter: AppliedFilterType) => void;
  appliedFilter: AppliedFilterType;
  children: (args: { popoverOpen: boolean }) => React.ReactNode;
  onClose: () => void;
  filterSelectorDropdownRef: React.MutableRefObject<HTMLButtonElement | null>;
  handleClickAddFilter: () => void;
}

function AppliedFilterDropdownPanel({
  appliedFilter,
  onChange,
  onClose,
}: {
  onChange: (filter: AppliedFilterType) => void;
  appliedFilter: AppliedFilterType;
  onClose: () => void;
}) {
  // Close the dropdown when the user presses Escape or Enter
  useKeyPressAlerter(onClose);
  return (
    <FilterInputTypeRenderer
      appliedFilter={appliedFilter}
      onChange={onChange}
      onClose={onClose}
    />
  );
}

function isDateChange(
  type: LogicalForm__InputTypeEnum,
  change: AppliedFilterType,
  format: TimeFormatEnum,
) {
  if (LogicalForm__InputTypeEnum.DateInput !== type) {
    return false;
  }
  invariant(typeof change.value === "object" && !Array.isArray(change.value));
  return change.value.format === format;
}

function AppliedFilterDropdown({
  appliedFilter,
  children,
  onChange,
  onClose,
  filterSelectorDropdownRef,
  handleClickAddFilter,
}: AppliedFilterDropdownProps) {
  const wrapperRef = useRef(null);

  // Call the handler after closing the dropdown panel
  // This will either remove the filter pill (if the value is empty)
  // or remove the applying flag.
  function handleClickOutside() {
    onClose();
  }

  useOutsideAlerter(
    wrapperRef,
    handleClickOutside,
    handleClickAddFilter,
    appliedFilter.applying,
    filterSelectorDropdownRef,
  );

  return (
    <div
      ref={wrapperRef}
      data-dd-action-name={`applied filter dropdown: ${appliedFilter.name}`}
    >
      <Popover className="relative bg-white">
        {({ open }) => (
          <>
            <HeadlessPopover.Button className="outline-none">
              {children({ popoverOpen: open as boolean })}
            </HeadlessPopover.Button>
            <PopoverPanel
              className={cn(
                "w-60 rounded-sm bg-white shadow",
                appliedFilter.type ===
                  LogicalForm__InputTypeEnum.MultiAccountSelect &&
                  "border-none",
                appliedFilter.type !== LogicalForm__InputTypeEnum.DateInput &&
                  "max-h-96",
              )}
              // This forces the dropdown panel to be shown by default when
              applying a new filter
              staticPanel={appliedFilter.applying}
            >
              {({ close }) => (
                <AppliedFilterDropdownPanel
                  appliedFilter={appliedFilter}
                  onChange={(change) => {
                    // For Single Select style inputs, automatically close the
                    popover
                    // after a selection has been made.
                    if (
                      [
                        LogicalForm__InputTypeEnum.SingleSelect,
                        LogicalForm__InputTypeEnum.CounterpartySelect,
                        LogicalForm__InputTypeEnum.InvoiceSelect,
                        LogicalForm__InputTypeEnum.ReconciliationRuleSelect,
                        LogicalForm__InputTypeEnum.PreviewReconciliationRuleSele
                        ct,
                      ].includes(appliedFilter.type) ||
                      // Duration format (i.e. "Past Week") are single select
                      style
                      isDateChange(
                        appliedFilter.type,
                        change,
                        TimeFormatEnum.Duration,
                      )
                    ) {
                      (close as () => void)();
                      onChange({ ...change, applying: false });
                    } else if (
                      // Date style uses DateInput, only call onChange
                      // when the values change (rather than on every keystroke)
                      isDateChange(
                        appliedFilter.type,
                        change,
                        TimeFormatEnum.Date,
                      )
                    ) {
                      invariant(
                        typeof change.value === "object" &&
                          !Array.isArray(change.value),
                      );
                      invariant(
                        appliedFilter.value === undefined ||
                          (typeof appliedFilter.value === "object" &&
                            !Array.isArray(appliedFilter.value)),
                      );
                      if (
                        change.value.lte !== appliedFilter.value?.lte ||
                        change.value.gte !== appliedFilter.value?.gte
                      ) {
                        onChange(change);
                      }
                    } else {
                      onChange(change);
                    }
                  }}
                  onClose={() => {
                    (close as () => void)();
                    onClose();
                  }}
                />
              )}
            </PopoverPanel>
          </>
        )}
      </Popover>
    </div>
  );
}

export default AppliedFilterDropdown;
```

---
## `filter/FilterArea.tsx.txt`
**Path:** `filter`  
```
import React, { Dispatch, SetStateAction, useRef, useState } from "react";
import { differenceWith, isEmpty, isEqual, isNil, omit, omitBy } from "lodash";
import { v4 as uuidv4 } from "uuid";
import { Popover } from "@headlessui/react";
import { FieldArray, Formik } from "formik";
import invariant from "ts-invariant";
import { cn } from "~/common/utilities/cn";
import { parse } from "~/common/utilities/queryString";
import { ButtonClickEventTypes } from "~/common/ui-components";
import useViewDocument from
"~/common/utilities/persisted_views/useViewDocument";
import { FILTER_AREA_EVENTS } from "~/common/constants/analytics";
import {
  AppliedFilterType,
  FilterType,
  metadataValueFromURLToState,
} from "./util";
import FilterPill from "./FilterPill";
import FilterSelectorDropdown, {
  PopoverTrigger,
} from "./FilterSelectorDropdown";
import useQueryParams from "./useQueryParams";
import {
  LogicalForm__InputTypeEnum,
  View,
  ViewDocumentTypeEnum,
  ResourceEnum,
} from "../../../generated/dashboard/graphqlSchema";
import { ACCOUNT_DATE_RANGE_FILTER_OPTIONS } from
"../../containers/reconciliation/utils";
import { DateRangeValues } from "../../../common/ui-
components/DateRangePicker/DateRangePicker";
import ColumnSelectorDropdown, {
  ColumnSelectorDropdownProps,
} from "../ColumnSelectorDropdown";
import ExportDataButton, { ExportDataButtonProps } from "../ExportDataButton";
import AppliedFilterDropdown from "./AppliedFilterDropdown";
import trackEvent from "../../../common/utilities/trackEvent";
import ClearFiltersButton from "../ClearFiltersButton";

const filterValues = (
  filtersFromURL: Record<string, unknown>,
  filtersFromViewDocument: Record<string, unknown>,
  defaultFilters: Record<string, unknown>,
) => {
  if (!isEmpty(filtersFromURL)) {
    return filtersFromURL;
  }
  if (!isEmpty(filtersFromViewDocument)) {
    return filtersFromViewDocument;
  }
  return defaultFilters;
};

/**
 * Finds the matching Filter entry for all keys in the
 * query string filters
 */
function enhanceFiltersFromURL(
  filters: Array<FilterType | AppliedFilterType>,
  filtersFromURL: Record<string, unknown>,
  filtersFromViewDocument: Record<string, unknown>,
) {
  const availableFilterNameToAvailableFiltersMap: Record<string, FilterType> =
    filters.reduce(
      (obj, item) => ({ ...obj, [item.key]: item }) as FilterType,
      {},
    );

  const defaultFilters = filters
    .filter((item) => item.default)
    .reduce(
      (obj, item) => ({
        ...obj,
        [item.key]: (item as AppliedFilterType).value,
      }),
      {},
    );

  const enhancedFiltersFromURL = Object.entries(
    filterValues(filtersFromURL, filtersFromViewDocument, defaultFilters),
  ).map(
    ([key, value]) =>
      ({
        ...availableFilterNameToAvailableFiltersMap[key],
        value,
      }) as AppliedFilterType,
  );

  return enhancedFiltersFromURL;
}

/**
 * Takes the filters from the query string and converts them
 * to a structure which matches the AppliedFilterType
 */
function parseURLForAppliedFilters(
  filters: FilterType[],
  filtersFromURL: Record<string, unknown>,
  filtersFromViewDocument: Record<string, unknown>,
  setAppliedFiltersCount: Dispatch<SetStateAction<number>>,
) {
  const enhancedFiltersFromURL = enhanceFiltersFromURL(
    filters,
    filtersFromURL,
    filtersFromViewDocument,
  );
  let appliedFiltersFromURL: AppliedFilterType[] = [];

  enhancedFiltersFromURL.forEach((enhancedFilter) => {
    if (enhancedFilter.hidden) {
      return;
    }
    switch (enhancedFilter.type) {
      case LogicalForm__InputTypeEnum.DateInput: {
        const dateFilter = ACCOUNT_DATE_RANGE_FILTER_OPTIONS.find(
          (dateFilterOption) =>
            isEqual(dateFilterOption.dateRange, enhancedFilter?.value),
        );

        const exactDateValue = enhancedFilter?.value as Omit<
          DateRangeValues,
          "dateRange"
        >;

        if (exactDateValue?.lte || exactDateValue?.gte || dateFilter) {
          appliedFiltersFromURL.push({
            ...enhancedFilter,
            id: uuidv4(),
          });
        }
        break;
      }
      case LogicalForm__InputTypeEnum.MetadataInput: {
        const metadataFilters = metadataValueFromURLToState(
          omit(enhancedFilter, ["value"]),
          enhancedFilter.value as string,
        );
        appliedFiltersFromURL = appliedFiltersFromURL.concat(metadataFilters);
        break;
      }
      default: {
        appliedFiltersFromURL.push({
          ...enhancedFilter,
          id: uuidv4(),
        });
        break;
      }
    }
  });

  setAppliedFiltersCount(appliedFiltersFromURL.length);

  return appliedFiltersFromURL;
}

/**
 * Determines what the available filters are based on what is already applied
 * in the query string.
 */
function parseURLForInitialAvailableFilters(
  filters: Array<FilterType | AppliedFilterType>,
  filtersFromURL: Record<string, unknown>,
  filtersFromViewDocument: Record<string, unknown>,
) {
  const enhancedFiltersFromURL = enhanceFiltersFromURL(
    filters,
    filtersFromURL,
    filtersFromViewDocument,
  );

  const availableFiltersFromURL = differenceWith(
    filters,
    enhancedFiltersFromURL,
    (filter, enhancedFilterFromURL) =>
      enhancedFilterFromURL.key === filter.key && !filter.repeatable,
  );

  return availableFiltersFromURL;
}

function completeMetadataValue(appliedFilter: AppliedFilterType) {
  return (
    typeof appliedFilter.value === "object" &&
    !Array.isArray(appliedFilter.value) &&
    !!appliedFilter.value?.value &&
    !!appliedFilter.value?.key
  );
}

function completeAmountValue(appliedFilter: AppliedFilterType) {
  return (
    appliedFilter.type === LogicalForm__InputTypeEnum.AmountInput &&
    typeof appliedFilter.value === "object" &&
    !Array.isArray(appliedFilter.value) &&
    (appliedFilter.value.gte !== null || appliedFilter.value.lte !== null)
  );
}

const shouldDebounceQuery = (filterType: LogicalForm__InputTypeEnum | null) =>
  !!filterType &&
  [
    LogicalForm__InputTypeEnum.AmountInput,
    LogicalForm__InputTypeEnum.MetadataInput,
    LogicalForm__InputTypeEnum.NumberInput,
    LogicalForm__InputTypeEnum.TextInput,
  ].includes(filterType);

export interface FilterAreaProps {
  filterName?: ResourceEnum;
  handleRefetch?: (
    queryParams: Record<string, unknown>,
    debounceQuery: boolean,
  ) => Promise<void> | void;
  filterIdsToRemove?: Array<string>;
  legacyQueryToFilters?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  view?: View;
}

/**
 * A wrapper to manage the overall state of the FilterArea.
 * This form stores an array of AppliedFilters and is responsible for adding,
 * removing and updating the items in the list.
 */
function FilterAreaFormikWrapper({
  availableFilters,
  setAvailableFilters,
  onChange,
  initialValues,
  filterSelectorDropdownLabel,
  setAppliedFiltersCount = () => {},
}: {
  availableFilters: Array<FilterType>;
  setAvailableFilters: (filters: Array<FilterType>) => void;
  onChange: (
    change: { filters: Array<AppliedFilterType> },
    debounceQuery: boolean,
  ) => void;
  initialValues: Array<AppliedFilterType>;
  filterSelectorDropdownLabel?: string;
  setAppliedFiltersCount?: Dispatch<SetStateAction<number>>;
}) {
  // There isn't a good way of passing arguments into Formik's `onSubmit`
  handler
  // This value stores the type of the filter which triggered the onSubmit
  handler
  const changeFilterType = useRef<LogicalForm__InputTypeEnum | null>(null);
  const filterSelectorDropdownRef = useRef(null);

  function handleRemoveFilter(filter: AppliedFilterType) {
    if (!filter.repeatable) {
      setAvailableFilters([
        ...availableFilters,
        omit(filter, ["id", "value", "applying"]),
      ]);
    }
  }

  function handleAddFilter(filter: FilterType) {
    if (!filter.repeatable) {
      setAvailableFilters(
        availableFilters.filter(
          (availableFilter) => availableFilter.name !== filter.name,
        ),
      );
    }
  }

  function handleOnClose(
    remove: (index: number) => void,
    replace: (index: number, data: AppliedFilterType) => void,
    values: {
      filters: Array<AppliedFilterType>;
    },
    filter: AppliedFilterType,
    index: number,
    timeout?: number,
  ) {
    // If the value is empty when the user closes the filter input dropdown,
    // remove the filter pill
    if (
      filter.value == null ||
      (filter.type === LogicalForm__InputTypeEnum.MetadataInput &&
        !completeMetadataValue(filter)) ||
      (filter.type === LogicalForm__InputTypeEnum.AmountInput &&
        !completeAmountValue(filter))
    ) {
      handleRemoveFilter(filter);
      if (timeout) {
        // The delay here allows the filter selector dropdown
        // to open before the pill is removed
        setTimeout(() => remove(index), timeout);
      } else {
        remove(index);
      }
    } else {
      replace(index, {
        ...values.filters[index],
        applying: false,
      });
    }
  }

  function handleClearFilters(
    filters: AppliedFilterType[],
    handleSubmit: () => void,
    resetForm: (nextState: object) => void,
  ): void {
    setAvailableFilters([...availableFilters, ...filters]);
    resetForm({ values: { filters: [] } });
    handleSubmit();
  }

  return (
    <Formik
      initialValues={{
        filters: initialValues,
      }}
      onSubmit={(values) => {
        onChange(values, shouldDebounceQuery(changeFilterType.current));
        changeFilterType.current = null;
      }}
    >
      {({ values, handleSubmit, resetForm }) => (
        <FieldArray name="filters">
          {({ push, replace, remove }) => (
            <>
              {values.filters.map((filter, index) => (
                <AppliedFilterDropdown
                  key={index}
                  appliedFilter={filter}
                  filterSelectorDropdownRef={filterSelectorDropdownRef}
                  handleClickAddFilter={() =>
                    handleOnClose(remove, replace, values, filter, index, 100)
                  }
                  onChange={(newFilter) => {
                    replace(index, newFilter);
                    changeFilterType.current = newFilter.type;
                    setTimeout(handleSubmit);
                  }}
                  onClose={() =>
                    handleOnClose(remove, replace, values, filter, index)
                  }
                >
                  {({ popoverOpen }) => (
                    <FilterPill
                      appliedFilter={filter}
                      removeFilter={(e: ButtonClickEventTypes) => {
                        if (!popoverOpen) {
                          // Prevents a popover from another pill from
                          automatically opening
                          e.stopPropagation();
                        }
                        remove(index);
                        handleRemoveFilter(filter);
                        setTimeout(handleSubmit);
                        setAppliedFiltersCount(values.filters.length - 1);
                      }}
                    />
                  )}
                </AppliedFilterDropdown>
              ))}
              <div className="flex">
                <FilterSelectorDropdown
                  ref={filterSelectorDropdownRef}
                  key="newFilter"
                  label={filterSelectorDropdownLabel}
                  availableFilters={availableFilters}
                  hideFilterText={values.filters.length > 0}
                  onFilterSelect={(filter) => {
                    push({
                      ...filter,
                      applying: true,
                    });
                    handleAddFilter(filter);
                    setAppliedFiltersCount(values.filters.length + 1);
                  }}
                />
                {values.filters.length > 0 && (
                  <ClearFiltersButton
                    onClick={() =>
                      handleClearFilters(
                        values.filters,
                        handleSubmit,
                        resetForm,
                      )
                    }
                  />
                )}
              </div>
            </>
          )}
        </FieldArray>
      )}
    </Formik>
  );
}

/**
 * Filters out values from the view document that are not part of the available
 filters.
 * This will occur if we remove a filter and the view documents in the database
 become stale.
 */
function parseViewDocumentFilters(
  viewDocumentFilters: Record<string, unknown>,
  filters: Array<FilterType | AppliedFilterType>,
) {
  return Object.keys(viewDocumentFilters).reduce((acc, filterId) => {
    if (filters.find(({ key }) => key === filterId)) {
      return {
        ...acc,
        [filterId]: viewDocumentFilters[filterId],
      };
    }
    return acc;
  }, {});
}

function FilterArea({
  filterName,
  filters,
  handleRefetch,
  filterIdsToRemove = [],
  legacyQueryToFilters,
  view,
  onChange,
  disableQueryURLParams,
  filterSelectorDropdownLabel,
  appliedFilters,
  setAppliedFiltersCount = () => {},
}: FilterAreaProps & {
  filters: FilterType[];
  onChange?: (data: object) => void;
  disableQueryURLParams?: boolean;
  filterSelectorDropdownLabel?: string;
  appliedFilters?: AppliedFilterType[];
  setAppliedFiltersCount?: Dispatch<SetStateAction<number>>;
}) {
  const { viewDocument, updateViewDocument } = useViewDocument(
    view,
    ViewDocumentTypeEnum.Filters,
  );
  const [getFilters, setFilters] = useQueryParams();
  // Handle cases where a user bookmarks a link with legacy style filters
  const legacyFormatFilters = legacyQueryToFilters
    ? omitBy(
        legacyQueryToFilters(parse(window.location.search)),
        (value) => isNil(value) || isEmpty(value),
      )
    : {};

  const filtersFromViewDocument = viewDocument
    ? parseViewDocumentFilters(
        JSON.parse(viewDocument.document) as Record<string, unknown>,
        filters,
      )
    : {};
  const filterFromURL = {
    ...legacyFormatFilters,
    ...getFilters(String(filterName)),
  };
  const appliedFilterKeys = appliedFilters?.map((a) => a.key) || [];
  const [availableFilters, setAvailableFilters] = useState<Array<FilterType>>(
    parseURLForInitialAvailableFilters(
      filters,
      filterFromURL,
      filtersFromViewDocument,
    )
      .filter((filter) => !filterIdsToRemove.includes(filter.key))
      .filter((filter) => !appliedFilterKeys.includes(filter.key)),
  );

  return (
    <FilterAreaFormikWrapper
      availableFilters={availableFilters}
      setAvailableFilters={setAvailableFilters}
      setAppliedFiltersCount={setAppliedFiltersCount}
      initialValues={
        appliedFilters ||
        parseURLForAppliedFilters(
          filters,
          filterFromURL,
          filtersFromViewDocument,
          setAppliedFiltersCount,
        )
      }
      filterSelectorDropdownLabel={filterSelectorDropdownLabel}
      // On change, convert the array of filters into a hash which can be
      consumed
      // by a graphql request
      onChange={(values, debounceQuery) => {
        // Combine metadata filter entries into a single hash
        const metadataFilters = values.filters
          .filter(
            (filter) =>
              filter.type === LogicalForm__InputTypeEnum.MetadataInput,
          )
          .reduce((acc, filter) => {
            invariant(
              typeof filter.value === "object" && !Array.isArray(filter.value),
            );
            const { key } = filter.value;
            invariant(typeof key === "string");
            return {
              ...acc,
              [key]: filter.value.value,
            };
          }, {});

        // Create a hash of hidden filters that are not part of the form state
        const hiddenFilters = Object.keys(filterFromURL).reduce((acc, key) => {
          if (filters.find((filter) => filter.key === key && !filter.hidden)) {
            return acc;
          }
          return {
            ...acc,
            [key]: filterFromURL[key],
          };
        }, {});

        // Create a combined filter hash with metadata, hidden filters and
        applied filters.
        const combinedFilters = values.filters
          .filter(
            (filter) =>
              filter.type !== LogicalForm__InputTypeEnum.MetadataInput,
          )
          .reduce(
            (acc, filter) => ({
              ...acc,
              [filter.key]: filter.value || undefined,
            }),
            {
              ...hiddenFilters,
              metadata: Object.keys(metadataFilters).length
                ? JSON.stringify(metadataFilters)
                : undefined,
            },
          );

        // Create an empty hash of all unused filters
        // This way the calling component can combine the change with an
        existing value.
        const emptyFilters = availableFilters
          .filter((filter) => !combinedFilters[filter.key])
          .reduce(
            (acc, filter) => ({
              ...acc,
              [filter.key]: undefined,
            }),
            {},
          );

        const updatedFiltersForTable = {
          ...combinedFilters,
          ...emptyFilters,
        };

        // Call handlers with fully combined hash
        if (!disableQueryURLParams) {
          setFilters(String(filterName), updatedFiltersForTable);
        }
        void updateViewDocument(JSON.stringify(updatedFiltersForTable));
        trackEvent(null, FILTER_AREA_EVENTS.FILTER_AREA_CHANGED, {
          ...updatedFiltersForTable,
        });
        if (handleRefetch)
          void handleRefetch(updatedFiltersForTable, debounceQuery);
        if (onChange) onChange(updatedFiltersForTable);
      }}
    />
  );
}

function FilterAreaContainer({
  leftContent,
  rightContent,
  fullWidth,
  constraintFilter,
}: {
  leftContent: React.ReactNode;
  rightContent: React.ReactNode;
  fullWidth?: boolean;
  constraintFilter?: boolean;
}) {
  return (
    <div
      className={cn(
        "flex flex-wrap items-start justify-between border-alpha-black-100 bg-
        background-default px-4 pt-3",
        fullWidth ? "border-l" : "rounded-t border-x border-t",
        constraintFilter && "rounded border",
      )}
    >
      <div className="flex flex-1 flex-wrap items-center gap-3 pb-3">
        {leftContent}
      </div>
      <div className="flex gap-2 pb-3">{rightContent}</div>
    </div>
  );
}

/**
 * Wrapper to render the content even when we don't have filter records.
 */
function FilterAreaLoadingWrapper({
  filtersLoading,
  columnSelectorDropdownProps,
  exportDataButtonProps,
  filterName,
  filtersToLegacyFormat,
  view,
  customizableColumns,
  enableExportData,
  fullWidth,
  constraintFilter,
  onChange,
  disableQueryURLParams,
  filterSelectorDropdownLabel,
  appliedFilters,
  ...filterAreaProps
}: FilterAreaProps & {
  columnSelectorDropdownProps?: ColumnSelectorDropdownProps;
  exportDataButtonProps?: ExportDataButtonProps;
  filtersLoading?: boolean;
  filters: FilterType[] | undefined;
  filtersToLegacyFormat?: (
    query: Record<string, unknown>,
  ) => Record<string, unknown>;
  customizableColumns?: boolean;
  enableExportData?: boolean;
  fullWidth?: boolean;
  constraintFilter?: boolean;
  onChange?: (data: object) => void;
  disableQueryURLParams?: boolean;
  filterSelectorDropdownLabel?: string;
  appliedFilters?: AppliedFilterType[];
  setAppliedFiltersCount?: Dispatch<SetStateAction<number>>;
}) {
  return (
    <FilterAreaContainer
      leftContent={
        !filtersLoading && filterAreaProps.filters ? (
          <FilterArea
            {...filterAreaProps}
            filters={filterAreaProps.filters}
            filterName={filterName}
            view={view}
            onChange={onChange}
            disableQueryURLParams={disableQueryURLParams}
            filterSelectorDropdownLabel={filterSelectorDropdownLabel}
            appliedFilters={appliedFilters}
            setAppliedFiltersCount={filterAreaProps.setAppliedFiltersCount}
          />
        ) : (
          <Popover>
            <PopoverTrigger disabled />
          </Popover>
        )
      }
      rightContent={
        <>
          {customizableColumns && columnSelectorDropdownProps && (
            <ColumnSelectorDropdown
              {...columnSelectorDropdownProps}
              inFilters
            />
          )}
          {enableExportData && exportDataButtonProps && (
            <ExportDataButton
              {...exportDataButtonProps}
              buttonHeight="extra-small"
              filterName={filterName}
              filtersToLegacyFormat={filtersToLegacyFormat}
            />
          )}
        </>
      }
      fullWidth={Boolean(fullWidth)}
      constraintFilter={Boolean(constraintFilter)}
    />
  );
}

export default FilterAreaLoadingWrapper;
```

---
## `filter/FilterInputRenderer.tsx.txt`
**Path:** `filter`  
```
import React, { RefObject, useRef, useState, useEffect } from "react";
import { useParams, useLocation } from "react-router";
import { LazyQueryExecFunction, OperationVariables } from "@apollo/client";
import { Field, Form, Formik, FormikProps } from "formik";
import { camelCase, isEqual, omit, startCase } from "lodash";
import invariant from "ts-invariant";
import { cn } from "~/common/utilities/cn";
import {
  CONNECTION,
  COUNTERPARTY,
  INVOICE,
  RECONCILIATION_RULE,
  RESOURCES,
  ResourcesEnum,
} from "~/generated/dashboard/types/resources";
import { useMountEffect } from "~/common/utilities/useMountEffect";
import MultiSelectDropdownPanel from "~/common/ui-
components/MultiSelectDropdown/MultiSelectDropdownPanel";
import { useToggle } from "~/common/utilities/useToggle";
import { FormikInputField } from "../../../common/formik";
import { AppliedFilterType, FilterType } from "./util";
import FormikAmountSearch from "./FormikAmountSearch";
import {
  Button,
  Input,
  Label,
  LoadingLine,
  Stack,
  ToggleRow,
} from "../../../common/ui-components";
import {
  LogicalForm__InputTypeEnum,
  TimeFormatEnum,
  useConnectionAsyncSelectLazyQuery,
  useCounterpartySelectFilterLazyQuery,
  useInvoicesFilterViewLazyQuery,
  useReconciliationRuleAsyncSelectLazyQuery,
} from "../../../generated/dashboard/graphqlSchema";
import DateRangePicker, {
  DateRangeValues,
} from "../../../common/ui-components/DateRangePicker/DateRangePicker";
import { ACCOUNT_DATE_RANGE_FILTER_OPTIONS } from
"../../containers/reconciliation/utils";
import MultiAccountSelect from "./MultiAccountSelect";

const INITIAL_PAGINATION = {
  total: 0,
  page: 1,
  perPage: 25,
};

function AmountSearchInputFilter({
  filter,
  formikRef,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
}) {
  const filterValue = (filter as AppliedFilterType).value as
    | {
        gte: number | null;
        lte: number | null;
      }
    | undefined;

  const [usingRange, toggleUsingRange] = useToggle(
    filterValue && filterValue?.gte !== filterValue?.lte,
  );

  function handleToggleUsingRange() {
    toggleUsingRange();
    if (formikRef.current) {
      void formikRef.current.setFieldValue(`${filter.key}.lte`, null);
      void formikRef.current.setFieldValue(`${filter.key}.gte`, null);
    }
  }

  return (
    <div className="grid gap-2 p-2">
      {usingRange ? (
        <>
          <Field
            id={filter.key}
            name={`${filter.key}.gte`}
            placeholder="0.00"
            component={FormikAmountSearch}
            onChange={() => {
              if (formikRef.current) {
                setTimeout(formikRef.current.handleSubmit);
              }
            }}
          />
          <Field
            id={filter.key}
            name={`${filter.key}.lte`}
            placeholder="0.00"
            component={FormikAmountSearch}
            onChange={() => {
              if (formikRef.current) {
                setTimeout(formikRef.current.handleSubmit);
              }
            }}
          />
        </>
      ) : (
        <Field
          id={filter.key}
          name={`${filter.key}.gte`}
          placeholder="0.00"
          component={FormikAmountSearch}
          onChange={(_, newValue: number | null) => {
            if (formikRef.current) {
              void formikRef.current.setFieldValue(
                `${filter.key}.lte`,
                newValue,
              );
              setTimeout(formikRef.current.handleSubmit);
            }
          }}
        />
      )}
      <div className="flex w-full">
        <ToggleRow
          toggleTextSize="text-xs"
          radios={[
            {
              selected: !usingRange,
              children: "Exact",
              value: "Exact",
              onChange: handleToggleUsingRange,
            },
            {
              selected: usingRange,
              children: "Range",
              value: "Range",
              onChange: handleToggleUsingRange,
            },
          ]}
          fullWidth
        />
      </div>
    </div>
  );
}

export function ChoiceSearchInputFilter({
  filter,
  formikRef,
  moreOptions,
  onLoadMore,
  onSearchChange,
  options = [],
  className,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
  moreOptions?: boolean;
  onLoadMore?: (searchValue: string) => void;
  onSearchChange?: (value: string) => void;
  options?: { label: string; value: string }[];
  className?: string;
}) {
  const initialValue = (filter as AppliedFilterType)?.value || "";
  const inputRef = useRef<HTMLInputElement>(null);
  const [searchValue, setSearchValue] = useState("");

  useMountEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  });

  const handleSubmit = () => {
    if (formikRef.current) {
      formikRef.current.handleSubmit();
    }
  };

  const filteredOptions = searchValue
    ? options.filter((option) =>
        option.label
          .toLocaleLowerCase()
          .includes(searchValue.toLocaleLowerCase()),
      )
    : options;

  return (
    <div className={cn("flex max-h-80 flex-col overflow-y-scroll", className)}>
      <div className="sticky top-0 border-b border-alpha-black-100">
        <Input
          placeholder={filter.name}
          value={searchValue}
          onChange={(e) => {
            setSearchValue(e.target.value);
            if (onSearchChange) {
              onSearchChange(e.target.value);
            }
          }}
          outline={false}
          name="searchFilter"
          className="pl-4 text-xs"
          ref={inputRef}
        />
      </div>
      <div className="p-2">
        {filteredOptions.map((option) => (
          <Label
            key={option.value}
            className={cn(
              "flex w-full cursor-pointer rounded-sm p-2 text-xs hover:bg-
              gray-25",
              initialValue === option.value &&
                "bg-blue-500 text-white hover:!bg-blue-500 hover:text-white",
            )}
          >
            <Field
              id={filter?.key}
              name={filter?.key}
              type="radio"
              value={option}
              className="peer hidden"
              onChange={() => {
                void formikRef?.current?.setFieldValue(
                  filter.key,
                  option.value,
                );
                handleSubmit();
              }}
            />
            {option.label}
          </Label>
        ))}
      </div>
      {filteredOptions.length === 0 && (
        <div className="bg-white px-4">
          <p className="font-regular p-4 text-center text-xs text-gray-700">
            No Results Found.
          </p>
        </div>
      )}
      {moreOptions && onLoadMore && (
        <div className="px-3 pb-4">
          <Button
            className="text-xs font-medium"
            buttonType="link"
            onClick={() => onLoadMore(searchValue)}
            hideFocusOutline
            fullWidth
          >
            Load More
          </Button>
        </div>
      )}
    </div>
  );
}

type LazyQueryFunctionType = () => [
  getEntities: LazyQueryExecFunction<ResponseType, OperationVariables>,
];

type ResponseType = { [key: string]: GetEntitiesQueryResponse };

type GetEntitiesQueryResponse = {
  edges: Array<{
    node: {
      id: string;
      name: string | null;
      longName?: string | null;
    };
  }>;
  pageInfo: {
    endCursor: string | null;
    hasNextPage: boolean;
  };
};

interface AsyncSearchFilterProps extends UIContainerProps {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
  query: unknown;
  resource: ResourcesEnum;
  entityLabelFieldName?: string;
  additionalVariables?: object;
}

function AsyncSearchFilter({
  filter,
  className,
  formikRef,
  query,
  resource,
  additionalVariables,
  entityLabelFieldName,
}: AsyncSearchFilterProps) {
  const [options, setOptions] = useState<{ label: string; value: string }[]>(
    [],
  );
  const [afterCursor, setAfterCursor] = useState<string>("");
  const [hasNextPage, setHasNextPage] = useState<boolean>(false);
  const [getEntities] = (query as LazyQueryFunctionType)();

  useEffect(() => {
    const loadInitialEntities = async () => {
      const response = await getEntities({
        variables: {
          first: INITIAL_PAGINATION.perPage,
          ...additionalVariables,
        },
      });

      const entityName = RESOURCES[resource].graphql_fields?.async_search;
      const entities = response?.data?.[entityName];

      const fieldName = entityLabelFieldName || "name";
      const formattedOptions = entities?.edges.map(({ node }) => ({
        label: (node[fieldName] as string) || "",
        value: node.id,
      }));

      setOptions(formattedOptions || []);
      setAfterCursor(entities?.pageInfo?.endCursor || "");
      setHasNextPage(entities?.pageInfo?.hasNextPage || false);
    };

    void loadInitialEntities();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleRefetch = async (name: string, loadMore = false) => {
    const updatedName = name !== "" ? name : undefined;
    const after = loadMore ? afterCursor : undefined;
    const initialVariables = {};
    initialVariables[entityLabelFieldName || name] = updatedName;

    const response = await getEntities({
      variables: {
        first: INITIAL_PAGINATION.perPage,
        after,
        ...initialVariables,
        ...additionalVariables,
      },
    });

    const entityName = RESOURCES[resource].graphql_fields?.async_search;
    const entities = response?.data?.[entityName];

    const fieldName = entityLabelFieldName || "name";
    const formattedOptions = entities?.edges.map(({ node }) => ({
      label: (node[fieldName] as string) || "",
      value: node.id,
    }));

    if (formattedOptions) {
      const updatedOptions = loadMore
        ? [...options, ...formattedOptions]
        : [...formattedOptions];
      setOptions(updatedOptions);
      setAfterCursor(entities?.pageInfo?.endCursor || "");
      setHasNextPage(entities?.pageInfo?.hasNextPage || false);
    }
  };

  const handleChange = (searchValue: string) => {
    void handleRefetch(searchValue);
  };

  const handleLoadMore = async (searchValue: string) => {
    await handleRefetch(searchValue, true);
  };

  return (
    <div className={cn("flex w-full max-w-60 flex-col", className)}>
      <ChoiceSearchInputFilter
        filter={filter}
        options={options}
        formikRef={formikRef}
        moreOptions={hasNextPage}
        className="border-0 border-b border-alpha-black-100"
        onSearchChange={handleChange}
        onLoadMore={(searchValue) => {
          void handleLoadMore(searchValue);
        }}
      />
    </div>
  );
}

function DateInputFilter({
  filter,
  formikRef,
  options = [],
  className,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
  options?: { label: string; value: string }[];
  className?: string;
}) {
  const appliedFilterValue = "value" in filter ? filter?.value : "";
  const initialValue = ACCOUNT_DATE_RANGE_FILTER_OPTIONS.find(
    (dateFilterOption) =>
      isEqual(dateFilterOption?.dateRange, appliedFilterValue),
  );
  const formatSelectedValue =
    initialValue?.value === "today" ? "past24H" : initialValue?.value;

  const handleSubmit = () => {
    if (formikRef.current) {
      formikRef.current.handleSubmit();
    }
  };

  const onApply = (dateRange: DateRangeValues) => {
    let value = {
      ...dateRange,
      inTheLast: null,
      format: TimeFormatEnum.Date,
    };
    if (dateRange.lte === "") {
      value = omit(value, "lte");
    }
    if (dateRange.gte === "") {
      value = omit(value, "gte");
    }
    void formikRef?.current?.setFieldValue(filter?.key, value);
    handleSubmit();
  };

  return (
    <>
      {options?.map((option) => (
        <Label
          key={option.label}
          className={cn(
            "flex w-full cursor-pointer rounded-sm p-2 text-xs hover:bg-
            gray-25",
            formatSelectedValue === camelCase(option.value) && "bg-gray-25",
            className,
          )}
        >
          <Field
            id={filter?.key}
            name={filter?.key}
            type="radio"
            value={option.value}
            className="peer hidden"
            onChange={() => {
              const value = ACCOUNT_DATE_RANGE_FILTER_OPTIONS.find(
                (dateFilterOption) => {
                  const dateFilterValue =
                    dateFilterOption.value === "today"
                      ? "past24H"
                      : dateFilterOption.value;
                  return dateFilterValue === camelCase(option.value);
                },
              );
              void formikRef?.current?.setFieldValue(
                filter.key,
                value?.dateRange,
              );
              handleSubmit();
            }}
          />
          {startCase(option.label)}
        </Label>
      ))}
      <DateRangePicker
        className="px-2 pt-2"
        onApply={onApply}
        initialValues={appliedFilterValue as unknown as DateRangeValues}
        allowExactValues
      />
    </>
  );
}

function MetadataInputFilter({
  filter,
  formikRef,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
}) {
  // Handle submit in a separate function in order to read the correct
  // value in the setTimeout function. Since event is mutated, we will read the
  // incorrect value if we read from event.target.value directly.
  function handleSubmit(newValue: string) {
    setTimeout(() => {
      if (
        newValue &&
        formikRef.current &&
        (formikRef.current.values[filter.key] as { value: string }).value
      ) {
        formikRef.current.handleSubmit();
      }
    });
  }

  function handleChange(
    filterKey: string,
    event: React.ChangeEvent<HTMLInputElement>,
  ) {
    void formikRef?.current?.setFieldValue(filterKey, event.target.value);

    handleSubmit(event.target.value);
  }

  return (
    <div className="p-4">
      <Stack className="gap-2">
        <Field
          id={filter.key}
          name={`${filter.key}.key`}
          placeholder="Key"
          component={FormikInputField}
          className="h-6 text-xs"
          onChange={(event: React.ChangeEvent<HTMLInputElement>) =>
            handleChange(`${filter.key}.key`, event)
          }
        />
        <Field
          id={filter.key}
          className="h-6 text-xs"
          name={`${filter.key}.value`}
          placeholder="Value"
          component={FormikInputField}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) =>
            handleChange(`${filter.key}.value`, event)
          }
        />
      </Stack>
      <button aria-label="submit button" className="sr-only" type="submit" />
    </div>
  );
}

function SearchInputFilter({
  filter,
  formikRef,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
}) {
  return (
    <div className="p-4">
      <Field
        id={filter.key}
        name={filter.key}
        placeholder=""
        component={FormikInputField}
        className="h-6 text-xs"
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          void formikRef?.current?.setFieldValue(
            filter.key,
            event.target.value || null,
          );
          if (formikRef.current) {
            setTimeout(formikRef.current.handleSubmit);
          }
        }}
      />
    </div>
  );
}

function MultiSelectFilter({
  onClose,
  filter,
  options,
  formikRef,
  initialValue,
}: {
  filter: FilterType | AppliedFilterType;
  formikRef: RefObject<FormikProps<FormValues>>;
  options: { label: string; value: string }[];
  initialValue: Array<string>;
  onClose: () => void;
}) {
  const [searchValue, setSearchValue] = useState("");

  return (
    <MultiSelectDropdownPanel
      onClose={onClose}
      categories={[
        {
          id: filter.key,
          items: options.map((o) => ({ id: o.value, label: o.label })),
          label: filter.name,
        },
      ]}
      onChange={(selectedValues) => {
        const selectedValueArray = Object.keys(selectedValues).reduce<
          Array<string>
        >((acc, key) => [...acc, ...selectedValues[key]], []);
        if (formikRef?.current) {
          void formikRef?.current?.setFieldValue(
            filter.key,
            selectedValueArray,
          );
          setTimeout(() => formikRef?.current?.handleSubmit());
        }
      }}
      initialValues={{
        [filter.key]: initialValue || [],
      }}
      onSearchValueChange={setSearchValue}
      searchValue={searchValue}
      className="border border-alpha-black-100"
    />
  );
}

export type FormValues = {
  [key: string]: AppliedFilterType["value"];
};

interface FilterInputTypeRendererProps {
  appliedFilter: AppliedFilterType;
  onChange: (filter: AppliedFilterType) => void;
  onClose: () => void;
}

function FilterInputTypeRenderer({
  appliedFilter: filter,
  onChange,
  onClose,
}: FilterInputTypeRendererProps) {
  const formikRef = useRef<FormikProps<FormValues>>(null);
  const initialValue = filter?.value ?? "";

  const fieldType = filter.type;
  const options = filter?.options?.map((enumValue) => ({
    label: enumValue?.prettyValueName,
    value: enumValue?.valueName,
  }));

  const { preview_id: previewId }: { preview_id: string } = useParams();
  const location = useLocation();

  let inputRenderer: React.ReactNode;
  switch (fieldType) {
    case LogicalForm__InputTypeEnum.AmountInput:
      inputRenderer = (
        <AmountSearchInputFilter filter={filter} formikRef={formikRef} />
      );
      break;
    case LogicalForm__InputTypeEnum.CounterpartySelect:
      inputRenderer = (
        <AsyncSearchFilter
          filter={filter}
          formikRef={formikRef}
          query={useCounterpartySelectFilterLazyQuery}
          resource={COUNTERPARTY}
          entityLabelFieldName="name"
        />
      );
      break;
    case LogicalForm__InputTypeEnum.InvoiceSelect:
      inputRenderer = (
        <AsyncSearchFilter
          filter={filter}
          formikRef={formikRef}
          query={useInvoicesFilterViewLazyQuery}
          resource={INVOICE}
          entityLabelFieldName="number"
        />
      );
      break;
    case LogicalForm__InputTypeEnum.ReconciliationRuleSelect:
      inputRenderer = (
        <AsyncSearchFilter
          filter={filter}
          formikRef={formikRef}
          query={useReconciliationRuleAsyncSelectLazyQuery}
          resource={RECONCILIATION_RULE}
          entityLabelFieldName="name"
        />
      );
      break;
    case LogicalForm__InputTypeEnum.PreviewReconciliationRuleSelect: {
      const queryParams = new URLSearchParams(location.search);
      const editingSessionId = queryParams.get("editingSessionId") as string;

      inputRenderer = (
        <AsyncSearchFilter
          filter={filter}
          formikRef={formikRef}
          query={useReconciliationRuleAsyncSelectLazyQuery}
          resource={RECONCILIATION_RULE}
          additionalVariables={{ previewId, editingSessionId }}
          entityLabelFieldName="name"
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.ConnectionSelect:
      inputRenderer = (
        <AsyncSearchFilter
          filter={filter}
          formikRef={formikRef}
          query={useConnectionAsyncSelectLazyQuery}
          resource={CONNECTION}
          entityLabelFieldName="name"
        />
      );
      break;
    case LogicalForm__InputTypeEnum.MultiSelect:
      invariant(options);
      inputRenderer = (
        <MultiSelectFilter
          filter={filter}
          formikRef={formikRef}
          options={options}
          onClose={onClose}
          initialValue={initialValue as Array<string>}
        />
      );
      break;
    case LogicalForm__InputTypeEnum.SingleSelect:
      inputRenderer = (
        <ChoiceSearchInputFilter
          filter={filter}
          formikRef={formikRef}
          options={options}
        />
      );
      break;
    case LogicalForm__InputTypeEnum.MultiAccountSelect:
      inputRenderer = (
        <MultiAccountSelect
          field={filter.key}
          label="Internal Accounts"
          initialValues={initialValue}
          onChange={(value) => {
            if (formikRef?.current) {
              void formikRef?.current?.setFieldValue(filter.key, value);
              setTimeout(() => formikRef?.current?.handleSubmit());
            }
          }}
          onClose={onClose}
        />
      );
      break;
    case LogicalForm__InputTypeEnum.DateInput:
      inputRenderer = (
        <div className="p-2">
          <DateInputFilter
            filter={filter}
            formikRef={formikRef}
            options={options}
          />
        </div>
      );
      break;
    case LogicalForm__InputTypeEnum.MetadataInput:
      inputRenderer = (
        <MetadataInputFilter filter={filter} formikRef={formikRef} />
      );
      break;
    case LogicalForm__InputTypeEnum.TextInput:
      inputRenderer = (
        <SearchInputFilter filter={filter} formikRef={formikRef} />
      );
      break;
    default:
      inputRenderer = (
        <div className="mb-4">
          <LoadingLine />
        </div>
      );
  }

  const hideTitle = [
    LogicalForm__InputTypeEnum.CounterpartySelect,
    LogicalForm__InputTypeEnum.SingleSelect,
    LogicalForm__InputTypeEnum.InternalAccountSelect,
    LogicalForm__InputTypeEnum.InvoiceSelect,
    LogicalForm__InputTypeEnum.MultiAccountSelect,
    LogicalForm__InputTypeEnum.ReconciliationRuleSelect,
    LogicalForm__InputTypeEnum.PreviewReconciliationRuleSelect,
    LogicalForm__InputTypeEnum.ConnectionSelect,
    LogicalForm__InputTypeEnum.MultiSelect,
  ].includes(fieldType);

  return (
    <div className="flex h-full w-full max-w-60 flex-col rounded-sm">
      {!hideTitle && (
        <div className="flex w-full items-center border-b border-alpha-black-100
        px-4 py-2 text-xs text-gray-500">
          <span>{startCase(filter.name)}</span>
        </div>
      )}
      <Formik
        initialValues={{
          [filter.key]: initialValue,
        }}
        onSubmit={(values: FormValues) => {
          onChange({ ...filter, value: values[filter.key] });
        }}
        innerRef={formikRef}
        enableReinitialize
      >
        <Form>{inputRenderer}</Form>
      </Formik>
    </div>
  );
}

export default FilterInputTypeRenderer;
```

---
## `filter/FilterPill.tsx.txt`
**Path:** `filter`  
```
import React from "react";
import { get, isEqual } from "lodash";
import pluralize from "pluralize";
import invariant from "ts-invariant";
import { ALL_ACCOUNTS_ID } from "~/app/constants";
import { AppliedFilterType, FilterType } from "./util";
import {
  ButtonClickEventTypes,
  Chip,
  DateRangeFormValues,
  Icon,
  LoadingLine,
  icons,
} from "../../../common/ui-components";
import {
  LogicalForm__InputTypeEnum,
  useFilterPillCounterpartyTextQuery,
  useFilterPillInternalAccountsTextQuery,
  useFilterPillReconciliationRuleTextQuery,
  useFilterPillConnectionTextQuery,
} from "../../../generated/dashboard/graphqlSchema";
import { DATE_SEARCH_FILTER_OPTIONS } from "../search/DateSearch";

function formatText(text: string) {
  const maxLength = 12;
  if (text.length <= maxLength) {
    return text;
  }
  const charsFromBeginning = Math.floor((maxLength - 3) / 2);
  const charsFromEnd = Math.ceil((maxLength - 3) / 2);
  return `${text.substring(0, charsFromBeginning)}...${text.substr(
    -charsFromEnd,
  )}`;
}

type QueryFunctionType = (args: Record<string, unknown>) => {
  data: unknown;
  loading: boolean;
};

function AsyncText({
  query,
  resource,
  field,
  id,
}: {
  query: QueryFunctionType;
  resource: string;
  field: string;
  id: string;
}) {
  const { data, loading } = query({
    variables: {
      id,
    },
  });

  if (data) {
    return <span>{get(data, [resource, field])}</span>;
  }
  if (loading) {
    return (
      <div className="w-20">
        <LoadingLine className="!h-3" />
      </div>
    );
  }
  return <span>{id}</span>;
}

function InternalAccountName({
  internalAccountIds,
}: {
  internalAccountIds: Array<string>;
}) {
  const { data } = useFilterPillInternalAccountsTextQuery({
    skip: internalAccountIds.length === 0,
    variables: {
      id: internalAccountIds[0],
    },
  });

  if (
    internalAccountIds.length === 1 &&
    internalAccountIds[0] === ALL_ACCOUNTS_ID
  ) {
    return <span>All Accounts</span>;
  }
  if (internalAccountIds.length > 1) {
    return (
      <span>
        {`${data?.internalAccount?.bestLongName || ""} + ${
          internalAccountIds.length - 1
        } ${pluralize("Account", internalAccountIds.length - 1)}`}
      </span>
    );
  }
  if (data) {
    return <span>{data?.internalAccount?.bestLongName}</span>;
  }
  return (
    <div className="w-20">
      <LoadingLine className="!h-3" />
    </div>
  );
}

function MultiSelectText({
  selectedValues,
  filter,
  options,
}: {
  selectedValues: Array<string>;
  filter: FilterType | AppliedFilterType;
  options: Array<Record<string, string>>;
}) {
  const firstSelected =
    options.find((o) => selectedValues.includes(o.valueName))
      ?.prettyValueName || "";
  if (selectedValues.length === 0) {
    return <span>{`All ${pluralize(filter.name, 2)}`}</span>;
  }
  if (selectedValues.length > 1) {
    return (
      <span>
        {`${firstSelected} + ${selectedValues.length - 1} ${pluralize(
          filter.name,
          selectedValues.length - 1,
        )}`}
      </span>
    );
  }
  return <span>{firstSelected}</span>;
}

function DateText({ value }: { value: DateRangeFormValues }) {
  const inTheLast = value?.inTheLast;
  const inTheNext = value?.inTheNext;

  let label = "";
  if (inTheLast) {
    label =
      DATE_SEARCH_FILTER_OPTIONS.find((dateSearchFilterOption) =>
        isEqual(dateSearchFilterOption.dateRange.inTheLast, inTheLast),
      )?.label || "";
  }

  if (inTheNext) {
    label =
      DATE_SEARCH_FILTER_OPTIONS.find((dateSearchFilterOption) =>
        isEqual(dateSearchFilterOption.dateRange.inTheNext, inTheNext),
      )?.label || "";
  }

  const lte = value?.lte as unknown as string;
  const gte = value?.gte as unknown as string;

  if (lte && gte && lte === gte) {
    return <span>{lte}</span>;
  }
  if (gte && !lte) {
    return (
      <span>
        {"> "}
        {gte}
      </span>
    );
  }
  if (lte && !gte) {
    return (
      <span>
        {"< "}
        {lte}
      </span>
    );
  }
  if (lte && gte) {
    return (
      <span>
        {gte} - {lte}
      </span>
    );
  }
  if (label) {
    return <span>{label}</span>;
  }
  return <span>Past 24h</span>;
}

function AmountText({
  value,
}: {
  value: {
    gte: number | null;
    lte: number | null;
  };
}) {
  const lte = (value?.lte as unknown as number) / 100;
  const gte = (value?.gte as unknown as number) / 100;

  if (lte === gte) {
    return (
      <span>
        {Intl.NumberFormat("en-US", {
          style: "decimal",
          minimumFractionDigits: 2,
        }).format(lte)}
      </span>
    );
  }
  if (gte && !lte) {
    return (
      <span>
        {"> "}
        {Intl.NumberFormat("en-US", {
          style: "decimal",
          minimumFractionDigits: 2,
        }).format(gte)}
      </span>
    );
  }
  if (lte && !gte) {
    return (
      <span>
        {"< "}
        {Intl.NumberFormat("en-US", {
          style: "decimal",
          minimumFractionDigits: 2,
        }).format(lte)}
      </span>
    );
  }
  return (
    <span>
      {Intl.NumberFormat("en-US", {
        style: "decimal",
        minimumFractionDigits: 2,
      }).format(gte)}{" "}
      -{" "}
      {Intl.NumberFormat("en-US", {
        style: "decimal",
        minimumFractionDigits: 2,
      }).format(lte)}
    </span>
  );
}

function formatAppliedFilterValue(appliedFilter: AppliedFilterType) {
  let content: React.ReactNode;

  switch (appliedFilter.type) {
    case LogicalForm__InputTypeEnum.AmountInput: {
      content = (
        <AmountText
          value={
            appliedFilter.value as {
              gte: number | null;
              lte: number | null;
            }
          }
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.CounterpartySelect: {
      content = (
        <AsyncText
          query={useFilterPillCounterpartyTextQuery}
          resource="counterparty"
          field="name"
          id={appliedFilter.value as string}
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.InvoiceSelect: {
      content = <span>{formatText(appliedFilter.value as string)}</span>;
      break;
    }
    case LogicalForm__InputTypeEnum.ConnectionSelect: {
      content = (
        <AsyncText
          query={useFilterPillConnectionTextQuery}
          resource="connection"
          field="name"
          id={appliedFilter.value as string}
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.PreviewReconciliationRuleSelect:
    case LogicalForm__InputTypeEnum.ReconciliationRuleSelect: {
      content = (
        <AsyncText
          query={useFilterPillReconciliationRuleTextQuery}
          resource="reconciliationRule"
          field="name"
          id={appliedFilter.value as string}
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.SingleSelect: {
      const option = (appliedFilter.options || []).find(
        (selectOption) => selectOption.valueName === appliedFilter.value,
      );
      content = option ? (
        <span>{formatText(option.prettyValueName)}</span>
      ) : null;
      break;
    }
    case LogicalForm__InputTypeEnum.MultiAccountSelect: {
      content = (
        <InternalAccountName
          internalAccountIds={appliedFilter.value as [string]}
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.MultiSelect: {
      invariant(appliedFilter.options);
      content = (
        <MultiSelectText
          options={appliedFilter.options}
          filter={appliedFilter}
          selectedValues={appliedFilter.value as [string]}
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.DateInput: {
      content = (
        <DateText
          value={
            appliedFilter.value as {
              gte: string | undefined;
              lte: string | undefined;
            }
          }
        />
      );
      break;
    }
    case LogicalForm__InputTypeEnum.MetadataInput: {
      const metadataValue = appliedFilter.value as {
        key: string;
        value: string;
      };

      content =
        metadataValue?.key && metadataValue?.value ? (
          <span className="flex flex-row space-x-1">
            <p>{formatText(metadataValue?.key)}</p>
            <Icon
              iconName="arrow_forward"
              color="currentColor"
              className="text-gray-700"
              size="s"
            />
            <p>{formatText(metadataValue?.value)}</p>
          </span>
        ) : (
          "Metadata"
        );
      break;
    }
    default:
      content = (
        <span>{`"${formatText(appliedFilter.value.toString())}"`}</span>
      );
      break;
  }

  return content;
}

interface FilterPillProps {
  appliedFilter: AppliedFilterType;
  removeFilter?: (e: ButtonClickEventTypes) => void;
}

/**
 * Creates a pill representing an applied filter and allows user to remove
 filter.
 */
function FilterPill({ appliedFilter, removeFilter }: FilterPillProps) {
  return (
    <Chip
      className="relative items-center"
      contentClassName="rounded-l-sm"
      icon={{
        iconName: appliedFilter.icon as keyof typeof icons,
        color: "currentColor",
        size: "s",
      }}
      onRemove={removeFilter}
    >
      {appliedFilter.value == null
        ? appliedFilter.name
        : formatAppliedFilterValue(appliedFilter)}
    </Chip>
  );
}

export default FilterPill;
```

---
## `filter/FilterSelector.tsx.txt`
**Path:** `filter`  
```
import { startCase } from "lodash";
import React, { useMemo, useRef, useState } from "react";
import { useMountEffect } from "~/common/utilities/useMountEffect";
import { ActionItem, Icon, icons, Input } from "../../../common/ui-components";
import { FilterType } from "./util";

interface FilterSelectorProps {
  availableFilters: FilterType[];
  onFilterSelect: (selectedFilter: FilterType) => void;
}

/**
 * Renders the filter selecting state within `FilterSelectorDropdown`.
 */
function FilterSelector({
  availableFilters,
  onFilterSelect,
}: FilterSelectorProps) {
  const [searchForFilterValue, setSearchForFilterValue] = useState<string>("");
  const inputRef = useRef<HTMLInputElement>(null);

  useMountEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  });

  const listOfFilters = useMemo(() => {
    const sortedFilters = availableFilters.sort(
      (availableFilterA, availableFilterB) =>
        availableFilterA.rank - availableFilterB.rank,
    );

    const filtersMatchingSearch = sortedFilters.filter((sortedFilter) =>
      sortedFilter.name
        .toLowerCase()
        .includes(searchForFilterValue.toLowerCase()),
    );

    return filtersMatchingSearch.map((filterMatchingSearch) => (
      <ActionItem
        key={filterMatchingSearch.key}
        className="flex rounded-sm hover:bg-gray-25"
        hideFocusOutline
        onClick={() => {
          onFilterSelect(filterMatchingSearch);
        }}
      >
        <div className="flex items-center gap-2">
          <Icon
            size="s"
            iconName={filterMatchingSearch.icon as keyof typeof icons}
            className="text-gray-700"
            color="currentColor"
          />
          <span className="text-xs font-normal text-gray-700">
            {startCase(filterMatchingSearch.name)}
          </span>
        </div>
      </ActionItem>
    ));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [availableFilters, searchForFilterValue]);

  return (
    <div className="flex h-full w-full flex-col rounded-sm bg-white">
      <Input
        placeholder="Search..."
        value={searchForFilterValue}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
          setSearchForFilterValue(e.target.value);
        }}
        outline={false}
        name="filterSearch"
        className="px-4 text-xs"
        ref={inputRef}
      />
      <div className="rounded-b-sm border-t border-alpha-black-100 bg-white
      p-2">
        {listOfFilters.length ? (
          listOfFilters
        ) : (
          <p className="font-regular text-center text-xs text-gray-700">
            No Results Found.
          </p>
        )}
      </div>
    </div>
  );
}

export default FilterSelector;
```

---
## `filter/FilterSelectorDropdown.tsx.txt`
**Path:** `filter`  
```
import React, { forwardRef } from "react";
import { Popover as HeadlessPopover, Transition } from "@headlessui/react";
import { cn } from "~/common/utilities/cn";
import { FilterType } from "./util";
import { Icon, Popover, PopoverPanel } from "../../../common/ui-components";
import FilterSelector from "./FilterSelector";

interface FilterSelectorDropdownProps {
  availableFilters: Array<FilterType>;
  hideFilterText: boolean;
  onFilterSelect: (filter: FilterType) => void;
  label?: string;
}

interface PopoverTriggerProps {
  hideFilterText?: boolean;
  disabled?: boolean;
  label?: string;
}

export const PopoverTrigger = forwardRef(
  (
    { hideFilterText = false, disabled = false, label }: PopoverTriggerProps,
    ref: React.ForwardedRef<HTMLButtonElement>,
  ) => (
    <HeadlessPopover.Button
      id="filterButton"
      ref={ref}
      disabled={disabled}
      className={cn(
        "bg-white px-2 py-1",
        "grid-flow-col items-center justify-center gap-1 whitespace-nowrap ",
        "grid rounded-sm outline-none focus:outline-none " +
          "border bg-button-background-default " +
          "hover:border-gray-200 hover:bg-gray-25 active:border-gray-300
          active:bg-gray-50 " +
          "focus:border-blue-500 focus:border-transparent focus:outline-none
          focus:ring-2 disabled:bg-gray-50 disabled:opacity-50 " +
          "font-medium disabled:cursor-not-allowed",
      )}
    >
      {label && <span className="text-xs text-gray-700">{label}</span>}
      <Icon
        iconName="filter_list"
        size="s"
        color="currentColor"
        className="text-gray-700"
      />
      {!hideFilterText && <span className="sr-only">Filter</span>}
    </HeadlessPopover.Button>
  ),
);

const FilterSelectorDropdown = forwardRef(
  (
    {
      availableFilters,
      hideFilterText,
      onFilterSelect,
      label,
    }: FilterSelectorDropdownProps,
    ref: React.ForwardedRef<HTMLButtonElement>,
  ) => (
    <Popover className="relative bg-white">
      <PopoverTrigger hideFilterText={hideFilterText} ref={ref} label={label} />
      <Transition
        enter="transition duration-100 ease-out"
        enterFrom="transform scale-95 opacity-0"
        enterTo="transform scale-100 opacity-100"
        leave="transition duration-75 ease-out"
        leaveFrom="transform scale-100 opacity-100"
        leaveTo="transform scale-95 opacity-0"
        className="relative z-40"
      >
        <PopoverPanel className="max-h-96 w-60 overflow-y-scroll rounded-sm
        !border-gray-100 bg-white shadow">
          {({ close }) => (
            <FilterSelector
              availableFilters={availableFilters}
              onFilterSelect={(filter) => {
                (close as () => void)();
                // Adding a small delay opening the applied filter dropdown
                // allows for the closing animation to complete
                setTimeout(() => onFilterSelect(filter), 100);
              }}
            />
          )}
        </PopoverPanel>
      </Transition>
    </Popover>
  ),
);

export default FilterSelectorDropdown;
```

---
## `filter/FormikAmountSearch.tsx.txt`
**Path:** `filter`  
```
import React from "react";
import { FieldProps } from "formik";
import { get } from "lodash";
import sanitizeAmount from "../../../common/utilities/sanitizeAmount";
import { CurrencyInput } from "../../../common/ui-components";
import { AppliedFilterType } from "./util";

type FormikAmountSearchProps = FieldProps & {
  name: string;
  id: string;
  disabled: boolean;
  allowNegative: boolean;
  placeholder: string;
  exponent?: number;
  onChange?: (
    event: React.ChangeEvent<HTMLInputElement>,
    newValue: number | null,
  ) => void;
};

function FormikAmountSearch({
  form,
  field,
  id,
  disabled,
  allowNegative,
  placeholder,
  exponent = 2,
  onChange,
}: FormikAmountSearchProps) {
  let value: number | undefined;

  const formValues = form?.values as Record<string, AppliedFilterType["value"]>;
  const queryField = get(formValues, field.name) as number;

  if (queryField) {
    value = queryField / 10 ** exponent;
  }

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    let newValue: number | null;
    if (allowNegative && event.target.value === "-") {
      newValue = null;
    } else {
      newValue = event.target.value
        ? sanitizeAmount(event.target.value, exponent)
        : null;
    }

    void form.setFieldValue(field.name, newValue);
    if (onChange) {
      onChange(event, newValue);
    }
  };

  return (
    <CurrencyInput
      required
      disabled={disabled}
      id={id}
      input={{
        value,
        onChange: handleChange,
        name: field.name,
        className: "h-[24px] text-xs",
      }}
      allowNegative={allowNegative}
      placeholder={placeholder}
      decimalScale={exponent}
    />
  );
}

export default FormikAmountSearch;
```

---
## `filter/MultiAccountSelect.tsx.txt`
**Path:** `filter`  
```
import { snakeCase } from "lodash";
import React, { useState } from "react";
import { LoadingLine } from "~/common/ui-components";
import MultiSelectDropdown, {
  Category,
} from "~/common/ui-components/MultiSelectDropdown/MultiSelectDropdownPanel";
import { useMultiAccountSelectQuery } from
"~/generated/dashboard/graphqlSchema";

/**
 * Takes an array of internal account IDs and categorizes
 * them by their connection (bank)
 */
function categorizeInitialValues(
  initialValues: Array<string>,
  categories: Array<Category> = [],
) {
  return (initialValues || []).reduce<Record<string, Array<string>>>(
    (acc, value) => {
      // Find the matching bank
      const category = categories.find((option) =>
        option.items.find((item) => item.id === value),
      );
      // Should only occur if something is incorrect in the query string
      // or if the id is all accounts
      if (!category) {
        return acc;
      }
      acc[snakeCase(category.label)].push(value);
      return acc;
    },
    // Create an empty array for each bank as the initial hash
    categories.reduce(
      (acc, category) => ({ ...acc, [snakeCase(category.label)]: [] }),
      {},
    ),
  );
}

function MultiAccountSelect({
  onClose,
  onChange,
  categories,
  initialValues,
}: {
  onClose: () => void;
  onChange: (internalAccounts: Array<string>) => void;
  categories: Array<Category>;
  initialValues: Array<string>;
}) {
  const [searchValue, setSearchValue] = useState("");

  return (
    <MultiSelectDropdown
      onClose={onClose}
      categories={categories}
      onChange={(selectedValues: Record<string, Array<string>>) => {
        const selectedValueArray = Object.keys(selectedValues).reduce<
          Array<string>
        >((acc, key) => [...acc, ...selectedValues[key]], []);
        onChange(
          selectedValueArray.length ? selectedValueArray : ["all-accounts"],
        );
      }}
      initialValues={categorizeInitialValues(initialValues, categories)}
      onSearchValueChange={setSearchValue}
      searchValue={searchValue}
      className="border border-alpha-black-100"
      searchOnCategories
    />
  );
}

function MultiAccountSelectLoader(props) {
  const { data } = useMultiAccountSelectQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      includeAllAccountsOption: false,
    },
  });

  const categories = data?.multiAccountSelectOptions.reduce<Array<Category>>(
    (
      acc,
      accountGroup: {
        label: string;
        options?: Array<{ label: string; value: string }>;
      },
    ) => [
      ...acc,
      {
        label: accountGroup.label,
        id: snakeCase(accountGroup.label),
        items: (accountGroup.options || []).map((account) => ({
          label: account.label,
          id: account.value,
        })),
      },
    ],
    [],
  );

  if (!categories) {
    return (
      <div className="grid h-24 w-60 gap-2 divide-y overflow-y-scroll border-
      alpha-black-100 bg-white p-2 text-sm shadow-lg">
        <LoadingLine />
        <LoadingLine />
        <LoadingLine />
      </div>
    );
  }

  return <MultiAccountSelect {...props} categories={categories} />;
}

export default MultiAccountSelectLoader;
```

---
## `filter/useQueryParams.tsx.txt`
**Path:** `filter`  
```
type GetFiltersFnType = (paramName: string) => Record<string, unknown>;
type SetFiltersFnType = (
  paramName: string,
  filters: Record<string, unknown>,
  updateRoute?: boolean,
) => URLSearchParams;
type UseQueryParamsType = [GetFiltersFnType, SetFiltersFnType];

function useQueryParams(): UseQueryParamsType {
  const getFilters = (paramName: string) => {
    const formattedParamName = `${paramName}Filters`;
    const allSearchParams = new URLSearchParams(window.location.search);
    const filtersForParam = allSearchParams.get(formattedParamName);
    const formattedFilters: Record<string, unknown> = filtersForParam
      ? (JSON.parse(decodeURIComponent(filtersForParam)) as Record<
          string,
          unknown
        >)
      : {};
    return formattedFilters;
  };

  const setFilters = (
    paramName: string,
    filters: Record<string, unknown>,
    updateRoute = true,
  ) => {
    const formattedParamName = `${paramName}Filters`;
    const formattedValue = encodeURIComponent(JSON.stringify(filters));

    const searchParams = new URLSearchParams(window.location.search);
    searchParams.set(formattedParamName, formattedValue);

    const newURL = `?${searchParams.toString()}`;

    if (updateRoute) {
      window.history.replaceState(null, "", newURL);
    }

    return searchParams;
  };

  return [getFilters, setFilters];
}

export default useQueryParams;
```

---
## `filter/util.ts.txt`
**Path:** `filter`  
```
import { v4 as uuidv4 } from "uuid";
import {
  Field,
  LogicalForm__InputTypeEnum,
  FieldWithValue,
} from "../../../generated/dashboard/graphqlSchema";

export type FilterType = {
  rank: number;
  key: string;
  type: LogicalForm__InputTypeEnum;
  name: string;
  repeatable: boolean;
  default: boolean;
  hidden: boolean;
  icon: string;
  options?: Record<string, string>[];
};

export type ValueType =
  | string
  | string[]
  | Record<string, string>
  | number
  | Record<string, unknown>;

export type AppliedFilterType = FilterType & {
  id: string;
  value: ValueType;
  applying: boolean;
};

/** Amount Utility Functions  */

export function amountSearchMapper(
  minimumAmount: number,
  maximumAmount: number,
) {
  return {
    lte: maximumAmount || undefined,
    gte: minimumAmount || undefined,
  };
}

/** Date Utility Functions */

export function dateSearchMapper(
  gte: string | undefined | null,
  lte: string | undefined | null,
) {
  return {
    lte: lte || undefined,
    gte: gte || undefined,
  };
}

export function metadataValueFromURLToState(
  filterInformation: FilterType,
  metadataValues: string,
): AppliedFilterType[] {
  const parsedMetadataValues = JSON.parse(metadataValues) as Record<
    string,
    string
  >;
  const metadataFilters = Object.entries(parsedMetadataValues).map(
    ([key, value]) =>
      ({
        id: uuidv4(),
        ...filterInformation,
        value: { key, value },
        applying: false,
      }) as AppliedFilterType,
  );

  return metadataFilters;
}

export type OverrideValue = {
  [key: string]: {
    default?: boolean;
    repeatable?: boolean;
    hidden?: boolean;
    value?: ValueType;
  };
};

export function mapFieldWithValuesToAppliedFilters(
  logicalFormFields: Array<FieldWithValue>,
): Array<AppliedFilterType> {
  return logicalFormFields.map((logicalFormField, index) => {
    let value = logicalFormField.value as ValueType;
    if (
      logicalFormField.inputType === LogicalForm__InputTypeEnum.SingleSelect ||
      logicalFormField.inputType ===
        LogicalForm__InputTypeEnum.CounterpartySelect
    ) {
      value = value[0] as ValueType;
    }
    const transformedField = {
      id: "",
      rank: index,
      key: logicalFormField.camelizeMethodName,
      type: logicalFormField.inputType,
      name: logicalFormField.prettyMethodName,
      options:
        logicalFormField.enumValues?.map((enumValue) => ({
          prettyValueName: enumValue?.prettyValueName,
          valueName: enumValue?.valueName,
        })) || [],
      repeatable:
        logicalFormField.inputType === LogicalForm__InputTypeEnum.MetadataInput,
      default: true,
      hidden: false,
      icon: logicalFormField.viewOptions?.filterView?.icon || "",
      value,
      applying: false,
    };
    return transformedField;
  });
}

export function mapLogicalFieldsToFilters(
  logicalFormFields: Array<Field>,
  overrideValue: OverrideValue = {},
) {
  return logicalFormFields.map((logicalFormField, index) => ({
    rank: index,
    key: logicalFormField.camelizeMethodName,
    type: logicalFormField.inputType,
    name: logicalFormField.prettyMethodName,
    options: logicalFormField.enumValues,
    repeatable:
      logicalFormField.inputType === LogicalForm__InputTypeEnum.MetadataInput
        ? true
        : overrideValue[logicalFormField.camelizeMethodName]?.repeatable ===
          true,
    default:
      overrideValue[logicalFormField?.camelizeMethodName]?.default === true,
    hidden:
      overrideValue[logicalFormField?.camelizeMethodName]?.hidden === true,
    icon: logicalFormField.viewOptions?.filterView?.icon,
    value:
      overrideValue[logicalFormField?.camelizeMethodName]?.value || undefined,
  }));
}

export function mapFiltersToAppliedFilters(
  filters: Array<FilterType>,
  initialValues?: Record<string, ValueType>,
): AppliedFilterType[] {
  if (!initialValues) {
    return [];
  }
  return filters
    .filter((f) => f.key in initialValues)
    .map((filter) => ({
      ...filter,
      applying: false,
      id: filter.key,
      value: initialValues[filter.key],
    }));
}
```

---
## `forms/ScheduleForm.tsx.txt`
**Path:** `forms`  
```
import { Field, Formik, FormikProps } from "formik";
import moment from "moment";
import React, { Ref } from "react";
import * as Yup from "yup";
import { FormikErrorMessage, FormikSelectField } from "../../../common/formik";
import FormikMultiSelectField from
"../../../common/formik/FormikMultiSelectField";
import { Label } from "../../../common/ui-components";
import {
  DaysOfWeekEnum,
  EveryEnum,
  Schedule,
  ScheduleInput,
} from "../../../generated/dashboard/graphqlSchema";
import {
  DAY_OF_WEEK_OPTIONS,
  getOrdinalNumberOptions,
  getTimeOfDayOptions,
  TIME_ZONE_OPTIONS,
  SCHEDULING_FREQUENCY_OPTIONS,
  TimeOfDayIncrement,
} from "../../constants";

export const DEFAULT_VALUES: ScheduleFormValues = {
  frequency: EveryEnum.Week,
  daysOfWeek: [],
  daysOfMonth: 1,
  timeOfDay: 12,
  timeZone: moment.tz.guess(true),
};

const FREQUENCY_ERROR = "Please select a valid schedule frequency.";
const DAYS_OF_WEEK_ERROR = "Please select at least one day of the week.";
const DAYS_OF_MONTH_ERROR = "Please select a valid day.";
const TIME_OF_DAY_ERROR = "Please select a valid hour.";
const TIME_ZONE_ERROR = "Please select a valid time zone.";

const VALIDATION_SCHEMA = Yup.object({
  frequency: Yup.string().required(FREQUENCY_ERROR),
  daysOfWeek: Yup.array().when("frequency", {
    is: (frequency) => frequency === EveryEnum.Week,
    then: Yup.array().min(1, DAYS_OF_WEEK_ERROR).required(DAYS_OF_WEEK_ERROR),
  }),
  daysOfMonth: Yup.number().when("frequency", {
    is: (frequency) => (frequency && frequency === EveryEnum.Month) as boolean,
    then: Yup.number()
      .min(1, DAYS_OF_MONTH_ERROR)
      .max(31, DAYS_OF_MONTH_ERROR)
      .required(DAYS_OF_MONTH_ERROR),
  }),
  timeOfDay: Yup.number()
    .min(0, TIME_OF_DAY_ERROR)
    .max(23, TIME_OF_DAY_ERROR)
    .required(TIME_OF_DAY_ERROR),
  timeZone: Yup.string().required(TIME_ZONE_ERROR),
});

export type ScheduleFormValues = {
  frequency: EveryEnum;
  daysOfWeek: DaysOfWeekEnum[];
  daysOfMonth: number;
  timeOfDay: number;
  timeZone: string;
};

interface ScheduleFormProps {
  initialValues: ScheduleFormValues;
  formRef?: Ref<FormikProps<ScheduleFormValues>>;
}

export function scheduleFormValuesToInputType(
  formValues: ScheduleFormValues,
): ScheduleInput {
  const { frequency, daysOfWeek, daysOfMonth, timeOfDay, timeZone } =
    formValues;

  const date = new Date();
  date.setUTCHours(Math.floor(timeOfDay), 60 * (timeOfDay % 1), 0);
  const scheduleInputValues: ScheduleInput = {
    every: frequency,
    timeZone,
    scheduledTime: date.toISOString(),
  };

  if (frequency === EveryEnum.Week) {
    scheduleInputValues.daysOfWeek = daysOfWeek;
  } else if (frequency === EveryEnum.Month) {
    scheduleInputValues.daysOfMonth = [daysOfMonth];
  }

  return scheduleInputValues;
}

export function scheduleInputTypeToFormValues(
  scheduleValues: Pick<
    Schedule,
    "daysOfMonth" | "daysOfWeek" | "every" | "timeZone" | "scheduledTime"
  >,
): ScheduleFormValues {
  const { every, daysOfMonth, daysOfWeek, timeZone } = scheduleValues;

  const scheduleFormValues: ScheduleFormValues = {
    frequency: every,
    timeOfDay: scheduleValues.scheduledTime
      ? new Date(scheduleValues.scheduledTime).getUTCHours()
      : DEFAULT_VALUES.timeOfDay,
    daysOfMonth:
      every === EveryEnum.Month && daysOfMonth && daysOfMonth.length > 0
        ? daysOfMonth[0]
        : 1,
    daysOfWeek: every === EveryEnum.Week && daysOfWeek ? daysOfWeek : [],
    timeZone,
  };

  return scheduleFormValues;
}

function ScheduleForm({ initialValues, formRef }: ScheduleFormProps) {
  function sendOnOptions(frequency: EveryEnum) {
    switch (frequency) {
      case EveryEnum.Week:
        return DAY_OF_WEEK_OPTIONS;
      case EveryEnum.Month:
        return getOrdinalNumberOptions(31);
      default:
        return [];
    }
  }

  return (
    <Formik
      initialValues={initialValues}
      validationSchema={VALIDATION_SCHEMA}
      onSubmit={() => undefined}
      innerRef={formRef}
    >
      {({ values }) => {
        const sendOnInput =
          values.frequency === EveryEnum.Week ? "daysOfWeek" : "daysOfMonth";

        return (
          <div>
            <div className="mb-4">
              <Label className="mb-1 text-sm font-medium">Frequency</Label>
              <Field
                name="frequency"
                component={FormikSelectField}
                options={SCHEDULING_FREQUENCY_OPTIONS}
              />
              <FormikErrorMessage name="frequency" />
            </div>
            {values?.frequency !== EveryEnum.Day && (
              <div className="mb-4">
                <Label className="mb-1 text-sm font-medium">Send on</Label>
                {values.frequency === EveryEnum.Month &&
                  values.daysOfMonth > 28 && (
                    <p className="mb-2 text-gray-500">
                      During months with fewer than {values.daysOfMonth} days,
                      this schedule will be triggered on the last day of the
                      month.
                    </p>
                  )}
                <Field
                  name={sendOnInput}
                  component={
                    sendOnInput === "daysOfWeek"
                      ? FormikMultiSelectField
                      : FormikSelectField
                  }
                  options={sendOnOptions(values.frequency)}
                  showOptionCheckbox={sendOnInput === "daysOfWeek"}
                  isClearable={false}
                />
                <FormikErrorMessage name={sendOnInput} />
              </div>
            )}
            <div className="flex">
              <div className="mr-2 w-1/3">
                <Label className="mb-1 text-sm font-medium">Hour</Label>
                <Field
                  name="timeOfDay"
                  component={FormikSelectField}
                  options={getTimeOfDayOptions(TimeOfDayIncrement.Hour)}
                />
                <FormikErrorMessage name="timeOfDay" />
              </div>
              <div className="ml-2 w-2/3">
                <Label className="mb-1 text-sm font-medium">Time zone</Label>
                <Field
                  name="timeZone"
                  component={FormikSelectField}
                  options={TIME_ZONE_OPTIONS}
                />
              </div>
            </div>
          </div>
        );
      }}
    </Formik>
  );
}

export default ScheduleForm;
```

---
## `logical_form/EditLogicalForm.tsx.txt`
**Path:** `logical_form`  
```
import React from "react";
import {
  LogicalForm__ModelNameEnum,
  LogicalFormKeyEnum,
  useLogicalFormQuery,
} from "../../../generated/dashboard/graphqlSchema";
import LogicalForm from "./LogicalForm";

interface EditLogicalFormProps<T> {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  entityId: string;
  preLogicalCustomComponent?: JSX.Element;
  postLogicalCustomComponent?: JSX.Element;
  additionalDefaultInitialValues: T;
  supportAndOfOrs: boolean;
  supportOrOfAnds: boolean;
  fullWidth: boolean;
}

function EditLogicalForm<T = object>({
  logicalFormKey,
  modelName,
  entityId,
  preLogicalCustomComponent,
  postLogicalCustomComponent,
  additionalDefaultInitialValues,
  supportAndOfOrs,
  supportOrOfAnds,
  fullWidth,
}: EditLogicalFormProps<T>): JSX.Element | null {
  const { loading, data } = useLogicalFormQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      logicalFormKey,
      modelName,
      entityId,
    },
  });

  const logicalFormInitialValues = data?.logicalFormInitialValues;

  if (loading) {
    return null;
  }

  return (
    <LogicalForm<T>
      logicalFormKey={logicalFormKey}
      modelName={modelName}
      existingInitialValues={logicalFormInitialValues}
      preLogicalCustomComponent={preLogicalCustomComponent}
      postLogicalCustomComponent={postLogicalCustomComponent}
      additionalDefaultInitialValues={additionalDefaultInitialValues}
      entityId={entityId}
      supportAndOfOrs={supportAndOfOrs}
      supportOrOfAnds={supportOrOfAnds}
      fullWidth={fullWidth}
    />
  );
}

export default EditLogicalForm;
```

---
## `logical_form/LogicalForm.tsx.txt`
**Path:** `logical_form`  
```
import React, { useState } from "react";
import { Formik, Form } from "formik";
import * as Sentry from "@sentry/browser";
import {
  LogicalForm__ModelNameEnum,
  LogicalFormKeyEnum,
  useSubmitLogicalFormMutation,
  LogicalForm__OperatorEnum,
} from "../../../generated/dashboard/graphqlSchema";
import PropositionComponent from "./PropositionComponent";
import {
  FormValues,
  Data,
  PropositionType,
  validationSchema,
} from "./LogicalTypes";
import {
  Alert,
  Button,
  FormContainer,
  Heading,
} from "../../../common/ui-components";

const FORM_SUBMIT_URL: Record<string, string> = {
  [LogicalForm__ModelNameEnum.PaymentOrder]: "/settings/payments/rules/",
  [LogicalForm__ModelNameEnum.ExternalAccount]: "/settings/payments/rules/",
  [LogicalForm__ModelNameEnum.Reconcilable]: "/reconciliation_rules/",
  [LogicalForm__ModelNameEnum.Transaction]:
    "/settings/transaction_categorization/rules/",
};

interface LogicalFormProps<T> {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  existingInitialValues?: string | null | undefined;
  additionalDefaultInitialValues: T;
  preLogicalCustomComponent?: JSX.Element;
  postLogicalCustomComponent?: JSX.Element;
  entityId: string | null | undefined;
  supportAndOfOrs: boolean;
  supportOrOfAnds: boolean;
  fullWidth: boolean;
  /* When passed in, rule will be associated with an editingSessionId. */
  editingSessionId?: string | null | undefined;
}

// LogicalForm for Approval Rules makes assumptions on levels of nesting and how
the
// ands/ors operators work at which level. The old rules were not formatted
within logical to
// conform these assumptions such as the 1st level must always be an OR

function convertOldRulesToNewFormat(data: Data) {
  // Check if the data is in the old format
  if (data?.conditions?.operator === LogicalForm__OperatorEnum.And) {
    const { name, approvers } = data;

    // Convert to the new format
    return {
      name,
      approvers,
      conditions: {
        ...data.conditions,
        operator: LogicalForm__OperatorEnum.Or,
        value: [
          {
            negate: data.conditions.negate,
            operator: LogicalForm__OperatorEnum.And,
            value: data.conditions.value,
          },
        ],
      },
    };
  }

  // If data is already in the new format, return as is
  return data;
}

function LogicalForm<T = object>({
  logicalFormKey,
  modelName,
  existingInitialValues,
  additionalDefaultInitialValues,
  preLogicalCustomComponent,
  postLogicalCustomComponent,
  entityId,
  supportAndOfOrs,
  supportOrOfAnds,
  fullWidth,
  editingSessionId,
}: LogicalFormProps<T>): JSX.Element | null {
  const [submitLogicalForm] = useSubmitLogicalFormMutation();
  const [formErrorMessages, setFormErrorMessages] = useState<string[]>([]);

  let initialValues: FormValues<T>;
  if (!existingInitialValues) {
    initialValues = {
      ...additionalDefaultInitialValues,
      conditions: {
        negate: false,
        value: [
          {
            negate: false,
            value: [
              {
                field: undefined,
                operator: undefined,
                negate: undefined,
                value: undefined,
              },
            ],
          },
        ],
      },
    };
  } else {
    const parsedValues = JSON.parse(existingInitialValues) as FormValues<T>;
    initialValues =
      modelName === LogicalForm__ModelNameEnum.PaymentOrder
        ? (convertOldRulesToNewFormat(parsedValues as Data) as FormValues<T>)
        : parsedValues;
  }

  return (
    <>
      {formErrorMessages.map((errorMessage) => (
        <div className="mt-2">
          <Alert alertType="danger">{errorMessage}</Alert>
        </div>
      ))}
      <FormContainer className="max-w-full">
        <Formik
          initialValues={initialValues}
          validationSchema={validationSchema}
          onSubmit={(values, { setSubmitting }) => {
            setSubmitting(true);

            submitLogicalForm({
              variables: {
                input: {
                  logicalFormKey,
                  modelName,
                  formData: JSON.stringify(values),
                  entityId: entityId ?? null,
                  editingSessionId: editingSessionId ?? null,
                },
              },
            })
              .then((response) => {
                if (response.data?.submitLogicalForm?.errors?.length === 0) {
                  const newEntityId =
                    response.data?.submitLogicalForm?.entityId;
                  if (response.data?.submitLogicalForm?.postSubmitPath) {
                    window.location.href =
                      response.data?.submitLogicalForm?.postSubmitPath;
                  } else {
                    window.location.href = `${FORM_SUBMIT_URL[modelName]}${
                      newEntityId ?? ""
                    }`;
                  }
                } else {
                  setFormErrorMessages(
                    response.data?.submitLogicalForm?.errors ?? [],
                  );
                }
              })
              .catch((error) => {
                setFormErrorMessages(["Sorry, an unexpected error occurred."]);
                Sentry.captureException(error);
              });
            setSubmitting(false);
          }}
        >
          {({ isValid, values }) => {
            const propositionType = values.conditions?.field
              ? PropositionType.Predicate
              : PropositionType.Statement;

            return (
              <Form>
                <div className="max-w-[1600px]">
                  {preLogicalCustomComponent}
                </div>
                <div className={fullWidth ? "max-w-[1600px]" : "max-w-[860px]"}>
                  <Heading level="h3" className="mb-6">
                    Conditions
                  </Heading>
                  <PropositionComponent
                    logicalFormKey={logicalFormKey}
                    modelName={modelName}
                    propositionType={propositionType}
                    formikPath="conditions"
                    supportAndOfOrs={supportAndOfOrs}
                    supportOrOfAnds={supportOrOfAnds}
                  />
                </div>
                <div className="max-w-[860px]">
                  {postLogicalCustomComponent}
                </div>
                <Button buttonType="primary" disabled={!isValid} isSubmit>
                  Submit
                </Button>
              </Form>
            );
          }}
        </Formik>
      </FormContainer>
    </>
  );
}

export default LogicalForm;
```

---
## `logical_form/LogicalFormContainer.tsx.txt`
**Path:** `logical_form`  
```
import React from "react";
import {
  LogicalForm__ModelNameEnum,
  LogicalFormKeyEnum,
} from "../../../generated/dashboard/graphqlSchema";
import EditLogicalForm from "./EditLogicalForm";
import LogicalForm from "./LogicalForm";

interface LogicalFormContainerProps<T = object> {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  entityId?: string;
  preLogicalCustomComponent?: JSX.Element;
  postLogicalCustomComponent?: JSX.Element;
  additionalDefaultInitialValues: T;
  supportAndOfOrs?: boolean;
  supportOrOfAnds?: boolean;
  fullWidth?: boolean;
  editingSessionId?: string | null | undefined;
}

function LogicalFormContainer<T = object>({
  logicalFormKey,
  modelName,
  entityId,
  preLogicalCustomComponent,
  postLogicalCustomComponent,
  additionalDefaultInitialValues,
  supportAndOfOrs = false,
  supportOrOfAnds = true,
  fullWidth = false,
  editingSessionId = null,
}: LogicalFormContainerProps<T>): JSX.Element {
  if (entityId != null) {
    return (
      <EditLogicalForm<T>
        logicalFormKey={logicalFormKey}
        modelName={modelName}
        entityId={entityId}
        additionalDefaultInitialValues={additionalDefaultInitialValues}
        preLogicalCustomComponent={preLogicalCustomComponent}
        postLogicalCustomComponent={postLogicalCustomComponent}
        supportAndOfOrs={supportAndOfOrs}
        supportOrOfAnds={supportOrOfAnds}
        fullWidth={fullWidth}
      />
    );
  }

  return (
    <LogicalForm<T>
      logicalFormKey={logicalFormKey}
      modelName={modelName}
      preLogicalCustomComponent={preLogicalCustomComponent}
      postLogicalCustomComponent={postLogicalCustomComponent}
      additionalDefaultInitialValues={additionalDefaultInitialValues}
      entityId={entityId}
      supportAndOfOrs={supportAndOfOrs}
      supportOrOfAnds={supportOrOfAnds}
      fullWidth={fullWidth}
      editingSessionId={editingSessionId}
    />
  );
}

export default LogicalFormContainer;
```

---
## `logical_form/LogicalTypes.ts.txt`
**Path:** `logical_form`  
```
import * as Yup from "yup";
import {
  LogicalForm__MethodNameEnum,
  LogicalForm__OperatorEnum,
} from "../../../generated/dashboard/graphqlSchema";
import { LegacyMetadata } from "../MetadataInput";

export type Proposition = Predicate | Statement;

export enum PropositionType {
  Predicate = "predicate",
  Statement = "statement",
}

export type Predicate = {
  field?: LogicalForm__MethodNameEnum | null;
  operator?:
    | LogicalForm__OperatorEnum.And
    | LogicalForm__OperatorEnum.Or
    | null;
  negate?: boolean | null;
  value?:
    | string
    | Array<string>
    | number
    | Record<string, string>
    | LegacyMetadata;
};

export type Statement = {
  field?: never;
  operator?: LogicalForm__OperatorEnum | null;
  negate?: boolean | null;
  value: Array<Proposition>;
};

export type FormValues<T = object> = T & {
  conditions: Proposition;
};

export type Approver = {
  id: string;
  conditional_group_ids: string[];
  number_of_reviewers: number;
};

export type Data = {
  conditions?: {
    operator?: LogicalForm__OperatorEnum;
    value: Array<Proposition>;
    negate?: boolean;
  };
  name?: string;
  approvers?: Approver[];
};

/**
 * ----- Yup Validation Schema -----
 *
 * The Schema below validates the input to grey out the submit button if the
 formik state is not valid. Note that it
 * does not validate the value string itself, but moreso validates presence.
 */
const predicateSchema = Yup.object({
  field: Yup.string().required(),
  operator: Yup.string()
    .oneOf(Object.values(LogicalForm__OperatorEnum))
    .required(),
  negate: Yup.boolean().required(),
  value: Yup.lazy((value: string | Array<string> | Record<string, string>) =>
    Yup.mixed().when("operator", {
      // missing and present operators do not require a value
      is: (field: string) =>
        field === LogicalForm__OperatorEnum.Missing ||
        field === LogicalForm__OperatorEnum.Present,
      then: Yup.string().nullable().optional(),
      otherwise: () => {
        if (Array.isArray(value)) {
          // Metadata will be an array of objects. Awkward check since `oneOf`
          wasn't working for me
          if (
            (value as Array<{ key: string; value: string } | string>).find(
              (v) => v && typeof v === "object" && v.key && v.value,
            )
          ) {
            return Yup.array().of(
              Yup.object({
                key: Yup.string().required(),
                value: Yup.string().required(),
              }),
            );
          }
          // All other values will be an array of strings
          return Yup.array().of(Yup.string().min(1, "at least 1"));
        }
        // Otherwise the value should be a string
        return Yup.string().required();
      },
    }),
  ),
});

const propositionSchema = Yup.lazy((value: Proposition) => {
  if (!("field" in value)) {
    const statementSchema = Yup.object({
      operator: Yup.string()
        .oneOf(Object.values(LogicalForm__OperatorEnum))
        .required(),
      negate: Yup.boolean().required(),
      value: Yup.array().of(propositionSchema).min(1, "at least 1"),
    });

    return statementSchema as Yup.SchemaOf<Statement>;
  }

  return predicateSchema;
});

export const validationSchema = Yup.object({
  conditions: propositionSchema as Yup.SchemaOf<Proposition>,
});
```

---
## `logical_form/PredicateComponent.tsx.txt`
**Path:** `logical_form`  
```
import React, { useEffect, useState } from "react";
import { useFormikContext } from "formik";
import { get, startCase } from "lodash";
import { ToggleRow } from "~/common/ui-components";
import PredicateField from "./PredicateField";
import FieldsRow from "../../../common/ui-components/FieldsRow/FieldsRow";
import PredicateOperator from "./PredicateOperator";
import {
  LogicalFormKeyEnum,
  LogicalForm__ModelNameEnum,
  LogicalForm__OperatorEnum,
  Operator,
} from "../../../generated/dashboard/graphqlSchema";
import Button from "../../../common/ui-components/Button/Button";
import Icon from "../../../common/ui-components/Icon/Icon";
import PredicateValueContainer from "./PredicateValueContainer";
import { FormValues } from "./LogicalTypes";

interface PredicateComponentProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
  deletePredicate?: () => void;
  index?: number;
  supportAndOfOrs: boolean;
  supportOrOfAnds: boolean;
}

function PredicateComponent({
  logicalFormKey,
  modelName,
  formikPath,
  deletePredicate,
  index = 0,
  supportAndOfOrs,
  supportOrOfAnds,
}: PredicateComponentProps) {
  const [operators, setOperators] = useState<Array<Operator>>([]);
  const { values, setFieldValue } = useFormikContext<FormValues>();

  const predicateOperatorPathExtractor = (inputString: string) =>
    (inputString.match(/conditions\.value\[\d+\]/) || [""]) as string[];
  const predicateOperatorPath = `${
    predicateOperatorPathExtractor(formikPath)[0]
  }.operator`;
  const predicateOperator =
    supportAndOfOrs && supportOrOfAnds
      ? (get(values, predicateOperatorPath) as LogicalForm__OperatorEnum) ||
        LogicalForm__OperatorEnum.And
      : LogicalForm__OperatorEnum.And;

  useEffect(() => {
    if (supportAndOfOrs && supportOrOfAnds) {
      void setFieldValue(predicateOperatorPath, predicateOperator);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const deletebutton = deletePredicate ? (
    <Button
      id="remove-rule-condition-btn"
      className="float-left w-8"
      buttonType="link"
      onClick={() => deletePredicate()}
    >
      <Icon
        iconName="clear"
        size="m"
        color="currentColor"
        className="text-gray-500"
      />
    </Button>
  ) : null;

  return (
    <div>
      {index === 0 && supportAndOfOrs && supportOrOfAnds && (
        <div className="mb-4 w-fit">
          <ToggleRow
            className="uppercase"
            radios={[
              {
                name: predicateOperatorPath,
                value: LogicalForm__OperatorEnum.And,
                children: startCase(LogicalForm__OperatorEnum.And),
                selected: predicateOperator === LogicalForm__OperatorEnum.And,
                onChange: () => {
                  void setFieldValue(
                    predicateOperatorPath,
                    LogicalForm__OperatorEnum.And,
                  );
                },
              },
              {
                name: predicateOperatorPath,
                value: LogicalForm__OperatorEnum.Or,
                children: startCase(LogicalForm__OperatorEnum.Or),
                selected: predicateOperator === LogicalForm__OperatorEnum.Or,
                onChange: () => {
                  void setFieldValue(
                    predicateOperatorPath,
                    LogicalForm__OperatorEnum.Or,
                  );
                },
              },
            ]}
          />
        </div>
      )}
      <div className="flex">
        <div className="w-14">
          <p className="mt-1 text-right font-medium text-gray-500">
            {index > 0 ? `${startCase(predicateOperator)}` : "When"}
          </p>
        </div>
        <div className="w-full">
          <div className="pl-2">
            <FieldsRow columns={3} gap={2}>
              <PredicateField
                logicalFormKey={logicalFormKey}
                modelName={modelName}
                formikPath={formikPath}
                setOperators={setOperators}
              />
              <PredicateOperator
                operators={operators}
                formikPath={formikPath}
              />
              <PredicateValueContainer
                logicalFormKey={logicalFormKey}
                modelName={modelName}
                formikPath={formikPath}
              />
            </FieldsRow>
          </div>
        </div>
        <div className="mx-2 mt-1.5 w-fit">{deletebutton}</div>
      </div>
    </div>
  );
}

export default PredicateComponent;
```

---
## `logical_form/PredicateField.tsx.txt`
**Path:** `logical_form`  
```
import React, { useEffect, useState } from "react";
import { Field, useFormikContext } from "formik";
import { get, isEmpty } from "lodash";
import ReconciliationRuleCustomFieldModal, {
  reconcilableSchemaCustomFieldCallback,
  overrideReconcilableSchemaCustomMethodName,
} from
"~/app/containers/reconciliation_rules/ReconciliationRuleCustomFieldModal";
import { buildCustomFieldLabel } from
"~/app/containers/reconciliation_rules/utils";
import {
  LogicalFormKeyEnum,
  LogicalForm__MethodNameEnum,
  LogicalForm__ModelNameEnum,
  Operator,
  PredicateFieldQuery,
  SelectOption,
  usePredicateFieldQuery,
} from "../../../generated/dashboard/graphqlSchema";
import FormikSelectField, {
  GroupOptionType,
  OptionType,
} from "../../../common/formik/FormikSelectField";
import { FormValues } from "./LogicalTypes";

const CUSTOM_FIELDS_GROUP_LABEL = "Custom Fields";

function formatFieldOptions(
  logicalFormFields: PredicateFieldQuery["logicalFormFields"] | undefined,
) {
  const groupLabelToFieldOptions: Record<string, SelectOption[]> = {};

  const fieldOptions = logicalFormFields?.map((field) => {
    const fieldOption = {
      label: field.prettyMethodName,
      value: field.methodName,
    };
    const groupLabel = field?.viewOptions?.selectView?.groupLabel;
    if (groupLabel) {
      const updatedFieldOptions =
        groupLabel in groupLabelToFieldOptions
          ? [...groupLabelToFieldOptions[groupLabel], fieldOption]
          : [fieldOption];
      groupLabelToFieldOptions[groupLabel] = updatedFieldOptions;
    }

    return fieldOption;
  });

  if (isEmpty(groupLabelToFieldOptions)) {
    return fieldOptions;
  }
  return Object.entries(groupLabelToFieldOptions).map(([label, options]) => ({
    label,
    options,
  }));
}

interface PredicateFieldProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
  setOperators: (operators: Array<Operator>) => void;
}

function PredicateField({
  logicalFormKey,
  modelName,
  formikPath,
  setOperators,
}: PredicateFieldProps) {
  const [isModalOpen, setIsModalOpen] = useState<boolean>(false);
  const [options, setOptions] = useState<OptionType[] | GroupOptionType[]>();
  const [customFieldName, setCustomFieldName] = useState<string>("");

  const { setFieldValue, values } = useFormikContext<FormValues>();

  const { loading, data } = usePredicateFieldQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      logicalFormKey,
      modelName,
    },
  });

  const logicalFormFields = data?.logicalFormFields;

  const fieldOptions = formatFieldOptions(logicalFormFields) || [];

  const fieldName = `${formikPath}.field`;
  const operatorName = `${formikPath}.operator`;
  const operatorNegate = `${formikPath}.negate`;
  const valuePath = `${formikPath}.value`;

  const curField = get(values, fieldName) as string;
  useEffect(() => {
    if (!loading && logicalFormFields != null) {
      const overriddenMethodName = overrideReconcilableSchemaCustomMethodName(
        modelName,
        curField,
      );

      if (overriddenMethodName) {
        const customFields = (fieldOptions as GroupOptionType[]).find(
          (fieldOptionGroupingByLabel) =>
            fieldOptionGroupingByLabel.label === CUSTOM_FIELDS_GROUP_LABEL,
        );

        const curCustomFieldLabel = buildCustomFieldLabel(
          overriddenMethodName,
          curField,
        );

        customFields?.options.push({
          label: curCustomFieldLabel,
          value: curField as LogicalForm__MethodNameEnum,
        });

        setOptions([...(fieldOptions as GroupOptionType[])]);
        void setFieldValue(fieldName, curField);
      }

      setOperators(
        logicalFormFields.find(
          (field) =>
            field.methodName === curField ||
            field.methodName === overriddenMethodName,
        )?.operators ?? [],
      );
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [modelName, logicalFormFields, loading, setOperators, curField]);

  if (loading || logicalFormFields == null) {
    return null;
  }

  return (
    <>
      <ReconciliationRuleCustomFieldModal
        customFieldName={customFieldName}
        isModalOpen={isModalOpen}
        setIsModalOpen={setIsModalOpen}
        fieldName={fieldName}
        operatorName={operatorName}
        operatorNegate={operatorNegate}
        valuePath={valuePath}
        options={fieldOptions as GroupOptionType[]}
        setOptions={setOptions}
      />
      <Field
        id={fieldName}
        name={fieldName}
        component={FormikSelectField}
        options={options || fieldOptions}
        onChange={(option: OptionType): void => {
          void setFieldValue(fieldName, option.value);
          void setFieldValue(operatorName, null);
          void setFieldValue(operatorNegate, null);
          void setFieldValue(valuePath, null);

          reconcilableSchemaCustomFieldCallback(
            modelName,
            fieldOptions as GroupOptionType[],
            option,
            setCustomFieldName,
            setIsModalOpen,
          );
        }}
      />
    </>
  );
}

export default PredicateField;
```

---
## `logical_form/PredicateOperator.tsx.txt`
**Path:** `logical_form`  
```
import React from "react";
import { Field, useFormikContext } from "formik";
import { get } from "lodash";
import {
  LogicalForm__MethodNameEnum,
  LogicalForm__OperatorEnum,
  Operator,
} from "../../../generated/dashboard/graphqlSchema";
import FormikSelectField, {
  OptionType,
} from "../../../common/formik/FormikSelectField";
import { Predicate } from "./LogicalTypes";

interface PredicateOperatorProps {
  formikPath: string;
  operators: Array<Operator>;
}

const CREATED_BY_THE_API = "Created by the API";
const CREATED_BY_USER_MANUALLY = "Created by a user manually";

function PredicateOperator({ formikPath, operators }: PredicateOperatorProps) {
  const { setFieldValue, values } = useFormikContext();

  const curPredicate = get(values, formikPath) as Predicate;

  const operatorName = `${formikPath}.operator`;
  const operatorNegate = `${formikPath}.negate`;
  const valuePath = `${formikPath}.value`;

  /* (gfu): to support this deprecated rule Predicate for created by
  missing/present
   *   The preferred method is to use CreationSource with OR's.
   */
  const operatorLabel = (operator: Operator) => {
    if (curPredicate?.field === LogicalForm__MethodNameEnum.CreatedByUser) {
      if (
        (operator.operatorName === LogicalForm__OperatorEnum.Missing &&
          !operator.negate) ||
        (operator.operatorName === LogicalForm__OperatorEnum.Present &&
          operator.negate)
      ) {
        return CREATED_BY_THE_API;
      }

      if (
        (operator.operatorName === LogicalForm__OperatorEnum.Present &&
          !operator.negate) ||
        (operator.operatorName === LogicalForm__OperatorEnum.Missing &&
          operator.negate)
      ) {
        return CREATED_BY_USER_MANUALLY;
      }
    }
    return operator.prettyOperatorName;
  };

  const operatorOptions = operators?.map(
    (operator: Operator): OptionType => ({
      label: operatorLabel(operator),
      value: `${operator.operatorName}-${operator.negate.toString()}`,
      hidden:
        operatorLabel(operator) === CREATED_BY_THE_API ||
        operatorLabel(operator) === CREATED_BY_USER_MANUALLY,
    }),
  );

  const isDisabled = curPredicate?.field == null;

  const curPredicateNegate = curPredicate.negate;
  const curPredicateOperator = curPredicate.operator;

  const getSelectedOption = (): string | undefined => {
    if (curPredicateOperator == null || curPredicateNegate == null) {
      return undefined;
    }

    const option = operatorOptions.find(
      (operatorOption: OptionType): boolean =>
        operatorOption.value ===
        `${curPredicateOperator}-${curPredicateNegate.toString()}`,
    );

    return option?.value;
  };

  return (
    <Field
      component={FormikSelectField}
      name={operatorName}
      options={operatorOptions}
      isDisabled={isDisabled}
      onChange={(option: OptionType) => {
        const [operator, negate] = option.value.split("-");
        void setFieldValue(operatorName, operator);
        void setFieldValue(operatorNegate, negate === "true");
        void setFieldValue(valuePath, null);
      }}
      value={getSelectedOption()}
      filterOption={(option: { data: { hidden?: boolean } }) =>
        !option.data.hidden
      }
    />
  );
}

export default PredicateOperator;
```

---
## `logical_form/PredicatePaginatedValue.tsx.txt`
**Path:** `logical_form`  
```
import React, { useState } from "react";
import { Field, useFormikContext } from "formik";
import { get } from "lodash";
import {
  LogicalFormKeyEnum,
  LogicalForm__InputTypeEnum,
  LogicalForm__MethodNameEnum,
  LogicalForm__ModelNameEnum,
  usePredicatePaginatedValueLazyQuery,
} from "../../../generated/dashboard/graphqlSchema";
import { INITIAL_PAGINATION } from "../EntityTableView";
import FormikAsyncSelectField from
"../../../common/formik/FormikAsyncSelectField";
import { FormValues } from "./LogicalTypes";
import { SelectValue } from "../../../common/ui-
components/AsyncSelectField/AsyncSelectField";

interface PredicatePaginatedValueProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
  methodName: LogicalForm__MethodNameEnum;
  inputType: LogicalForm__InputTypeEnum;
  isDisabled: boolean;
}

function PredicatePaginatedValue({
  logicalFormKey,
  modelName,
  formikPath,
  methodName,
  inputType,
  isDisabled,
}: PredicatePaginatedValueProps): JSX.Element | null {
  const { setFieldValue, values } = useFormikContext<FormValues>();

  const [options, setOptions] = useState<SelectValue[]>([]);
  const [nextCursor, setNextCursor] = useState<string | null>(null);

  const [getPredicatePaginatedValue] = usePredicatePaginatedValueLazyQuery();

  // TODO(@lukecivantos): Add ability to search by text PAINT-1863
  const loadOptions = () =>
    new Promise((resolve, reject) => {
      getPredicatePaginatedValue({
        variables: {
          first: INITIAL_PAGINATION.perPage,
          after: nextCursor,
          logicalFormKey,
          modelName,
          methodName,
        },
      })
        .then(({ data: newData }) => {
          // Save next cursor for the following graphql query
          setNextCursor(
            newData?.logicalFormPaginatedValues?.pageInfo.endCursor ?? null,
          );

          // Return the options to react-select
          resolve({
            hasMore: newData?.logicalFormPaginatedValues?.pageInfo?.hasNextPage,
            options: newData?.logicalFormPaginatedValues?.nodes?.map(
              (paginatedValue) => ({
                value: paginatedValue?.valueName,
                label: paginatedValue?.prettyValueName,
              }),
            ),
          });
        })
        .catch((e) => reject(e));
    });

  const valuePath = `${formikPath}.value`;
  const curValue = get(values, valuePath) as
    | string
    | string[]
    | null
    | undefined;
  const curOption = () => {
    if (curValue == null) {
      return undefined;
    }

    if (Array.isArray(curValue)) {
      return curValue.map((val) => ({
        value: val,
        label: options.find((option) => option.value === val)?.label,
      }));
    }

    return {
      value: curValue,
      label: options.find((option) => option.value === curValue)?.label,
    };
  };

  return (
    <Field
      id={valuePath}
      name={valuePath}
      component={FormikAsyncSelectField}
      onChange={(field: SelectValue | SelectValue[]) => {
        if (Array.isArray(field)) {
          setOptions(field);
          void setFieldValue(
            valuePath,
            field.map((curVal) => curVal?.value),
          );
        } else {
          setOptions([field]);
          void setFieldValue(valuePath, field?.value);
        }
      }}
      selectValue={curOption() ?? null}
      loadOptions={loadOptions}
      isDisabled={isDisabled}
      isMulti={inputType === LogicalForm__InputTypeEnum.MultiSelect}
    />
  );
}

export default PredicatePaginatedValue;
```

---
## `logical_form/PredicateValue.tsx.txt`
**Path:** `logical_form`  
```
import React, { useEffect, useState } from "react";
import { Field, FormikHelpers, useFormikContext } from "formik";
import { get } from "lodash";
import ReconciliationRuleCustomValueModal from
"~/app/containers/reconciliation_rules/ReconciliationRuleCustomValueModal";
import { overrideReconcilableSchemaCustomMethodName } from
"~/app/containers/reconciliation_rules/ReconciliationRuleCustomFieldModal";
import AccountSelect from "~/app/containers/AccountSelect";
import { buildCustomFieldLabel } from
"~/app/containers/reconciliation_rules/utils";
import { FormikDateInput } from "~/common/formik";
import {
  LogicalFormKeyEnum,
  LogicalForm__InputTypeEnum,
  LogicalForm__MethodNameEnum,
  LogicalForm__ModelNameEnum,
  LogicalForm__OperatorEnum,
  usePredicateValueQuery,
} from "../../../generated/dashboard/graphqlSchema";
import FormikSelectField, {
  OptionType,
} from "../../../common/formik/FormikSelectField";
import { FormValues, Predicate } from "./LogicalTypes";
import PredicatePaginatedValue from "./PredicatePaginatedValue";
import FormikInputField from "../../../common/formik/FormikInputField";
import FormikNumberFormatField from
"../../../common/formik/FormikNumberFormatField";
import FormikMultiSelectField from
"../../../common/formik/FormikMultiSelectField";
import MetadataInput, {
  LegacyMetadata,
  formatLegacyMetadata,
  parseLegacyMetadata,
} from "../MetadataInput";
import MultiAccountSelect, {
  AllAccountsSelectionBehaviorEnum,
} from "../../containers/MultiAccountSelect";
import CounterpartySelect from "../../containers/CounterpartySelect";
import { SelectAction, SelectValue } from "../../../common/ui-components";
import MultiUserSelect from "../MultiUserSelect";
import {
  EXPECTED_PAYMENT,
  PAYMENT_ORDER,
  ResourcesEnum,
  TRANSACTION,
  EXTERNAL_ACCOUNT,
  RECONCILIATION_RULE_PREVIEW_TRANSACTION,
  INVOICE,
  COUNTERPARTY,
  INTERNAL_ACCOUNT,
  PAPER_ITEM,
  VIRTUAL_ACCOUNT,
  RECONCILIATION_RULE,
} from "../../../generated/dashboard/types/resources";
import FormikSanitizedCurrencyInput from
"../../../common/formik/FormikSanitizedCurrencyInput";

const computeAccountSelectValue = (
  selectField: { value: string; label: string },
  actionName: string,
  values: FormValues,
  valuePath: string,
  setFieldValue: FormikHelpers<FormValues>["setFieldValue"],
) => {
  if (!selectField) return;

  const currentValue = get(values, valuePath) as string[];
  let newValue: Array<string>;
  if (actionName === "remove-value") {
    newValue = currentValue
      ? currentValue.filter((v) => v !== selectField.value)
      : [];
  } else {
    newValue = !currentValue
      ? [selectField.value]
      : [...currentValue, selectField.value];
  }
  void setFieldValue(valuePath, newValue);
};

const CUSTOM_IDENTIFIER_GROUP_OPTION_LABEL = "Custom Identifier";
const KEYWORDS_FOR_CUSTOM_FIELD = ["key", "custom", "match"];

export const computeMultiUserSelectValue = (
  selectValues: SelectValue | SelectValue[],
  selectAction: SelectAction,
  values: object,
  valuePath: string,
  setFieldValue: FormikHelpers<object>["setFieldValue"],
) => {
  let newValue: Array<string> | undefined;
  const currentValue = get(values, valuePath) as string[];
  if (selectAction.action === "remove-value") {
    newValue = currentValue
      ? currentValue.filter(
          (v) =>
            v !==
            (
              selectAction as unknown as {
                removedValue: SelectValue;
              }
            ).removedValue.value,
        )
      : [];
  } else if (selectAction.action === "clear") {
    newValue = undefined;
  } else if (Array.isArray(selectValues)) {
    newValue = !currentValue
      ? [...new Set(selectValues.map((v) => v.value as string))]
      : [
          ...new Set([
            ...currentValue,
            ...selectValues.map((v) => v.value as string),
          ]),
        ];
  } else {
    newValue = !currentValue
      ? [selectValues.value as string]
      : [...new Set([...currentValue, selectValues.value as string])];
  }
  void setFieldValue(valuePath, newValue);
};

interface PredicateValueProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
  methodName: LogicalForm__MethodNameEnum;
  operatorName: LogicalForm__OperatorEnum;
}

// TODO(stephane-mt): we should be using `resources` which are used across the
app
// rather than redeclaring a custom string for the model.
const modelNameToResource: Record<
  LogicalForm__ModelNameEnum,
  ResourcesEnum | undefined
> = {
  PaymentOrder: PAYMENT_ORDER,
  ExpectedPayment: EXPECTED_PAYMENT,
  Transaction: TRANSACTION,
  Quote: undefined,
  Reconcilable: undefined,
  ExternalAccount: EXTERNAL_ACCOUNT,
  ReconciliationRulePreviewTransaction: RECONCILIATION_RULE_PREVIEW_TRANSACTION,
  Invoice: INVOICE,
  Counterparty: COUNTERPARTY,
  InternalAccount: INTERNAL_ACCOUNT,
  PaperItem: PAPER_ITEM,
  VirtualAccount: VIRTUAL_ACCOUNT,
  ReconciliationRule: RECONCILIATION_RULE,
};

function PredicateValue({
  logicalFormKey,
  modelName,
  formikPath,
  methodName,
  operatorName,
}: PredicateValueProps): JSX.Element | null {
  const [isModalOpen, setIsModalOpen] = useState<boolean>(false);
  const [options, setOptions] = useState<OptionType[]>();
  const [customFieldValue, setCustomFieldValue] = useState<string>("");

  const { setFieldValue, values } = useFormikContext<FormValues>();

  const curPredicate = get(values, formikPath) as Predicate;

  const overriddenMethodName = overrideReconcilableSchemaCustomMethodName(
    modelName,
    methodName,
  );

  const { loading, data } = usePredicateValueQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      logicalFormKey,
      modelName,
      methodName: overriddenMethodName || methodName,
      operatorName,
    },
  });

  const valuePath = `${formikPath}.value`;

  const isDisabled =
    curPredicate?.field == null ||
    curPredicate?.operator == null ||
    curPredicate?.negate == null;

  const logicalFormInputType = data?.logicalFormInputType;
  const inputType = logicalFormInputType?.inputType;
  const valueOptions = logicalFormInputType?.enumValues?.map((enumValue) => ({
    label: enumValue?.prettyValueName,
    value: enumValue?.valueName,
  }));

  useEffect(() => {
    const curValue = curPredicate?.value as string;

    if (
      modelName === LogicalForm__ModelNameEnum.Reconcilable &&
      (overriddenMethodName ||
        methodName ===
          LogicalForm__MethodNameEnum.TransactionVendorDescription ||
        methodName ===
          LogicalForm__MethodNameEnum.TransactionVendorCustomerId ||
        methodName === LogicalForm__MethodNameEnum.TransactionId ||
        methodName ===
          LogicalForm__MethodNameEnum.TransactionPaperItemLockboxNumber) &&
      curValue &&
      valueOptions
    ) {
      const matchCurValueToValueOptions = valueOptions.filter((valueOption) =>
        curValue.includes(
          valueOption.value.replace(".path_to", "").replace(".key", ""),
        ),
      );

      const curFieldNameLabel =
        matchCurValueToValueOptions.length === 0
          ? `"${curValue}"`
          : buildCustomFieldLabel(
              matchCurValueToValueOptions[0].value,
              curValue,
            );

      const exactMatch =
        valueOptions.filter((valueOption) => curValue === valueOption.value)
          .length === 1;

      if (!exactMatch) {
        setOptions([
          ...(valueOptions || []),
          {
            label: curFieldNameLabel,
            value: curValue as LogicalForm__MethodNameEnum,
          },
        ]);
      }

      void setFieldValue(valuePath, curValue);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [modelName, methodName, logicalFormInputType, curPredicate?.value]);

  if (inputType === LogicalForm__InputTypeEnum.NoInput) {
    return null;
  }

  if (inputType === LogicalForm__InputTypeEnum.MultiAccountSelect) {
    return (
      <MultiAccountSelect
        disabled={isDisabled}
        onAccountSelect={(_value, selectField, actionName) =>
          computeAccountSelectValue(
            selectField,
            actionName,
            values,
            valuePath,
            setFieldValue,
          )
        }
        accountIds={get(values, valuePath) as string[]}
        id={valuePath}
        showAllAccountsByDefault={false}
        allAccountsSelectionBehavior={
          AllAccountsSelectionBehaviorEnum.selectAccounts
        }
        className="w-full"
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.MultiUserSelect) {
    return (
      <MultiUserSelect
        onChange={(selectValues, selectAction) =>
          computeMultiUserSelectValue(
            selectValues,
            selectAction,
            values,
            valuePath,
            setFieldValue,
          )
        }
        selectedUserIds={get(values, valuePath) as string[]}
        disabled={isDisabled}
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.MetadataInput) {
    return modelNameToResource[modelName] ? (
      <MetadataInput
        onChange={(value) => {
          void setFieldValue(valuePath, formatLegacyMetadata(value));
        }}
        initialValues={parseLegacyMetadata(
          curPredicate.value as unknown as LegacyMetadata | null,
        )}
        resource={modelNameToResource[modelName] as ResourcesEnum}
        hideLabel
        multiLines
        inlineAddButton={false}
        noInitialEmptyEntry={!!curPredicate.value}
        alwaysDeleteOnRemove
        allowNoEntries={false}
      />
    ) : null;
  }

  if (inputType === LogicalForm__InputTypeEnum.FormikSanitizedCurrencyInput) {
    return (
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikSanitizedCurrencyInput}
        className="h-8 flex-grow rounded-sm border border-border-default px-2
        py-1 text-sm placeholder-gray-600 outline-none hover:border-gray-300
        focus:border-l focus:border-blue-500 disabled:bg-gray-100"
      />
    );
  }

  if (logicalFormInputType?.paginateInput) {
    return (
      <PredicatePaginatedValue
        logicalFormKey={logicalFormKey}
        modelName={modelName}
        formikPath={formikPath}
        methodName={methodName}
        inputType={logicalFormInputType?.inputType}
        isDisabled={isDisabled}
      />
    );
  }

  if (loading || logicalFormInputType == null) {
    return (
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikSelectField}
        options={[]}
        isDisabled
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.TextInput) {
    return (
      <Field id={valuePath} name={valuePath} component={FormikInputField} />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.NumberInput) {
    return (
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikNumberFormatField}
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.MultiSelect) {
    return (
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikMultiSelectField}
        options={valueOptions ?? []}
        isDisabled={isDisabled}
        isMulti
        showTooltipOnHover
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.AccountSelect) {
    return (
      <Field
        classes="w-full"
        component={AccountSelect}
        removeAllAccountsOption
        name={valuePath}
        accountId={get(values, valuePath) as string}
        onAccountSelect={(_account, accountData: OptionType) => {
          void setFieldValue(valuePath, accountData.value);
        }}
        customOptions={[
          {
            label: CUSTOM_IDENTIFIER_GROUP_OPTION_LABEL,
            options: valueOptions,
          },
        ]}
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.CounterpartySelect) {
    return (
      <Field
        label={null}
        name={valuePath}
        counterpartyId={get(values, valuePath) as string}
        component={CounterpartySelect}
        onChange={(counterpartyId) => {
          void setFieldValue(valuePath, counterpartyId);
        }}
        customOptions={valueOptions}
      />
    );
  }

  if (inputType === LogicalForm__InputTypeEnum.DateInput) {
    return (
      <Field
        label={null}
        name={valuePath}
        initialDate={get(values, valuePath) as string}
        component={FormikDateInput}
        className="-mt-1.5"
      />
    );
  }

  return (
    <>
      <ReconciliationRuleCustomValueModal
        customFieldValue={customFieldValue}
        isModalOpen={isModalOpen}
        setIsModalOpen={setIsModalOpen}
        valuePath={valuePath}
        options={valueOptions || []}
        setOptions={setOptions}
      />
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikSelectField}
        // If options and valueOptions have the same label, options and
        valueOptions are in sync, so use options.
        // If options and valueOptions don't have the same label, it is because
        the form is not in sync when deleting
        // a predicate, so use valueOptions which is the up to date value.
        options={
          options &&
          valueOptions &&
          options[0]?.label === valueOptions[0]?.label
            ? options || valueOptions
            : valueOptions || options
        }
        onChange={(option: OptionType): void => {
          const isReconcilableSchemaCustomField =
            KEYWORDS_FOR_CUSTOM_FIELD.some((keywordInCustomField) =>
              option.value.includes(keywordInCustomField),
            );

          if (isReconcilableSchemaCustomField) {
            setCustomFieldValue(option.value);
            if (valueOptions?.map((o) => o.value).includes(option.value)) {
              setIsModalOpen(true);
            }
          } else {
            void setFieldValue(valuePath, option.value);
          }
        }}
        isDisabled={isDisabled}
      />
    </>
  );
}

export default PredicateValue;
```

---
## `logical_form/PredicateValueContainer.tsx.txt`
**Path:** `logical_form`  
```
import React from "react";
import { Field, useFormikContext } from "formik";
import { get } from "lodash";
import {
  LogicalFormKeyEnum,
  LogicalForm__ModelNameEnum,
} from "../../../generated/dashboard/graphqlSchema";
import FormikSelectField from "../../../common/formik/FormikSelectField";
import { FormValues, Predicate } from "./LogicalTypes";
import PredicateValue from "./PredicateValue";

interface PredicateValueContainerProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
}

function PredicateValueContainer({
  logicalFormKey,
  modelName,
  formikPath,
}: PredicateValueContainerProps): JSX.Element | null {
  const { values } = useFormikContext<FormValues>();

  const curPredicate = get(values, formikPath) as Predicate;

  const valuePath = `${formikPath}.value`;

  const curPredicateField = curPredicate.field;
  const curPredicateOperator = curPredicate.operator;
  const curPredicateNegate = curPredicate.negate;

  if (
    curPredicateField == null ||
    curPredicateOperator == null ||
    curPredicateNegate == null
  ) {
    return (
      <Field
        id={valuePath}
        name={valuePath}
        component={FormikSelectField}
        options={[]}
        isDisabled
      />
    );
  }

  return (
    <PredicateValue
      logicalFormKey={logicalFormKey}
      modelName={modelName}
      formikPath={formikPath}
      methodName={curPredicateField}
      operatorName={curPredicateOperator}
    />
  );
}

export default PredicateValueContainer;
```

---
## `logical_form/PropositionComponent.tsx.txt`
**Path:** `logical_form`  
```
import React from "react";
import PredicateComponent from "./PredicateComponent";
import {
  LogicalFormKeyEnum,
  LogicalForm__ModelNameEnum,
} from "../../../generated/dashboard/graphqlSchema";
import { PropositionType } from "./LogicalTypes";
import StatementComponent from "./StatementComponent";

interface PropositionComponentProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  propositionType: PropositionType;
  formikPath: string;
  deleteProposition?: () => void;
  supportAndOfOrs: boolean;
  supportOrOfAnds: boolean;
}

function PropositionComponent({
  logicalFormKey,
  modelName,
  propositionType,
  formikPath,
  supportAndOfOrs,
  supportOrOfAnds,
  deleteProposition,
}: PropositionComponentProps) {
  if (propositionType === PropositionType.Predicate) {
    return (
      <PredicateComponent
        logicalFormKey={logicalFormKey}
        modelName={modelName}
        formikPath={formikPath}
        deletePredicate={deleteProposition}
        supportAndOfOrs={supportAndOfOrs}
        supportOrOfAnds={supportOrOfAnds}
      />
    );
  }

  if (propositionType === PropositionType.Statement) {
    return (
      <StatementComponent
        logicalFormKey={logicalFormKey}
        modelName={modelName}
        formikPath={formikPath}
        deleteStatement={deleteProposition}
        supportAndOfOrs={supportAndOfOrs}
        supportOrOfAnds={supportOrOfAnds}
      />
    );
  }

  throw new Error("Unrecognized proposition type");
}

export default PropositionComponent;
```

---
## `logical_form/StatementComponent.tsx.txt`
**Path:** `logical_form`  
```
import React, { useCallback, useEffect } from "react";
import { FieldArray, useFormikContext } from "formik";
import { get, startCase } from "lodash";
import {
  ToggleRow,
  FormContainer,
  LogicalOperatorSeparator,
} from "~/common/ui-components";
import {
  FormValues,
  Proposition,
  PropositionType,
  Statement,
} from "./LogicalTypes";
import Button from "../../../common/ui-components/Button/Button";
import Icon from "../../../common/ui-components/Icon/Icon";
import {
  LogicalFormKeyEnum,
  LogicalForm__ModelNameEnum,
  LogicalForm__OperatorEnum,
} from "../../../generated/dashboard/graphqlSchema";
import PredicateComponent from "./PredicateComponent";

interface StatementComponentProps {
  logicalFormKey: LogicalFormKeyEnum;
  modelName: LogicalForm__ModelNameEnum;
  formikPath: string;
  deleteStatement?: () => void;
  level?: number;
  supportAndOfOrs: boolean;
  supportOrOfAnds: boolean;
}

export default function StatementComponent({
  logicalFormKey,
  modelName,
  formikPath,
  deleteStatement,
  level = 1,
  supportAndOfOrs,
  supportOrOfAnds,
}: StatementComponentProps): JSX.Element | null {
  const { setFieldValue } = useFormikContext<FormValues>();
  const { values } = useFormikContext<FormValues>();

  const curStatement = get(values, formikPath) as Statement;
  const operatorPath = `${formikPath}.operator`;
  const valuePath = `${formikPath}.value`;
  const outerOperator = get(values, "conditions.operator");

  // for simple logic the conditions are always supportOrOfAnds=true
  // and supportAndOfOrs=false
  function configureOperatorsForSimpleLogic() {
    if (level > 1) {
      void setFieldValue(operatorPath, LogicalForm__OperatorEnum.And);
    } else {
      void setFieldValue(operatorPath, LogicalForm__OperatorEnum.Or);
    }
  }

  function configureOperatorsForComplexLogic() {
    const operatorExists = get(values, operatorPath) as string;

    if (!operatorExists) {
      const selectOperator =
        level > 1
          ? LogicalForm__OperatorEnum.And
          : LogicalForm__OperatorEnum.Or;
      void setFieldValue(operatorPath, selectOperator);
    }
  }

  useEffect(() => {
    const complexLogicSupported = supportAndOfOrs && supportOrOfAnds;

    if (complexLogicSupported) {
      configureOperatorsForComplexLogic();
    } else {
      configureOperatorsForSimpleLogic();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [level, setFieldValue, operatorPath]);

  useEffect(() => {
    if (curStatement.value?.length === 0 && deleteStatement) {
      deleteStatement();
    }
  }, [curStatement, deleteStatement]);

  // [@lukeciv]: I originally used PropositionComponent.tsx, but needed to do it
  like this to avoid the dependency cycle
  const propositionComponent = useCallback(
    (
      propositionType: PropositionType,
      newFormikPath: string,
      deleteProposition: () => void,
      index?: number,
    ) => {
      const currentLevel = level ? level + 1 : 1;
      if (propositionType === PropositionType.Predicate) {
        return (
          <PredicateComponent
            logicalFormKey={logicalFormKey}
            modelName={modelName}
            formikPath={newFormikPath}
            deletePredicate={deleteProposition}
            index={index}
            supportAndOfOrs={supportAndOfOrs}
            supportOrOfAnds={supportOrOfAnds}
          />
        );
      }

      if (propositionType === PropositionType.Statement) {
        return (
          <StatementComponent
            logicalFormKey={logicalFormKey}
            modelName={modelName}
            formikPath={newFormikPath}
            deleteStatement={deleteProposition}
            level={currentLevel}
            supportAndOfOrs={supportAndOfOrs}
            supportOrOfAnds={supportOrOfAnds}
          />
        );
      }

      throw new Error("Unrecognized proposition type");
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [logicalFormKey, modelName, level],
  );

  if (typeof values.conditions.value === "string") {
    return null;
  }

  const statementOperator = (
    <div className="relative mb-4 mb-6 mt-8 flex items-center">
      <div className="mr-4 flex-grow border-b border-gray-100" />
      {supportOrOfAnds && supportAndOfOrs && (
        <div className="w-fit">
          <ToggleRow
            radios={[
              {
                name: "conditions.operator",
                value: LogicalForm__OperatorEnum.And,
                selected: outerOperator === LogicalForm__OperatorEnum.And,
                children: startCase(LogicalForm__OperatorEnum.And),
                onChange: () => {
                  void setFieldValue(
                    "conditions.operator",
                    LogicalForm__OperatorEnum.And,
                  );
                },
              },
              {
                name: "conditions.operator",
                value: LogicalForm__OperatorEnum.Or,
                children: startCase(LogicalForm__OperatorEnum.Or),
                selected: outerOperator === LogicalForm__OperatorEnum.Or,
                onChange: () => {
                  void setFieldValue(
                    "conditions.operator",
                    LogicalForm__OperatorEnum.Or,
                  );
                },
              },
            ]}
          />
        </div>
      )}
      {supportOrOfAnds && !supportAndOfOrs && (
        <LogicalOperatorSeparator
          operator={outerOperator as LogicalForm__OperatorEnum}
        />
      )}
      <div className="ml-4 flex-grow border-b border-gray-100" />
    </div>
  );

  return (
    <div>
      <FieldArray
        name={valuePath}
        render={(arrayHelpers) => (
          <>
            <div>
              {curStatement.value && curStatement.value?.length > 0
                ? curStatement.value.map(
                    (proposition: Proposition, index: number): JSX.Element => {
                      const propositionType =
                        "field" in proposition
                          ? PropositionType.Predicate
                          : PropositionType.Statement;
                      const newFormikPath = `${formikPath}.value[${index}]`;
                      return (
                        <>
                          {index > 0 &&
                            propositionType === PropositionType.Statement &&
                            statementOperator}
                          <div
                            className={`rounded-sm bg-gray-50 ${
                              propositionType === PropositionType.Statement
                                ? "border border-gray-100 p-4"
                                : ""
                            }`}
                            key={newFormikPath}
                          >
                            {propositionComponent(
                              propositionType,
                              newFormikPath,
                              (): void => {
                                arrayHelpers.remove(index);
                              },
                              index,
                            )}
                          </div>
                        </>
                      );
                    },
                  )
                : null}
              {level > 1 && (
                <FormContainer className="flex max-w-full justify-center">
                  <Button
                    buttonType="secondary"
                    className="font-medium"
                    onClick={() =>
                      arrayHelpers.push({
                        field: undefined,
                        operator: undefined,
                        negate: undefined,
                        value: undefined,
                      })
                    }
                  >
                    <Icon iconName="add" color="currentColor" />
                    Add Condition
                  </Button>
                </FormContainer>
              )}
            </div>
            {level === 1 && (
              <Button
                buttonType="secondary"
                className="mx-auto my-6 self-center"
                onClick={() =>
                  arrayHelpers.push({
                    operator: undefined,
                    negate: false,
                    value: [
                      {
                        field: undefined,
                        operator: undefined,
                        negate: undefined,
                        value: undefined,
                      },
                    ],
                  })
                }
              >
                <Icon iconName="add" color="currentColor" />
                Add Condition Block
              </Button>
            )}
          </>
        )}
      />
    </div>
  );
}
```

---
## `navigation_bar/InternalToolsSection.tsx.txt`
**Path:** `navigation_bar`  
```
import React from "react";
import InternalToolsToggle from "~/app/containers/InternalToolsToggle";
import { Button, Icon, Stack } from "~/common/ui-components";

export interface InternalToolsSectionProps {
  onClickGhostLogout: () => void;
  collapsed: boolean;
}

export default function InternalToolsSection({
  onClickGhostLogout,
  collapsed,
}: InternalToolsSectionProps) {
  return (
    <Stack className="mb-2 gap-1">
      {collapsed ? (
        <Button iconOnly buttonType="destructive" onClick={onClickGhostLogout}>
          <Icon iconName="undo" color="currentColor" className="text-white" />
        </Button>
      ) : (
        <Button
          className="!rounded"
          fullWidth
          buttonType="destructive"
          onClick={onClickGhostLogout}
        >
          Stop Customer View
        </Button>
      )}

      <InternalToolsToggle collapsed={collapsed} />
    </Stack>
  );
}
```

---
## `navigation_bar/NavigationBarLayout.tsx.txt`
**Path:** `navigation_bar`  
```
import React, { ReactNode } from "react";

interface NavigationBarProps {
  header: ReactNode;
  children: ReactNode;
}
function NavigationBarLayout({ header, children }: NavigationBarProps) {
  return (
    <div className="no-scrollbar flex h-full w-full flex-col justify-between
    text-sm">
      <div>{header}</div>
      <div className="no-scrollbar flex w-full grow overflow-y-auto pr-1">
        {/* Replaces 1px padding with an empty div. This acts as a target to
        check if the user's mouse
        enters this area. We use it to close the popover when the navbar is
        collapsed */}
        <div className="navbar-mouseleave-target flex h-full w-1" />
        {children}
      </div>
    </div>
  );
}

export default NavigationBarLayout;
```

---
## `navigation_bar/RootNavigationMenu.jsx.txt`
**Path:** `navigation_bar`  
```
import React from "react";
import { cn } from "~/common/utilities/cn";
import NavigationLink from "../NavigationLink";
import OrgSwitcher from "../OrgSwitcher";
import {
  Icon,
  Popover,
  PopoverPanel,
  PopoverTrigger,
  Stack,
} from "../../../common/ui-components";
import Gon from "../../../common/utilities/gon";
import QuickSwitchNavigationLink from
"../../containers/quick_switch/QuickSwitchNavigationLink";
import SandboxToggle from "./SandboxToggle";
import SpaceBetweenContainer from "./SpaceBetweenContainer";
import NavigationBarLayout from "./NavigationBarLayout";
import InternalToolsSection from "./InternalToolsSection";

export function visitGoLive() {
  window.location.href = "/partner_searches/new?newnav=true";
}

function RootNavigationMenu({
  collapsed,
  organizationName,
  navigationLinks,
  setNavBar,
  isGhosting,
  onGhostLogoutClick,
  setCollapsedPreviewSection,
  collapsedPreviewSection,
  ...props
}) {
  const {
    ui: { userEmail },
  } = Gon.gon;
  const {
    primary_links: primaryLinks,
    tools_links: toolsLinks,
    additional_links: additionalLinks,
    products_links: productsLinks,
    footer_links: footerLinks,
  } = navigationLinks;

  // Used to build the org icon in the sidebar when collapsed
  const shortname = organizationName.substring(0, 2);

  return (
    <NavigationBarLayout
      header={
        <Popover>
          <div className="flex">
            <PopoverTrigger
              as="div"
              className={cn(
                "flex w-full cursor-pointer items-center justify-center",
                !collapsed &&
                  "mx-1 mb-2 mt-4 h-10 justify-between rounded-md hover:bg-
                  gray-800 active:bg-gray-700",
                collapsed && "h-16 !px-0.5",
              )}
              role="button"
              id="headlessui-popover-button-1"
            >
              {collapsed ? (
                <div className="pt-2.5">
                  <div className="flex items-start justify-between gap-1
                  rounded-md px-0.5 py-2 hover:bg-gray-800 active:bg-gray-700">
                    <div className="flex w-8 justify-center rounded-[3px] bg-
                    white px-1 py-2 text-center text-xxs font-medium uppercase">
                      {shortname}
                    </div>
                    <div className="sr-only">{organizationName}</div>
                  </div>
                </div>
              ) : (
                <div className="flex w-full items-center justify-between gap-1
                rounded-md px-2 py-1.5 hover:bg-gray-800 active:bg-gray-700">
                  <div className="flex max-w-[172px] flex-col gap-0.5
                  whitespace-nowrap">
                    <div className="organization-name overflow-hidden overflow-
                    ellipsis whitespace-nowrap text-left text-sm font-medium
                    text-gray-50a">
                      {organizationName}
                    </div>
                    <div className="overflow-hidden overflow-ellipsis
                    whitespace-nowrap text-left text-xs font-medium text-
                    gray-300">
                      {userEmail}
                    </div>
                  </div>
                  <Icon
                    className="shrink-0 text-gray-400"
                    iconName="expand_all"
                    color="currentColor"
                    size="m"
                  />
                </div>
              )}
            </PopoverTrigger>
          </div>
          <PopoverPanel className="!mt-1 !border-none !bg-transparent !py-0">
            {({ close }) => <OrgSwitcher onClose={close} />}
          </PopoverPanel>
        </Popover>
      }
    >
      <SpaceBetweenContainer
        mainContent={
          <Stack
            id="application-sidebar-products"
            className={cn(
              "navbar-mouseleave-target gap-8 pt-2",
              collapsed && "w-fit",
            )}
          >
            <Stack
              className={cn(
                "navbar-mouseleave-target gap-1",
                collapsed && "w-fit",
              )}
            >
              {isGhosting ? (
                <InternalToolsSection
                  onClickGhostLogout={onGhostLogoutClick}
                  collapsed={collapsed}
                />
              ) : null}
              <NavigationLink
                srOnly={collapsed}
                collapsed={collapsed}
                key="Home"
                link={{
                  text: "Home",
                  icon: "mt_home",
                  path: "/",
                }}
                alwaysExpanded={false}
                setCollapsedPreviewSection={setCollapsedPreviewSection}
                collapsedPreviewSection={collapsedPreviewSection}
              />
              <QuickSwitchNavigationLink
                key="quickSwitch"
                defaultFocus
                collapsed={collapsed}
                srOnly={collapsed}
                setCollapsedPreviewSection={setCollapsedPreviewSection}
                collapsedPreviewSection={collapsedPreviewSection}
              />
              {primaryLinks.map((l) => (
                <NavigationLink
                  srOnly={collapsed}
                  collapsed={collapsed}
                  link={l}
                  alwaysExpanded={false}
                  setCollapsedPreviewSection={setCollapsedPreviewSection}
                  collapsedPreviewSection={collapsedPreviewSection}
                />
              ))}
            </Stack>
            <Stack
              className={cn(
                "navbar-mouseleave-target gap-1",
                collapsed && "w-fit",
              )}
            >
              {productsLinks.map((l) => (
                <NavigationLink
                  collapsed={collapsed}
                  srOnly={collapsed}
                  key={l.text}
                  link={l}
                  alwaysExpanded={false}
                  setCollapsedPreviewSection={setCollapsedPreviewSection}
                  collapsedPreviewSection={collapsedPreviewSection}
                />
              ))}

              {toolsLinks.map((t) => (
                <NavigationLink
                  srOnly={collapsed}
                  collapsed={collapsed}
                  key={t.text}
                  link={t}
                  alwaysExpanded={false}
                  setCollapsedPreviewSection={setCollapsedPreviewSection}
                  collapsedPreviewSection={collapsedPreviewSection}
                />
              ))}
            </Stack>
            <Stack className={cn("gap-1", collapsed && "w-fit")}>
              <SandboxToggle
                {...props}
                visitGoLive={visitGoLive}
                collapsed={collapsed}
                srOnly={collapsed}
                setCollapsedPreviewSection={setCollapsedPreviewSection}
              />
              {additionalLinks.map((l) => (
                <NavigationLink
                  srOnly={collapsed}
                  collapsed={collapsed}
                  key={l.text}
                  link={l}
                  alwaysExpanded={false}
                  setCollapsedPreviewSection={setCollapsedPreviewSection}
                  collapsedPreviewSection={collapsedPreviewSection}
                />
              ))}
            </Stack>
          </Stack>
        }
        bottomContent={
          <Stack className={cn("gap-1", collapsed && "w-fit")}>
            {footerLinks.map((l) => (
              <NavigationLink
                srOnly={collapsed}
                collapsed={collapsed}
                key={l.text}
                link={l}
                alwaysExpanded={false}
                setCollapsedPreviewSection={setCollapsedPreviewSection}
                collapsedPreviewSection={collapsedPreviewSection}
              />
            ))}
          </Stack>
        }
      />
    </NavigationBarLayout>
  );
}

export default RootNavigationMenu;
```

---
## `navigation_bar/SandboxToggle.tsx.txt`
**Path:** `navigation_bar`  
```
import React from "react";
import { cn } from "~/common/utilities/cn";
import { useReadLiveMode } from "~/common/utilities/useReadLiveMode";
import { Clickable, Icon } from "../../../common/ui-components";

type SandboxToggleProps = {
  isOrganizationLive: boolean;
  toggleLiveMode: () => void;
  visitGoLive: () => void;
  collapsed?: boolean;
  setCollapsedPreviewSection: (section: string | null) => void;
};

function SandboxText({
  isLiveMode,
  collapsed,
}: {
  isLiveMode: boolean;
  collapsed?: boolean;
}) {
  if (collapsed) {
    return null;
  }
  return isLiveMode ? (
    <span className="pl-2">View Sandbox</span>
  ) : (
    <span className="pl-2">Viewing Sandbox</span>
  );
}

function SandboxToggle({
  isOrganizationLive,
  toggleLiveMode,
  visitGoLive,
  collapsed,
  setCollapsedPreviewSection,
}: SandboxToggleProps) {
  const isLiveMode = useReadLiveMode();
  return (
    <Clickable onClick={isOrganizationLive ? toggleLiveMode : visitGoLive}>
      <div
        className="flex rounded px-2 py-1.5 hover:bg-mist-700"
        onMouseEnter={() => {
          if (collapsed) {
            setCollapsedPreviewSection(null);
          }
        }}
      >
        <div
          id="live-mode-toggle"
          className={cn(
            "flex items-center",
            isLiveMode ? "text-gray-200" : "text-orange-300a",
          )}
        >
          <div className="flex h-5 w-5 items-center justify-center">
            <Icon
              className={cn(isLiveMode ? "text-gray-200" : "text-orange-300a")}
              color="currentColor"
              iconName={isLiveMode ? "toggle_off" : "toggle_on"}
              size="s"
            />
          </div>
          <SandboxText isLiveMode={isLiveMode} collapsed={collapsed} />
        </div>
      </div>
    </Clickable>
  );
}

export default SandboxToggle;
```

---
## `navigation_bar/SettingsNavigationMenu.tsx.txt`
**Path:** `navigation_bar`  
```
import React from "react";
import {
  ButtonClickEventTypes,
  Clickable,
  Icon,
  Stack,
} from "~/common/ui-components";
import { useHandleLinkClick } from "~/common/utilities/handleLinkClick";
import { cn } from "~/common/utilities/cn";
import NavigationLink, { LinkType } from "../NavigationLink";
import NavigationBarLayout from "./NavigationBarLayout";
import SandboxToggle from "./SandboxToggle";
import { visitGoLive } from "./RootNavigationMenu";
import SpaceBetweenContainer from "./SpaceBetweenContainer";
import InternalToolsSection from "./InternalToolsSection";

interface SettingsNavigationMenuProps {
  organizationName: string;
  navigationLinks: {
    settings_links: Array<LinkType>;
  };
  isOrganizationLive: boolean;
  toggleLiveMode: () => void;
  isGhosting: boolean;
  onGhostLogoutClick: () => void;
  collapsed: boolean;
  setCollapsedPreviewSection: (section: string | null) => void;
  collapsedPreviewSection: string | null;
}

function SettingsNavigationMenu(props: SettingsNavigationMenuProps) {
  const {
    organizationName,
    navigationLinks: { settings_links: settingsLinks },
    isOrganizationLive,
    toggleLiveMode,
    isGhosting,
    onGhostLogoutClick,
    collapsed,
    setCollapsedPreviewSection,
    collapsedPreviewSection,
  } = props;
  const handleLinkClick = useHandleLinkClick();

  const clearAndSetNavBar = (e: ButtonClickEventTypes) => {
    setCollapsedPreviewSection(null);
    handleLinkClick("/", e);
  };

  return (
    <NavigationBarLayout
      header={
        collapsed ? (
          <div className="px-1">
            <Clickable onClick={clearAndSetNavBar}>
              <div className="mb-2 mt-4 flex w-full justify-center rounded-md
              pb-2 pt-2 transition-colors duration-150 ease-in-out hover:bg-
              gray-800">
                <Icon
                  className="text-gray-200"
                  iconName="chevron_left"
                  color="currentColor"
                  size="l"
                />
              </div>
            </Clickable>
          </div>
        ) : (
          <div className="pb-2 pt-4">
            <div className="flex">
              <div className="flex w-[220px] flex-col whitespace-nowrap">
                <div className="organization-name text-left text-xs">
                  <button
                    type="button"
                    onClick={clearAndSetNavBar}
                    className="w-50"
                  >
                    <div className="flex items-center pl-2">
                      <Icon
                        className="text-gray-400"
                        iconName="chevron_left"
                        size="s"
                        color="currentColor"
                      />
                      <span className="overflow-hidden overflow-ellipsis
                      whitespace-nowrap pl-1 font-medium text-gray-300">
                        {organizationName}
                      </span>
                    </div>
                  </button>
                </div>
              </div>
            </div>
            <div className="pl-3 text-base font-medium text-gray-50a">
              Settings
            </div>
          </div>
        )
      }
    >
      <SpaceBetweenContainer
        mainContent={
          <Stack className="navbar-mouseleave-target gap-1 pt-2">
            {isGhosting ? (
              <InternalToolsSection
                onClickGhostLogout={onGhostLogoutClick}
                collapsed={collapsed}
              />
            ) : null}
            <Stack
              className={cn(
                "navbar-mouseleave-target",
                collapsed ? "gap-1" : "gap-6",
              )}
            >
              {settingsLinks.map((link) => (
                <Stack className="gap-1" key={link.path}>
                  <NavigationLink
                    key={link.text}
                    link={link}
                    alwaysExpanded
                    collapsed={collapsed}
                    srOnly={collapsed}
                    setCollapsedPreviewSection={setCollapsedPreviewSection}
                    collapsedPreviewSection={collapsedPreviewSection}
                  />
                </Stack>
              ))}
            </Stack>
          </Stack>
        }
        bottomContent={
          <SandboxToggle
            isOrganizationLive={isOrganizationLive}
            toggleLiveMode={toggleLiveMode}
            visitGoLive={visitGoLive}
            collapsed={collapsed}
            setCollapsedPreviewSection={setCollapsedPreviewSection}
          />
        }
      />
    </NavigationBarLayout>
  );
}

export default SettingsNavigationMenu;
```

---
## `navigation_bar/SpaceBetweenContainer.tsx.txt`
**Path:** `navigation_bar`  
```
import React from "react";

interface SettingsNavigationMenuProps {
  mainContent: JSX.Element | Array<JSX.Element>;
  bottomContent: JSX.Element;
}

function SpaceBetweenContainer({
  mainContent,
  bottomContent,
}: SettingsNavigationMenuProps) {
  return (
    <div className="no-scrollbar navbar-mouseleave-target flex h-full w-full
    grow flex-col justify-between gap-4 overflow-y-auto pb-6 pt-2">
      <div className="navbar-mouseleave-target flex-grow">{mainContent}</div>
      <div>{bottomContent}</div>
    </div>
  );
}

export default SpaceBetweenContainer;
```

---
## `rules/CreatedByUserFieldValueInput.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import { RULE_VALUE_MAPPING } from "../../constants";
import { RulesFormQuery } from "../../../generated/dashboard/graphqlSchema";
import { SelectField } from "../../../common/ui-components";
import {
  InputFieldProps,
  SingleFieldChangeFn,
  MultiFieldChangeFn,
} from "../../types/RuleConditionFieldValueInput";

type OperatorFieldOption = {
  id: string | null;
  key: string;
  value: string;
  label: string;
  operator?: string;
};

function CreatedByUserFieldValueInput({
  id,
  dataIndex,
  operator,
  conditionKey,
  currentValue,
  userEntities,
  onSingleFieldChange,
  onMultiFieldChange,
}: {
  userEntities: RulesFormQuery["usersUnpaginated"];
  onSingleFieldChange: SingleFieldChangeFn;
  onMultiFieldChange: MultiFieldChangeFn;
} & InputFieldProps) {
  let options: Array<OperatorFieldOption>;
  let isMulti: boolean;
  let onChange: SingleFieldChangeFn | MultiFieldChangeFn;
  if (operator === "in" || operator === "not_in") {
    isMulti = true;
    onChange = onMultiFieldChange;
    options = Object.values(userEntities).map((user) => ({
      value: user.id,
      label: user.name || user.id,
      key: conditionKey,
      operator,
      id,
    }));
  } else {
    isMulti = false;
    onChange = onSingleFieldChange;
    options = Object.keys(RULE_VALUE_MAPPING).map((value) => ({
      value,
      label: RULE_VALUE_MAPPING.any === value ? "a user manually" : "API",
      key: conditionKey,
      operator,
      id,
    }));
  }

  return (
    <SelectField
      required
      isMulti={isMulti}
      options={options}
      handleChange={onChange}
      name={`value_${dataIndex}`}
      selectValue={currentValue}
    />
  );
}

export default CreatedByUserFieldValueInput;
```

---
## `rules/MetadataFieldValueInput.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import MetadataInput from "../MetadataInput";
import {
  RuleValue,
  MetadataKeyValue,
} from "../../types/RuleConditionFieldValueInput";
import { PAYMENT_ORDER } from "../../../generated/dashboard/types/resources";

function MetadataFieldValueInput({
  currentValue,
  onMetadataChange,
}: {
  currentValue: RuleValue;
  onMetadataChange: (data: Record<string, Record<string, string>>) => void;
}) {
  const metadata = ((currentValue as MetadataKeyValue) || []).reduce(
    (memo: MetadataKeyValue[number], { key = "", value = "" }) => ({
      ...memo,
      [key]: value,
    }),
    {},
  );

  return (
    <div className="form-group">
      <MetadataInput
        initialValues={metadata}
        resource={PAYMENT_ORDER}
        hideLabel
        onChange={(data) =>
          onMetadataChange(
            Object.keys(data).length ? { metadata: { ...data } } : {},
          )
        }
        multiLines
        noInitialEmptyEntry={Object.keys(metadata).length > 0}
        allowNoEntries={false}
      />
    </div>
  );
}

export default MetadataFieldValueInput;
```

---
## `rules/NormalizeRuleData.ts.txt`
**Path:** `rules`  
```
import { isEmpty } from "lodash";
import {
  RuleData,
  RuleValue,
  RuleValueField,
  UIRuleData,
} from "../../types/RuleConditionFieldValueInput";

const NEGATION_OPERATOR_PREFIX = "not_";

/**
 * Function for adding negation information to rule condition data before gql
 mutation
 * Negated operators need to be parsed from "not_${operator}": value to
 operator: { value, negate } form
 */
export function normalizeRuleData(data: UIRuleData): RuleData {
  // key is something like "metadata_keys_and_values", "amount", etc.
  return Object.keys(data as Record<string, unknown>).reduce(
    (normalizedData: RuleData, key) => {
      const fieldValue: Record<string, RuleValue> = data[key];

      // add negation information to condition value
      let [operator] = Object.keys(fieldValue);
      const value: RuleValue = fieldValue[operator];
      let negate = false;
      if (operator?.includes(NEGATION_OPERATOR_PREFIX)) {
        operator = operator.replace(NEGATION_OPERATOR_PREFIX, "");
        negate = true;
      }

      return {
        ...normalizedData,
        [key]: {
          [operator]: {
            value,
            negate,
          },
        },
      };
    },
    {},
  );
}

/**
 * Function for translating the rule data's operators for FE
 * Negated operators need to be parsed from operator: {value, negate} to
 "not_${operator}": value form
 */
export function normalizeOperatorOptions(data: string): UIRuleData {
  if (isEmpty(data)) return {};

  const dataJson = JSON.parse(data) as Record<
    string,
    Record<string, RuleValueField>
  >;

  return Object.keys(dataJson).reduce((normalizedData, key) => {
    const fieldValue = dataJson[key];

    let [operator] = Object.keys(fieldValue);
    const { value } = fieldValue[operator];
    operator = fieldValue[operator].negate
      ? `${NEGATION_OPERATOR_PREFIX}${operator}`
      : operator;

    return {
      ...normalizedData,
      [key]: {
        [operator]: value,
      },
    };
  }, {});
}
```

---
## `rules/OriginatingAccountFieldValueInput.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import { SelectField } from "../../../common/ui-components";
import {
  InputFieldProps,
  MultiFieldChangeFn,
} from "../../types/RuleConditionFieldValueInput";
import { InternalAccount } from "../../../generated/dashboard/graphqlSchema";

function OriginatingAccountFieldValueInput({
  id,
  dataIndex,
  operator,
  conditionKey,
  currentValue,
  internalAccountsById,
  onMultiFieldChange,
}: {
  internalAccountsById: { [s: string]: InternalAccount };
  onMultiFieldChange: MultiFieldChangeFn;
} & InputFieldProps) {
  const accountOptions = Object.values<InternalAccount>(
    internalAccountsById,
  ).map((ia) => ({
    value: ia.id,
    label: ia.longName,
    key: conditionKey,
    operator,
    id,
  }));

  return (
    <SelectField
      isMulti
      isClearable={false}
      required
      options={accountOptions}
      handleChange={onMultiFieldChange}
      name={`value_${dataIndex}`}
      selectValue={currentValue}
    />
  );
}

export default OriginatingAccountFieldValueInput;
```

---
## `rules/PaymentTypeFieldValueInput.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import { SelectField } from "../../../common/ui-components";
import {
  InputFieldProps,
  SingleFieldChangeFn,
} from "../../types/RuleConditionFieldValueInput";
import { PRETTY_PAYMENT_TYPE_MAPPING } from "../../constants";

function PaymentTypeFieldValueInput({
  id,
  dataIndex,
  operator,
  conditionKey,
  currentValue,
  onSingleFieldChange,
}: {
  onSingleFieldChange: SingleFieldChangeFn;
} & InputFieldProps) {
  const paymentTypeOptions = Object.entries(PRETTY_PAYMENT_TYPE_MAPPING).map(
    ([value, label]) => ({
      value,
      label,
      key: conditionKey,
      operator,
      id,
    }),
  );

  return (
    <SelectField
      required
      options={paymentTypeOptions}
      handleChange={onSingleFieldChange}
      name={`value_${dataIndex}`}
      selectValue={currentValue}
    />
  );
}

export default PaymentTypeFieldValueInput;
```

---
## `rules/RuleApproverSection.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import isNil from "lodash/isNil";

import {
  Button,
  Heading,
  Icon,
  Label,
  SelectField,
} from "../../../common/ui-components";
import { RuleFormValues } from "../../constants/rule_form";

import { RulesFormQuery } from "../../../generated/dashboard/graphqlSchema";

function RuleApproverSection({
  id,
  rule,
  queryData,
  loading,
  setRule,
}: {
  id: string | null;
  rule: RuleFormValues;
  queryData: RulesFormQuery | undefined;
  loading: boolean;
  setRule: (rule: RuleFormValues) => void;
}) {
  const { groups } = rule;
  const groupEntities =
    loading || !queryData ? [] : queryData.groupsUnpaginated;

  function handleGroupsChange(value, field: { index: number; value: string }) {
    const newGroups = rule.groups ? [...rule.groups] : [];
    newGroups[field.index] = field.value;

    const newRule = {
      ...rule,
      groups: newGroups,
    };

    setRule(newRule);
  }

  function removeRuleGroup(groupIndex: number) {
    groups?.splice(groupIndex, 1);

    const newRule = {
      ...rule,
      groups,
    };

    setRule(newRule);
  }

  function addRuleGroup() {
    const newRule = {
      ...rule,
      groups: groups ? [...groups, ""] : [],
    };

    setRule(newRule);
  }

  return (
    <div className="form-section pb-4">
      <Heading level="h3">Approvers</Heading>
      {groups?.map((groupId, groupIndex) => {
        const groupOptions = groupEntities.map((group) => ({
          value: group.id,
          label: group.name,
          id,
          index: groupIndex,
        }));

        return (
          <div>
            <Label>{`Approver ${groupIndex + 1}`}</Label>
            <div className="flex w-full flex-row space-x-4 pb-4" key={groupId}>
              <div className="w-1/4">
                <SelectField
                  required
                  isClearable={false}
                  name={`groups_${groupIndex}`}
                  handleChange={handleGroupsChange}
                  selectValue={groups[groupIndex]}
                  placeholder="Select a group"
                  options={groupOptions}
                />
              </div>
              <Button
                id="remove-approver-btn"
                disabled={groupIndex === 0 && groups?.length <= 1}
                onClick={() => removeRuleGroup(groupIndex)}
              >
                <Icon
                  iconName="clear"
                  size="xs"
                  color="currentColor"
                  className="text-gray-300"
                />
              </Button>
            </div>
          </div>
        );
      })}
      <Button
        onClick={() => addRuleGroup()}
        disabled={rule?.groups?.some((g) => isNil(g))}
      >
        <Icon iconName="add" />
        <span>Add Approver</span>
      </Button>
    </div>
  );
}

export default RuleApproverSection;
```

---
## `rules/RuleCondition.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import {
  RuleConditionFragment,
  RuleValue,
} from "../../../generated/dashboard/graphqlSchema";

interface RuleConditionProps {
  ruleCondition: RuleConditionFragment;
  includeLinks?: boolean;
}

function RuleCondition({
  ruleCondition,
  includeLinks = true,
}: RuleConditionProps): JSX.Element | null {
  const { prettyKey, prettyOperator, prettyValue } = ruleCondition;

  if (prettyValue.length === 0) {
    // @TODO(@lukecivantos): This is very bad. I want to log while still
    returning null.
    return null;
  }

  const valueContent = prettyValue.map(
    (ruleValue: RuleValue, index: number): JSX.Element => {
      const { prettyContent, path } = ruleValue;

      const startingSpace = index === 0 ? " " : null;

      let content: JSX.Element;
      let key: string;
      if (path && includeLinks) {
        key = path;
        content = (
          <React.Fragment key={key}>
            {startingSpace}
            <a href={path}>{prettyContent}</a>
          </React.Fragment>
        );
      } else {
        key = prettyContent;
        content = (
          <React.Fragment key={`${key}_${index}`}>
            {startingSpace}
            {prettyContent}
          </React.Fragment>
        );
      }

      if (prettyValue.length === 1) {
        return content;
      }

      return <li key={key}>{content}</li>;
    },
  );

  return (
    <>
      {`${prettyKey} ${prettyOperator}`}
      {prettyValue.length !== 1 && ":"}
      {valueContent}
    </>
  );
}

export default RuleCondition;
```

---
## `rules/RuleConditionFieldValueInput.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import isNil from "lodash/isNil";
import {
  DIRECTION_OPTIONS,
  RECEIVING_ENTITY_TYPE_OPTIONS,
  DECISION_SCORE_OPTIONS,
  DECISION_TYPE_OPTIONS,
  VERIFIED_BY_OPTIONS,
  CREATION_SOURCE_OPTIONS,
} from "../../constants";
import { RulesFormQuery } from "../../../generated/dashboard/graphqlSchema";
import ReduxInputField from "../../../common/deprecated_redux/ReduxInputField";
import { CurrencyInput, SelectField } from "../../../common/ui-components";
import CreatedByUserFieldValueInput from "./CreatedByUserFieldValueInput";
import OriginatingAccountFieldValueInput from
"./OriginatingAccountFieldValueInput";
import MetadataFieldValueInput from "./MetadataFieldValueInput";
import PaymentTypeFieldValueInput from "./PaymentTypeFieldValueInput";
import {
  RuleValue,
  UIRuleData,
} from "../../types/RuleConditionFieldValueInput";
import { RuleFormValues } from "../../constants/rule_form";

const FIELD_TYPE_OPTIONS_MAPPING = {
  direction: DIRECTION_OPTIONS,
  creation_source: CREATION_SOURCE_OPTIONS,
  verified_by: VERIFIED_BY_OPTIONS,
  receiving_entity_type: RECEIVING_ENTITY_TYPE_OPTIONS,
  decision_score: DECISION_SCORE_OPTIONS,
  decision_type: DECISION_TYPE_OPTIONS,
};

/**
 * Component for a rule condition's value.
 */
function RuleConditionFieldValueInput({
  rule,
  id,
  dataIndex,
  operator,
  conditionKey,
  queryData,
  loading,
  setRule,
}: {
  id: string | null;
  conditionKey: string;
  dataIndex: number;
  operator: string;
  rule: RuleFormValues;
  queryData: RulesFormQuery | undefined;
  loading: boolean;
  setRule: (rule: RuleFormValues) => void;
}): JSX.Element {
  const userEntities = loading || !queryData ? [] : queryData.usersUnpaginated;
  const internalAccountsById =
    loading || !queryData
      ? []
      : queryData.internalAccountsUnpaginated.reduce(
          (acc, account) => ({ ...acc, [account.id]: account }),
          {},
        );

  function mapBasicOptions(
    optionsList: Record<string, string | null>[],
  ): Record<string, string | null>[] {
    return optionsList.map((opt) => ({
      ...opt,
      key: conditionKey,
      operator,
      id,
    }));
  }

  function onMetadataChange(data: Record<string, Record<string, string>>) {
    const metadata = data?.metadata
      ? Object.entries(data.metadata).map(([key, value]) => ({
          key,
          value,
        }))
      : undefined;
    const key = "metadata_keys_and_values";
    const newRule = {
      ...rule,
      data: {
        ...rule.data,
        [key]: {
          [operator]: metadata,
        },
      },
    };

    setRule(newRule);
  }

  function onMultiFieldChange(
    _value: string[],
    field: { key: string; operator: string; value: string },
    actionName: string,
  ) {
    const { key } = field;
    const currentValue: Array<string> = (rule.data as UIRuleData)[key][
      operator
    ] as Array<string>;

    let newValue: Array<string>;
    if (actionName === "remove-value") {
      newValue = currentValue
        ? currentValue.filter((v) => v !== field.value)
        : [];
    } else {
      newValue = currentValue ? [...currentValue, field.value] : [field.value];
    }
    const newRule = {
      ...rule,
      data: {
        ...rule.data,
        [key]: {
          [operator]: newValue,
        },
      },
    };

    setRule(newRule);
  }

  function onSingleFieldChange(
    value: string,
    field: { key: string; operator: string },
  ) {
    const { key } = field;
    const newRule = {
      ...rule,
      data: {
        ...rule.data,
        [key]: {
          [operator]: value,
        },
      },
    };

    setRule(newRule);
  }

  function handleAmountChange(value: string, key: string) {
    const decimalValue = parseFloat(value.replace(/,/g, "")) * 100;
    const newRule = {
      ...rule,
      data: {
        ...rule.data,
        [key]: {
          [operator]: decimalValue,
        },
      },
    };

    setRule(newRule);
  }

  function getInputComponent(): JSX.Element {
    if (isNil(conditionKey) || isNil(operator)) {
      return <ReduxInputField placeholder="Value" disabled />;
    }

    const currentValue: RuleValue = (rule.data as UIRuleData)[conditionKey]?.[
      operator
    ];

    switch (conditionKey) {
      case "metadata_keys_and_values":
        return (
          <MetadataFieldValueInput
            currentValue={currentValue}
            onMetadataChange={onMetadataChange}
          />
        );
      case "payment_type":
        return (
          <PaymentTypeFieldValueInput
            id={id}
            dataIndex={dataIndex}
            operator={operator}
            conditionKey={conditionKey}
            currentValue={currentValue}
            onSingleFieldChange={onSingleFieldChange}
          />
        );
      case "originating_account_id":
        return (
          <OriginatingAccountFieldValueInput
            id={id}
            dataIndex={dataIndex}
            operator={operator}
            conditionKey={conditionKey}
            currentValue={currentValue}
            internalAccountsById={internalAccountsById}
            onMultiFieldChange={onMultiFieldChange}
          />
        );
      case "amount":
        return (
          <CurrencyInput
            id="amount-field"
            required
            input={{
              value:
                currentValue !== null ? (currentValue as number) / 100 : "",
              onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
                handleAmountChange(e.target.value, conditionKey),
              "data-id": id,
              "data-key": conditionKey,
              "data-operator": operator,
            }}
          />
        );
      case "created_by_user":
        return (
          <CreatedByUserFieldValueInput
            id={id}
            dataIndex={dataIndex}
            operator={operator}
            conditionKey={conditionKey}
            currentValue={currentValue}
            userEntities={userEntities}
            onSingleFieldChange={onSingleFieldChange}
            onMultiFieldChange={onMultiFieldChange}
          />
        );
      case "direction":
      case "creation_source":
      case "verified_by":
      case "receiving_entity_type":
      case "decision_score":
      case "decision_type":
        // fall through
        return (
          <SelectField
            required
            options={mapBasicOptions(FIELD_TYPE_OPTIONS_MAPPING[conditionKey])}
            name={`value_${dataIndex}`}
            selectValue={currentValue}
            handleChange={onSingleFieldChange}
          />
        );
      default:
        return <ReduxInputField placeholder="Value" disabled />;
    }
  }

  return getInputComponent();
}

export default RuleConditionFieldValueInput;
```

---
## `rules/RuleConditionSection.tsx.txt`
**Path:** `rules`  
```
import React from "react";
import isNil from "lodash/isNil";
import isEmpty from "lodash/isEmpty";
import pickBy from "lodash/pickBy";

import {
  RULE_KEY_MAPPING,
  RULE_OPERATOR_MAPPING,
  NEGATED_RULE_OPERATOR_MAPPING,
} from "../../constants";
import {
  RulePrimitivesEnum,
  RuleResourceTypeEnum,
  RulesFormQuery,
} from "../../../generated/dashboard/graphqlSchema";
import {
  UIRuleData,
  RuleValue,
} from "../../types/RuleConditionFieldValueInput";
import {
  Button,
  Heading,
  Icon,
  SelectField,
} from "../../../common/ui-components";
import RuleConditionFieldValueInput from "./RuleConditionFieldValueInput";
import { RuleFormValues } from "../../constants/rule_form";

type OperatorFieldOption = {
  id: string | null;
  key: string;
  value: string;
  label: string;
  operator?: string;
};

const NEW_CONDITION_KEY = "newCondition";

function RuleConditionSection({
  id,
  rule,
  queryData,
  resourceType,
  loading,
  setRule,
}: {
  id: string | null;
  rule: RuleFormValues;
  queryData: RulesFormQuery | undefined;
  resourceType: RuleResourceTypeEnum;
  loading: boolean;
  setRule: (rule: RuleFormValues) => void;
}): JSX.Element {
  const dataKeys = Object.keys(rule.data as Record<string, never>);
  if (isEmpty(dataKeys)) {
    dataKeys.push("");
  }

  function operatorFields(key: string): Array<OperatorFieldOption> {
    const options: Array<OperatorFieldOption> = [];

    function addOption(operator: string) {
      options.push({
        value: operator,
        label: RULE_OPERATOR_MAPPING[operator],
        id,
        key,
      });
      options.push({
        value: `not_${operator}`,
        label: NEGATED_RULE_OPERATOR_MAPPING[operator],
        id,
        key,
      });
    }

    switch (key) {
      case "metadata_keys_and_values":
        addOption(RulePrimitivesEnum.Contains);
        break;
      case "originating_account_id":
        addOption(RulePrimitivesEnum.In);
        break;
      case "amount":
        addOption(RulePrimitivesEnum.LessThan);
        addOption(RulePrimitivesEnum.GreaterThan);
        break;
      case "created_by_user":
        addOption(RulePrimitivesEnum.In);
        if (resourceType === "PaymentOrder") {
          addOption(RulePrimitivesEnum.Eql);
        }
        break;
      case "payment_type":
      case "direction":
      case "creation_source":
      case "verified_by":
      case "receiving_entity_type":
      case "decision_score":
      case "decision_type":
        // fall through
        addOption(RulePrimitivesEnum.Eql);
        break;
      default:
        break;
    }

    return options;
  }

  function getDataOperator(ruleInput: RuleFormValues, key: string) {
    if (isEmpty(ruleInput.data) || isNil(key)) {
      return "";
    }
    return Object.keys((ruleInput.data as UIRuleData)[key])[0] || "";
  }

  function onDataKeySelected(key: string, field: { currentValue: RuleValue }) {
    const { currentValue } = field;

    const newRule = {
      ...rule,
      data: {
        ...pickBy(rule.data, (v, k) => k !== currentValue),
        [key]: {},
      },
    };

    setRule(newRule);
  }

  function onOperatorSelected(operator, field: { key: string }) {
    const { key } = field;
    const newRule = {
      ...rule,
      data: {
        ...rule.data,
        [key]: {
          [operator]: undefined,
        },
      },
    };

    setRule(newRule);
  }

  function removeRuleCondition(key) {
    const newData = pickBy(rule.data, (v, k) => k !== key);
    const newRule = {
      ...rule,
      data: newData,
    };

    setRule(newRule);
  }

  function addNewRuleCondition() {
    const newData = {
      ...pickBy(rule.data, (v, k) => k !== NEW_CONDITION_KEY),
      [NEW_CONDITION_KEY]: {},
    };
    const newRule = {
      ...rule,
      data: newData,
    };
    setRule(newRule);
  }

  return (
    <div className="form-section">
      <Heading level="h3">Conditions</Heading>
      {dataKeys.map((key, dataIndex) => {
        const keyOptions = Object.entries(RULE_KEY_MAPPING[rule.resourceType])
          .map(([value, label]) => ({
            value,
            label,
            id,
            currentValue: key,
          }))
          .filter(
            (keyOption) =>
              !dataKeys.includes(keyOption.value) || key === keyOption.value,
          );

        return (
          <div key={key} className="form-row flex">
            <SelectField
              required
              classes="key-field"
              name={`key_${dataIndex}`}
              handleChange={onDataKeySelected}
              options={keyOptions}
              selectValue={key}
              placeholder="Field"
            />
            <SelectField
              required
              name={`operator_${dataIndex}`}
              classes="operator-field"
              disabled={isNil(key) || key === "undefined"}
              handleChange={onOperatorSelected}
              selectValue={getDataOperator(rule, key)}
              placeholder="Operator"
              options={operatorFields(key)}
            />
            <RuleConditionFieldValueInput
              id={id}
              conditionKey={key}
              rule={rule}
              operator={getDataOperator(rule, key)}
              queryData={queryData}
              dataIndex={dataIndex}
              loading={loading}
              setRule={setRule}
            />

            <Button
              id="remove-rule-condition-btn"
              onClick={() => removeRuleCondition(key)}
            >
              <Icon
                iconName="clear"
                size="xs"
                color="currentColor"
                className="text-gray-300"
              />
            </Button>
          </div>
        );
      })}
      <Button
        onClick={() => addNewRuleCondition()}
        disabled={
          !Object.keys(rule.data).length ||
          Object.keys(rule.data).includes(NEW_CONDITION_KEY)
        }
      >
        <Icon iconName="add" />
        <span>Add Condition</span>
      </Button>
    </div>
  );
}

export default RuleConditionSection;
```

---
## `search/AccountSearch.jsx.txt`
**Path:** `search`  
```
import React from "react";
import AccountSelect from "../../containers/AccountSelect";
import { ALL_ACCOUNTS_ID } from "../../constants/index";

function AccountSearch({ field, label, query, updateQuery }) {
  const accountId = query[field];

  function onAccountSelect(newValue) {
    if (newValue === ALL_ACCOUNTS_ID) {
      updateQuery({ [field]: null });
    } else {
      updateQuery({ [field]: newValue });
    }
  }

  return (
    <AccountSelect
      onAccountSelect={onAccountSelect}
      accountId={accountId}
      label={label}
    />
  );
}

export default AccountSearch;
```

---
## `search/AmountSearch.jsx.txt`
**Path:** `search`  
```
import React from "react";

import sanitizeAmount from "../../../common/utilities/sanitizeAmount";
import {
  CurrencyInput,
  FieldGroup,
  Label,
} from "../../../common/ui-components";

function AmountSearch({
  field,
  disabled,
  query,
  updateQuery,
  operator,
  label,
  allowNegative,
  placeholder,
  exponent = 2,
}) {
  let value;
  const queryField = query[field];

  if (queryField && queryField[operator]) {
    value = queryField[operator] / 10 ** exponent;
  }

  function onChange(event) {
    let newValue;
    if (allowNegative && event.target.value === "-") {
      newValue = null;
    } else {
      newValue = event.target.value
        ? sanitizeAmount(event.target.value, exponent)
        : null;
    }

    updateQuery({
      [field]: {
        ...queryField,
        [operator]: newValue,
      },
    });
  }

  return (
    <FieldGroup>
      <Label id={`${field}[${operator}]`}>{label}</Label>
      <CurrencyInput
        required
        disabled={disabled}
        id="amount-field"
        input={{
          value,
          onChange,
          name: `${field}[${operator}]`,
        }}
        allowNegative={allowNegative}
        placeholder={placeholder}
        decimalScale={exponent}
      />
    </FieldGroup>
  );
}

export default AmountSearch;
```

---
## `search/ApiKeySearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import ApiKeySelect, { ALL_API_KEYS_ID } from "../../containers/ApiKeySelect";

interface ApiKeySearchProps {
  updateQuery: (input: Query) => void;
  field: string;
  query: Query;
  disabled?: boolean;
}

function ApiKeySearch({
  updateQuery,
  field,
  query,
  disabled = false,
}: ApiKeySearchProps) {
  const apiKeyId = query[field] as string;

  function onApiKeySelect(newValue: string) {
    if (newValue === ALL_API_KEYS_ID) {
      updateQuery({ [field]: null });
    } else {
      updateQuery({ [field]: newValue });
    }
  }

  return (
    <ApiKeySelect
      overrideOnApiKeySelect={onApiKeySelect}
      overrideCurrentApiKeyId={apiKeyId}
      hideLabel={false}
      disabled={disabled}
    />
  );
}

export default ApiKeySearch;
```

---
## `search/AutosuggestTextSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import {
  Autosuggest,
  Suggestion,
  FieldGroup,
  Label,
} from "../../../common/ui-components";

interface AutosuggestTextSearchProps {
  updateQuery: (query: unknown) => void;
  query: { [key: string]: unknown };
  field: string;
  suggestions: Array<Suggestion>;
  label?: string;
  placeholder?: string;
  helpText?: string;
  disabled?: boolean;
}

/**
 * A Text Search that has basic autosuggest based on given static array of
 suggestions.
 */
function AutosuggestTextSearch({
  updateQuery,
  query,
  field,
  suggestions,
  label,
  placeholder,
  helpText,
  disabled,
}: AutosuggestTextSearchProps) {
  const matchingSuggestion = suggestions.find(
    (suggestion) => suggestion.value === query[field],
  );
  const value = matchingSuggestion?.label || (query[field] as string) || "";

  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    updateQuery({
      [field]: e.target.value,
    });
  };

  const onSuggestionSelect = (
    _event,
    selection: { suggestionValue: string },
  ) => {
    updateQuery({
      [field]: selection.suggestionValue,
    });
  };

  return (
    <FieldGroup>
      <Label id={label} helpText={helpText}>
        {label}
      </Label>
      <div>
        <Autosuggest
          onChange={onChange}
          className="mr-3"
          onSuggestionSelect={onSuggestionSelect}
          value={value}
          field={field}
          suggestions={suggestions}
          placeholder={placeholder}
          disabled={disabled}
        />
      </div>
    </FieldGroup>
  );
}

export default AutosuggestTextSearch;
```

---
## `search/BooleanSearch.jsx.txt`
**Path:** `search`  
```
import React from "react";
import ReduxCheckbox from "../../../common/deprecated_redux/ReduxCheckbox";
import { FieldGroup, Label } from "../../../common/ui-components";

export default function BooleanSearch({
  field,
  query,
  updateQuery,
  label,
  labelId = "label-id",
  disabled,
}) {
  const checked = !!query[field] && query[field] !== "false";

  function onChange() {
    updateQuery({ [field]: !checked });
  }

  return (
    <div className="flex self-start">
      <FieldGroup direction="right-to-left">
        <Label id={labelId} disabled={disabled}>
          {label}
        </Label>
        <ReduxCheckbox
          id={labelId}
          input={{
            onChange,
            checked,
          }}
          disabled={disabled}
        />
      </FieldGroup>
    </div>
  );
}
```

---
## `search/ButtonTextSearch.tsx.txt`
**Path:** `search`  
```
import React, { useCallback, useState, useRef } from "react";
import { Button, Icon, Input } from "../../../common/ui-components";

interface QueryType {
  page?: number;
  perPage?: number;
  paginationDirection?: "next" | "previous";
  startCursor?: string;
  endCursor?: string;
  [key: string]: unknown;
  placeHolderTextSize?: "text-xs" | "text-sm";
}

interface ButtonTextSearchProps {
  updateQuery: (input: Record<string, unknown>) => void;
  field: string;
  query: QueryType;
  buttonText?: string;
  placeholder?: string;
  disabled?: boolean;
  showSearchBarAtStart?: boolean;
  hideSearchBarOnClear?: boolean;
  placeHolderTextSize?: QueryType["placeHolderTextSize"];
}

function ButtonTextSearch({
  updateQuery,
  field,
  query,
  buttonText,
  placeholder,
  disabled,
  showSearchBarAtStart = false,
  hideSearchBarOnClear = true,
  placeHolderTextSize = "text-sm",
}: ButtonTextSearchProps) {
  const value = query[field] as string;
  const [showSearchBar, setShowSearchBar] = useState<boolean>(
    Boolean(value) || showSearchBarAtStart,
  );
  const searchInputRef = useRef<HTMLInputElement>(null);

  function setSearchValue(searchValue: string) {
    updateQuery({
      [field]: searchValue,
    });
  }

  // We need to wait one tick for the input to be visible in the DOM
  const handleSearchButtonClick = useCallback(
    () =>
      setTimeout(() => {
        setShowSearchBar(true);
        searchInputRef.current?.focus();
      }),
    [],
  );

  return (
    <div className="flex flex-wrap justify-between">
      <div className="flex">
        {showSearchBar ? (
          <div className="relative w-96">
            <Input
              placeholder={placeholder}
              value={value}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                setSearchValue(e.target.value)
              }
              prefixIconName="search"
              ref={searchInputRef}
              suffixIconName="clear"
              onSuffixIconClick={
                disabled
                  ? undefined
                  : () => {
                      if (value) {
                        setSearchValue("");
                      }
                      if (hideSearchBarOnClear) {
                        setShowSearchBar(false);
                      }
                    }
              }
              className={`placeholder:${placeHolderTextSize}`}
              name={field}
              disabled={disabled}
            />
          </div>
        ) : (
          <Button onClick={handleSearchButtonClick} disabled={disabled}>
            <Icon
              iconName="search"
              color="currentColor"
              className="text-gray-600"
            />
            <span className="font-medium">{buttonText}</span>
          </Button>
        )}
      </div>
    </div>
  );
}

export default ButtonTextSearch;
```

---
## `search/ChoiceSearch.jsx.txt`
**Path:** `search`  
```
import React from "react";
import { FieldGroup, Label, SelectField } from "../../../common/ui-components";

export default function ChoiceSearch({
  field,
  query,
  updateQuery,
  label,
  options,
  disabled,
  isClearable = true,
  defaultValue,
}) {
  const queryField = query[field];

  function onChange(value) {
    updateQuery({
      [field]: value,
    });
  }

  return (
    <FieldGroup direction="top-to-bottom">
      <Label id={field}>{label}</Label>
      <SelectField
        classes="w-72"
        isClearable={isClearable}
        required
        disabled={disabled}
        name={field}
        handleChange={onChange}
        options={options}
        selectValue={queryField || defaultValue}
      />
    </FieldGroup>
  );
}
```

---
## `search/CounterpartySearch.jsx.txt`
**Path:** `search`  
```
import React from "react";
import CounterpartySelect from "../../containers/CounterpartySelect";

function CounterpartySearch({ field, disabled, query, updateQuery, label }) {
  function onChange(value) {
    updateQuery({ [field]: value });
  }

  return (
    <CounterpartySelect
      label={label}
      name={field}
      onChange={onChange}
      counterpartyId={query[field]}
      disabled={disabled}
    />
  );
}

CounterpartySearch.defaultProps = {
  label: "Counterparty",
};

export default CounterpartySearch;
```

---
## `search/DateSearch.tsx.txt`
**Path:** `search`  
```
import React, { useState } from "react";
import moment from "moment";
import { isEqual } from "lodash";
import useUserTimezone from "../../../common/utilities/useUserTimezone";
import {
  DateFilterInput,
  TimeUnitEnum,
} from "../../../generated/dashboard/graphqlSchema";
import DateRangeSelectField, {
  DateRangeFormValues,
  DateRangeSelectFieldProps,
  Option,
} from "../../../common/ui-
components/DateRangeSelectField/DateRangeSelectField";
import { format } from "../../../common/ui-
components/DateRangePicker/DateRangePicker";

const ALL_TIME = {
  value: "allTime",
  label: "All Time",
  dateRange: {
    inTheLast: null,
    inTheNext: null,
  },
};

const NEXT_WEEK = {
  value: "nextWeek",
  label: "Next Week",
  dateRange: {
    inTheLast: null,
    inTheNext: { unit: TimeUnitEnum.Weeks, amount: "1" },
  },
};

const PAST_WEEK = {
  value: "pastWeek",
  label: "Past Week",
  dateRange: {
    inTheLast: { unit: TimeUnitEnum.Weeks, amount: "1" },
    inTheNext: null,
  },
};

const PAST_MONTH = {
  value: "pastMonth",
  label: "Past Month",
  dateRange: {
    inTheLast: { unit: TimeUnitEnum.Months, amount: "1" },
    inTheNext: null,
  },
};

const PAST_QUARTER = {
  value: "pastQuarter",
  label: "Past Quarter",
  dateRange: {
    inTheLast: { unit: TimeUnitEnum.Months, amount: "3" },
    inTheNext: null,
  },
};

const PAST_YEAR = {
  value: "pastYear",
  label: "Past Year",
  dateRange: {
    inTheLast: { unit: TimeUnitEnum.Years, amount: "1" },
    inTheNext: null,
  },
};

const PAST_DAY = {
  value: "pastDay",
  label: "Past Day",
  dateRange: {
    inTheLast: { unit: TimeUnitEnum.Days, amount: "1" },
    inTheNext: null,
  },
};

export const DATE_SEARCH_FILTER_OPTIONS = [
  ALL_TIME,
  NEXT_WEEK,
  PAST_DAY,
  PAST_WEEK,
  PAST_MONTH,
  PAST_QUARTER,
  PAST_YEAR,
];

export const DATE_SEARCH_FILTER_OPTIONS_WITHOUT_FUTURE = [
  ALL_TIME,
  PAST_WEEK,
  PAST_MONTH,
  PAST_QUARTER,
  PAST_YEAR,
];

interface DateSearchProps {
  anchorOrigin?: DateRangeSelectFieldProps["anchorOrigin"];
  field: string;
  updateQuery: (input: Record<string, DateRangeFormValues>) => void;
  options: Option[];
  minDate?: string;
  maxDate?: string;
  label?: string;
  disabled?: boolean;
  validateRange?: boolean;
  dateTimeType?: boolean;
  query?: Record<string, DateRangeFormValues>;
  /** allows for ability change label without changing the date range
   *  used for global filter, when a child filter changes, change the label
   */
  defaultLabel?: string;
  setGlobalDateFilterLabel?: () => void;
  showIcon?: boolean;
  autoWidth?: boolean;
  showStartAndEndDateArrow?: boolean;
}

const toLocalTimestamp = (
  date: string | undefined,
  dateRange: "start" | "end",
) => {
  if (date === undefined) return date;

  return dateRange === "start"
    ? moment(date).startOf("day").format()
    : moment(date).endOf("day").format();
};

export function dateSearchMapper(
  dateRange: DateRangeFormValues | undefined,
  transformToTimestamp = false,
): DateFilterInput {
  if (!dateRange) return {};
  const inTheLast = {
    unit: dateRange.inTheLast?.unit,
    amount: parseInt(dateRange.inTheLast?.amount || "", 10),
  };
  const inTheNext = {
    unit: dateRange.inTheNext?.unit,
    amount: parseInt(dateRange.inTheNext?.amount || "", 10),
  };
  if (dateRange.inTheLast) {
    return {
      gte: transformToTimestamp
        ? toLocalTimestamp(dateRange.gte, "start")
        : dateRange.gte,
      lte: transformToTimestamp
        ? toLocalTimestamp(dateRange.lte, "end")
        : dateRange.lte,
      inTheLast,
      format: dateRange.format,
    };
  }
  if (dateRange.inTheNext) {
    return {
      gte: transformToTimestamp
        ? toLocalTimestamp(dateRange.gte, "start")
        : dateRange.gte,
      lte: transformToTimestamp
        ? toLocalTimestamp(dateRange.lte, "end")
        : dateRange.lte,
      inTheNext,
      format: dateRange.format,
    };
  }
  return {
    gte: transformToTimestamp
      ? toLocalTimestamp(dateRange.gte, "start")
      : dateRange.gte,
    lte: transformToTimestamp
      ? toLocalTimestamp(dateRange.lte, "end")
      : dateRange.lte,
    format: dateRange.format,
  };
}
// Extract selected relative date option from the query (inTheLast or inTheNext
must be populated).
function matchingOption(
  option: Option,
  query: Record<string, DateRangeFormValues>,
  field: string,
) {
  if (query && query[field] && option.value !== "allTime") {
    const relativeOperator = option.dateRange.inTheLast
      ? "inTheLast"
      : "inTheNext";

    return (
      option.dateRange[relativeOperator]?.amount ===
        query[field][relativeOperator]?.amount &&
      option.dateRange[relativeOperator]?.unit ===
        query[field][relativeOperator]?.unit
    );
  }
  return false;
}

function DateSearch({
  anchorOrigin,
  field,
  updateQuery,
  minDate,
  maxDate,
  options,
  disabled,
  validateRange,
  dateTimeType,
  label,
  query,
  defaultLabel,
  setGlobalDateFilterLabel,
  showIcon = false,
  autoWidth = false,
  showStartAndEndDateArrow = true,
}: DateSearchProps) {
  /** value is used to detect if there have been changes in the input that
  require a requery, it is initialized from
  query string if there is one */
  const [value, setValue] = useState(
    query
      ? {
          gte: format(query[field]?.gte),
          lte: format(query[field]?.lte),
          inTheLast: query[field]?.inTheLast,
          inTheNext: query[field]?.inTheNext,
        }
      : { gte: "", lte: "", inTheLast: null, inTheNext: null },
  );
  let initialSelected: string | undefined;
  const userTimeZone = useUserTimezone();

  if (query && (query[field]?.inTheLast || query[field]?.inTheNext)) {
    initialSelected = options.find((option) =>
      matchingOption(option, query, field),
    )?.label;
  }
  // The onChange updatesQuery when the fields have changed
  function onChange(dateRange: DateRangeFormValues): void {
    let startDate: Date | string | undefined = dateRange.gte;
    let endDate: Date | string | undefined = dateRange.lte;
    // Allows timestamps
    if (dateTimeType) {
      startDate = startDate
        ? moment
            .tz(startDate, userTimeZone)
            .startOf("day")
            .toDate()
            .toISOString()
        : undefined;
      endDate = endDate
        ? moment.tz(endDate, userTimeZone).endOf("day").toDate().toISOString()
        : undefined;
    }
    if (
      value.gte !== dateRange.gte ||
      value.lte !== dateRange.lte ||
      (dateRange.inTheLast && !isEqual(value.inTheLast, dateRange.inTheLast)) ||
      (dateRange.inTheNext && !isEqual(value.inTheNext, dateRange.inTheNext))
    ) {
      if (Object.keys(dateRange).length > 0) {
        updateQuery({
          [field]: {
            ...dateRange,
            gte: startDate || undefined,
            lte: endDate || undefined,
          },
        });
      }
    }
    if (setGlobalDateFilterLabel) setGlobalDateFilterLabel();
    setValue({
      gte: dateRange.gte || "",
      lte: dateRange.lte || "",
      inTheLast: dateRange.inTheLast || null,
      inTheNext: dateRange.inTheNext || null,
    });
  }

  return (
    <DateRangeSelectField
      anchorOrigin={anchorOrigin}
      fieldLabel={label}
      options={options}
      initialSelected={initialSelected}
      onChange={onChange}
      initialValues={{ gte: value.gte, lte: value.lte }}
      minDate={minDate}
      validateRange={validateRange}
      maxDate={maxDate}
      disabled={disabled}
      defaultLabel={defaultLabel}
      showIcon={showIcon}
      autoWidth={autoWidth}
      showStartAndEndDateArrow={showStartAndEndDateArrow}
    />
  );
}

export default DateSearch;
```

---
## `search/DateSearchJS.jsx.txt`
**Path:** `search`  
```
import React from "react";
import moment from "moment-timezone";
import {
  formatLocalDate,
  formatISODateTime,
  parseISOLocalDate,
  parseISODateTime,
} from "../../../common/utilities/formatDate";

import useUserTimezone from "../../../common/utilities/useUserTimezone";
import { DatePicker as ModernDatePicker } from "../../../common/ui-components";

function DateSearchJS({
  field,
  query,
  updateQuery,
  operator,
  label,
  minDate,
  maxDate,
  dateType,
  dateTimeType,
  disabled,
  prefix,
}) {
  let value;
  const queryField = query[field] || {};
  const userTimeZone = useUserTimezone();

  if (queryField[operator]) {
    value = queryField[operator];
  }

  function onChange(newDate) {
    updateQuery({
      [field]: {
        ...queryField,
        [operator]: newDate,
      },
    });
  }

  const minimumDate = maxDate ? null : queryField[minDate];
  const maximumDate = minDate ? null : queryField[maxDate];

  function formatISODateTimeInclusive(dateTimeValue) {
    // set to the end of the day if lte and dateTime
    // so we include times in the current day.
    let eodDateTime = dateTimeValue;
    if (eodDateTime && operator === "lte" && dateTimeType) {
      eodDateTime = moment
        .tz(dateTimeValue, userTimeZone)
        .endOf("day")
        .toDate();
    }
    return formatISODateTime(eodDateTime);
  }

  return (
    <ModernDatePicker
      required
      disabled={disabled}
      label={label}
      minDate={minimumDate}
      maxDate={maximumDate}
      input={{
        value,
        onChange,
        name: `${field}[${operator}]`,
      }}
      dateFormatter={
        (dateType && formatLocalDate) ||
        (dateTimeType && formatISODateTimeInclusive) ||
        null
      }
      dateParser={
        (dateType && parseISOLocalDate) ||
        (dateTimeType && parseISODateTime) ||
        null
      }
      prefix={prefix}
    />
  );
}

export default DateSearchJS;
```

---
## `search/FavoritesButtonSearch.tsx.txt`
**Path:** `search`  
```
import React, { useState } from "react";
import { Button, Icon } from "~/common/ui-components";
import { SHOW_FAVORITES } from "~/common/constants/analytics";
import trackEvent from "../../../common/utilities/trackEvent";

interface QueryType {
  favoritesOnly: "true" | "false";
}

interface FavoritesButtonSearchProps {
  disabled: boolean;
  query: QueryType;
  updateQuery: (input: Record<string, unknown>) => void;
}

const { SHOW_FAVORITES_CLICKED, SHOW_FAVORITES_UNCLICKED } = SHOW_FAVORITES;

export default function FavoritesButtonSearch({
  disabled,
  query,
  updateQuery,
}: FavoritesButtonSearchProps) {
  const [selected, setSelected] = useState<boolean>(
    JSON.parse(query.favoritesOnly || "false") as boolean,
  );

  return (
    <div className="flex self-start">
      <Button
        onClick={() => {
          updateQuery({ favoritesOnly: !selected });
          setSelected(!selected);
          trackEvent(
            null,
            selected ? SHOW_FAVORITES_UNCLICKED : SHOW_FAVORITES_CLICKED,
          );
        }}
        disabled={disabled}
        hideFocusOutline
      >
        <Icon
          iconName={selected ? "star_outlined" : "star"}
          color="currentColor"
          className="text-gray-600"
        />
        <span className="font-medium">
          {selected ? "Show all" : "Show favorites"}
        </span>
      </Button>
    </div>
  );
}
```

---
## `search/KeyValueSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import KeyValueInput from "../KeyValueInput";

interface KeyValueSearchProps {
  updateQuery: (query: unknown) => void;
  query: { [key: string]: unknown };
  field: string;
  label: string;
  hideLabel?: boolean;
  disabled?: boolean;
  multiLines?: boolean;
}

/**
 * A Text Search that has basic autosuggest based on given static array of
 suggestions.
 */
function KeyValueSearch({
  updateQuery,
  query,
  field,
  label,
  hideLabel,
  disabled,
  multiLines,
}: KeyValueSearchProps) {
  const onChange = (metadata: Record<string, string>) => {
    updateQuery({
      [field]: Object.keys(metadata).length ? { ...metadata } : undefined,
    });
  };

  return (
    <KeyValueInput
      initialValues={query[field] as Record<string, string>}
      label={label}
      onChange={onChange}
      hideLabel={hideLabel}
      disabled={disabled}
      multiLines={multiLines}
      allowNoEntries={false}
      inlineAddButton
    />
  );
}

export default KeyValueSearch;
```

---
## `search/LedgerAccountSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import { useParams } from "react-router-dom";
import LedgerAccountSelect from "../../containers/LedgerAccountSelect";
import type { SelectValue } from "~/common/ui-components";
import type { LedgerTransactionQueryFilter } from
"~/common/search_components/ledgerTransactionSearchComponents";

interface LedgerAccountSearchProps {
  field: string;
  label?: string;
  updateQuery: (input: Query) => void;
  query: LedgerTransactionQueryFilter;
}

interface LedgersRouteParams {
  ledgerId: string;
}

function LedgerAccountSearch({
  field,
  label = "",
  updateQuery,
  query,
}: LedgerAccountSearchProps) {
  const { ledgerId } = useParams<LedgersRouteParams>();

  const onLedgerAccountSelect = (selectedOption: SelectValue) => {
    if (!selectedOption) {
      updateQuery({ [field]: undefined });
    } else {
      const selectedLedgerAccountId = String(selectedOption.value);
      updateQuery({ [field]: selectedLedgerAccountId });
    }
  };

  return (
    <LedgerAccountSelect
      onAccountSelect={onLedgerAccountSelect}
      ledgerId={ledgerId}
      label={label}
      selectedLedgerAccountId={query.ledger_account_id}
    />
  );
}

export default LedgerAccountSearch;
```

---
## `search/MetadataSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import MetadataInput from "../MetadataInput";
import { ResourcesEnum } from "../../../generated/dashboard/types/resources";

interface MetadataSearchProps {
  updateQuery: (query: unknown) => void;
  query: { [key: string]: unknown };
  field: string;
  resource: ResourcesEnum;
  hideLabel?: boolean;
  disabled?: boolean;
  multiLines?: boolean;
}

/**
 * A Text Search that has basic autosuggest based on given static array of
 suggestions.
 */
function MetadataSearch({
  updateQuery,
  query,
  field,
  resource,
  hideLabel,
  disabled,
  multiLines,
}: MetadataSearchProps) {
  const onChange = (metadata: Record<string, string>) => {
    updateQuery({
      [field]: Object.keys(metadata).length ? { ...metadata } : undefined,
    });
  };

  return (
    <MetadataInput
      initialValues={query[field] as Record<string, string>}
      onChange={onChange}
      resource={resource}
      hideLabel={hideLabel}
      disabled={disabled}
      multiLines={multiLines}
      allowNoEntries={false}
      alwaysDeleteOnRemove
      inlineAddButton
    />
  );
}

export default MetadataSearch;
```

---
## `search/MultiAccountGroupSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";

import { isEqual, without } from "lodash";

import { ALL_ACCOUNT_GROUPS_ID } from "../../constants";

import MultiChoiceSearch from "./MultiChoiceSearch";
import {
  SelectSimpleOption,
  useAccountGroupSelectOptionsQuery,
} from "../../../generated/dashboard/graphqlSchema";

interface QueryType {
  [key: string]: unknown;
}

interface MultiAccountGroupSearchProps {
  field: string;
  label: string;
  currencies?: Array<string>;
  query: QueryType;
  updateQuery: (input: Record<string, unknown>) => void;
  disabled: boolean;
}

function MultiAccountGroupSearch({
  field,
  label,
  currencies,
  query,
  updateQuery,
  disabled,
}: MultiAccountGroupSearchProps) {
  const currentAccountGroups: Array<string> = query[field] as Array<string>;

  const { data, loading, error } = useAccountGroupSelectOptionsQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      ...(currencies && currencies.length > 0 && { currencies }),
    },
  });

  const options = (
    loading || error || !data ? [] : data?.accountGroupSelectOptions || []
  ) as SelectSimpleOption[];

  return (
    <MultiChoiceSearch
      field={field}
      label={label}
      query={query}
      options={options}
      updateQuery={(input: Record<string, unknown>) => {
        const newAccountGroupIds = input[field] as Array<string>;
        let updatedAccountGroupIds = isEqual(newAccountGroupIds, [
          ALL_ACCOUNT_GROUPS_ID,
        ])
          ? newAccountGroupIds
          : without(newAccountGroupIds, ALL_ACCOUNT_GROUPS_ID);
        if (
          !currentAccountGroups.includes(ALL_ACCOUNT_GROUPS_ID) &&
          newAccountGroupIds.includes(ALL_ACCOUNT_GROUPS_ID)
        ) {
          updatedAccountGroupIds = [ALL_ACCOUNT_GROUPS_ID];
        }
        updateQuery({ [field]: updatedAccountGroupIds });
      }}
      disabled={disabled}
    />
  );
}

export default MultiAccountGroupSearch;
```

---
## `search/MultiAccountSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import MultiAccountSelect, {
  AllAccountsSelectionBehaviorEnum,
} from "../../containers/MultiAccountSelect";
import { ALL_ACCOUNTS_ID } from "../../constants/index";
import {
  MultiAccountSelectQuery,
  SelectGroupOption,
  SelectOption,
  SelectSimpleOption,
} from "../../../generated/dashboard/graphqlSchema";

interface QueryType {
  page?: number;
  perPage?: number;
  paginationDirection?: "next" | "previous";
  startCursor?: string;
  endCursor?: string;
  [key: string]: unknown;
}

interface MultiAccountSearchProps {
  field: string;
  label: string;
  query: QueryType;
  updateQuery: (input: Record<string, unknown>) => void;
  disabled: boolean;
  id?: string;
  showAllAccountsByDefault?: boolean;
  allAccountsSelectionBehavior?: AllAccountsSelectionBehaviorEnum;
  selectAllAccountsByDefault?: boolean;
}

// transforms array of nested select option objects into array of account ids
// type assertion is performed because value only exists on SelectSimpleOption
and options only on SelectGroupOption
const selectAllValuesFromOptions: (
  selectOptions: SelectOption[],
) => string[] = (selectOptions) =>
  selectOptions.reduce((accountIds: string[], selectOption: SelectOption) => {
    if (Object.prototype.hasOwnProperty.call(selectOption, "value")) {
      const optionValue = (selectOption as SelectSimpleOption).value;
      return accountIds.concat(
        optionValue === ALL_ACCOUNTS_ID ? [] : [optionValue],
      );
    }
    return accountIds.concat(
      selectAllValuesFromOptions((selectOption as SelectGroupOption).options),
    );
  }, []);

const shouldChooseOnlyTheSelectedValue = (
  existingValues: string[],
  selectedValue: string,
) =>
  !existingValues ||
  selectedValue === ALL_ACCOUNTS_ID ||
  existingValues.includes(ALL_ACCOUNTS_ID);

function MultiAccountSearch({
  field,
  label,
  query,
  updateQuery,
  disabled,
  id,
  showAllAccountsByDefault = false,
  allAccountsSelectionBehavior =
  AllAccountsSelectionBehaviorEnum.allAccountsKey,
  selectAllAccountsByDefault = true,
}: MultiAccountSearchProps) {
  const currentValue: Array<string> = query[field] as Array<string>;

  const onAccountSelect = (
    _value: string,
    selectField: { value: string; label: string },
    actionName: string,
    options: MultiAccountSelectQuery["multiAccountSelectOptions"],
  ) => {
    if (!selectField) return;

    let newValue: Array<string>;
    if (actionName === "remove-value") {
      newValue = currentValue
        ? currentValue.filter((v) => v !== selectField.value)
        : [];
    } else {
      /*
       * For actionName "select-option":
       * If no accounts are selected, select the one the user just picked.
       * 'All Accounts' is represented by ALL_ACCOUNTS_ID and is available when
       showAllAccountsByDefault is true.
       * If the All Accounts option is available....
       * If selectAllAccountsAsAllCurrentOptions is false:
       * Selecting 'All Accounts' will unselect any other already selected
       accounts.
       * If 'All Accounts' is currently selected, selecting another individual
       account will unselect it.
       * If selectAllAccountsAsAllCurrentOptions is true:
       * Selecting 'All Accounts' will act as if user selected all individual
       accounts
       */
      const shouldChooseAllValues =
        selectField.value === ALL_ACCOUNTS_ID &&
        allAccountsSelectionBehavior ===
          AllAccountsSelectionBehaviorEnum.selectAccounts;
      if (shouldChooseAllValues) {
        newValue = selectAllValuesFromOptions(options || []);
      } else {
        newValue = shouldChooseOnlyTheSelectedValue(
          currentValue,
          selectField.value,
        )
          ? [selectField.value]
          : [...currentValue, selectField.value];
      }
    }
    updateQuery({ [field]: newValue });
  };

  return (
    <MultiAccountSelect
      disabled={disabled}
      onAccountSelect={onAccountSelect}
      accountIds={currentValue}
      label={label}
      id={id}
      showAllAccountsByDefault={showAllAccountsByDefault}
      allAccountsSelectionBehavior={allAccountsSelectionBehavior}
      selectAllAccountsByDefault={selectAllAccountsByDefault}
    />
  );
}

export default MultiAccountSearch;
```

---
## `search/MultiChoiceSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import { FieldGroup, Label, SelectField } from "../../../common/ui-components";

interface QueryType {
  page?: number;
  perPage?: number;
  paginationDirection?: "next" | "previous";
  startCursor?: string;
  endCursor?: string;
  [key: string]: unknown;
}

interface MultiChoiceSearchProps {
  classes?: string;
  field: string;
  label: string;
  query: QueryType;
  options: { value: string; label: string }[];
  updateQuery: (input: Record<string, unknown>) => void;
  disabled: boolean;
}

export default function MultiChoiceSearch({
  classes,
  field,
  query,
  updateQuery,
  label,
  options,
  disabled,
}: MultiChoiceSearchProps) {
  const queryField: Array<string> = query[field] as Array<string>;

  const onChoiceSelect = (
    _value: string,
    selectField: { value: string; label: string },
    actionName: string,
  ) => {
    if (!selectField) return;

    let newValue: Array<string>;
    if (actionName === "remove-value") {
      newValue = queryField
        ? queryField.filter((v) => v !== selectField.value)
        : [];
    } else {
      newValue = !queryField
        ? [selectField.value]
        : [...queryField, selectField.value];
    }
    updateQuery({ [field]: newValue });
  };

  if (label) {
    return (
      <FieldGroup direction="top-to-bottom">
        <Label id={field}>{label}</Label>
        <SelectField
          classes={classes}
          isMulti
          isClearable={false}
          required
          disabled={disabled}
          name={field}
          handleChange={onChoiceSelect}
          options={options}
          selectValue={queryField}
        />
      </FieldGroup>
    );
  }

  return (
    <SelectField
      classes={classes}
      isMulti
      isClearable={false}
      required
      disabled={disabled}
      name={field}
      handleChange={onChoiceSelect}
      options={options}
      selectValue={queryField}
    />
  );
}
```

---
## `search/MultiConnectionSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";

import { isEqual, without } from "lodash";

import { ALL_CONNECTIONS_ID } from "../../constants";

import MultiChoiceSearch from "./MultiChoiceSearch";
import {
  SelectSimpleOption,
  useMultiConnectionSelectQuery,
} from "../../../generated/dashboard/graphqlSchema";

interface QueryType {
  [key: string]: unknown;
}

interface MultiConnectionSearchProps {
  classes?: string;
  field: string;
  label: string;
  currencies?: Array<string>;
  query: QueryType;
  updateQuery: (input: Record<string, unknown>) => void;
  disabled: boolean;
}

function MultiConnectionSearch({
  classes,
  field,
  label,
  currencies,
  query,
  updateQuery,
  disabled,
}: MultiConnectionSearchProps) {
  const currentConnections: Array<string> = query[field] as Array<string>;

  const { data, loading, error } = useMultiConnectionSelectQuery({
    notifyOnNetworkStatusChange: true,
    variables: {
      ...(currencies && currencies.length > 0 && { currencies }),
    },
  });

  const options = (
    loading || error || !data ? [] : data?.connectionSelectOptions || []
  ) as SelectSimpleOption[];

  return (
    <MultiChoiceSearch
      classes={classes}
      field={field}
      label={label}
      query={query}
      options={options}
      updateQuery={(input: Record<string, unknown>) => {
        const newConnectionIds = input[field] as Array<string>;
        let updatedConnectionIds = isEqual(newConnectionIds, [
          ALL_CONNECTIONS_ID,
        ])
          ? newConnectionIds
          : without(newConnectionIds, ALL_CONNECTIONS_ID);
        if (
          !currentConnections.includes(ALL_CONNECTIONS_ID) &&
          newConnectionIds.includes(ALL_CONNECTIONS_ID)
        ) {
          updatedConnectionIds = [ALL_CONNECTIONS_ID];
        }
        updateQuery({ [field]: updatedConnectionIds });
      }}
      disabled={disabled}
    />
  );
}

export default MultiConnectionSearch;
```

---
## `search/ReconciliationRuleAsyncSearch.tsx.txt`
**Path:** `search`  
```
import React, { useState } from "react";
import isNil from "lodash/isNil";
import { AsyncSelectField } from "~/common/ui-components";
import { SelectValue } from "~/common/ui-
components/AsyncSelectField/AsyncSelectField";
import { useReconciliationRuleAsyncSelectQuery } from
"~/generated/dashboard/graphqlSchema";

interface ReconciliationRuleAsyncSearchProps {
  updateQuery: (input: Record<string, unknown>) => void;
  query: { [key: string]: unknown };
  label: string;
  field: string;
  disabled: boolean;
}

function ReconciliationRuleAsyncSearch({
  query,
  updateQuery,
  label = "Reconciliation Rule",
  field,
  disabled = false,
}: ReconciliationRuleAsyncSearchProps) {
  const [options, setOptions] = useState<SelectValue[]>([]);
  const [isDataLoaded, setIsDataLoaded] = useState<boolean>(false);
  const { refetch } = useReconciliationRuleAsyncSelectQuery({
    skip: true,
  });
  const selectValue = query[field] as string;
  const selectLabel = query[`${field}_label`] as string;

  const loadOptions = (input: string) =>
    new Promise((resolve, reject) => {
      if (isDataLoaded) {
        const filteredOptions = options.filter((option) =>
          option.label.includes(input.toUpperCase()),
        );
        resolve({ options: filteredOptions });
      } else {
        refetch()
          .then(({ data }) => {
            const reconciliationRuleOptions =
              data?.reconciliationRules?.edges.map((edge) => ({
                value: edge?.node?.id,
                label: edge?.node?.name,
              }));
            setOptions(reconciliationRuleOptions);
            setIsDataLoaded(true);
            resolve({
              options: reconciliationRuleOptions,
            });
          })
          .catch((e) => reject(e));
      }
    });

  return (
    <AsyncSelectField
      isClearable
      defaultOptions={!isNil(selectValue)}
      loadOptions={loadOptions}
      handleChange={(option: SelectValue) =>
        updateQuery({
          [field]: option?.value,
          [`${field}_label`]: option?.label,
        })
      }
      selectValue={
        selectValue && selectLabel
          ? {
              value: selectValue,
              label: selectLabel,
            }
          : undefined
      }
      noOptionsMessage={(val) =>
        val.inputValue === "" ? "Type to see options" : "No options"
      }
      label={label}
      name={label}
      disabled={disabled}
    />
  );
}

export default ReconciliationRuleAsyncSearch;
```

---
## `search/ReviewAsGroupSearch.tsx.txt`
**Path:** `search`  
```
import React, { useEffect } from "react";
import {
  Group,
  useReviewAsGroupSelectQuery,
} from "../../../generated/dashboard/graphqlSchema";
import { FieldGroup, Label, SelectField } from "../../../common/ui-components";

const ADMIN_OVERRIDE = "ADMIN_OVERRIDE";
interface ReviewAsGroupSearchProps {
  field: string;
  updateQuery: (input: Record<string, unknown>) => void;
  placeholder: string;
  query: { [key: string]: unknown };
  label?: string;
  includeAdminOverride?: boolean;
}

function ReviewAsGroupSearch({
  field,
  updateQuery,
  placeholder,
  query,
  label,
  includeAdminOverride = false,
}: ReviewAsGroupSearchProps) {
  const queryField = query[field];
  const adminOverride = query.reviewAsAdminOverride === "true";
  const { data } = useReviewAsGroupSelectQuery();
  const groups = data?.currentUser.contextedGroupMemberships as Group[];
  const canAdminOverride = data?.currentOrganization.canReviewAll as boolean;

  const idToGroupName = new Map(groups?.map((group) => [group.id, group.name]));

  const options = groups?.map((group) => ({
    value: group.id,
    label: group.name,
  }));

  const { scopeByPendingMyApproval } = query;

  if (includeAdminOverride && canAdminOverride) {
    options?.push({ value: ADMIN_OVERRIDE, label: "Admin Override" });
  }

  useEffect((): void => {
    if (!scopeByPendingMyApproval && (queryField || adminOverride)) {
      updateQuery({
        [field]: null,
        reviewAsAdminOverride: "false",
        reviewAsGroupSelectedLabel: null,
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scopeByPendingMyApproval]);

  function setQuery(id?: string) {
    if (id === ADMIN_OVERRIDE) {
      updateQuery({
        [field]: null,
        reviewAsAdminOverride: "true",
        reviewAsGroupSelectedLabel: "Admin Override",
      });
    } else {
      updateQuery({
        [field]: id,
        reviewAsAdminOverride: "false",
        reviewAsGroupSelectedLabel: idToGroupName.get(id as string),
      });
    }
  }

  function onChange(id?: string) {
    setQuery(id);
  }

  function selectValue() {
    if (!adminOverride && !queryField && options?.length === 1) {
      const { value } = options[0];
      onChange(value);

      return value;
    }

    return adminOverride ? ADMIN_OVERRIDE : queryField;
  }

  return (
    <FieldGroup direction="top-to-bottom">
      <Label id={field}>{label}</Label>
      <SelectField
        isClearable
        required
        placeholder={placeholder}
        disabled={!options}
        name="reviewAsGroupSelect"
        id="reviewAsGroupSelect"
        handleChange={onChange}
        options={options || []}
        selectValue={selectValue()}
      />
    </FieldGroup>
  );
}

export default ReviewAsGroupSearch;
```

---
## `search/TextSearch.jsx.txt`
**Path:** `search`  
```
import React from "react";
import ReduxInputField from "../../../common/deprecated_redux/ReduxInputField";
import { FieldGroup, Label } from "../../../common/ui-components";

export default function TextSearch({
  updateQuery,
  field,
  query,
  label,
  placeholder,
  helpText,
  disabled,
}) {
  const value = query[field];

  function onChange(e) {
    updateQuery({
      [field]: e.target.value,
    });
  }

  return label !== undefined ? (
    <FieldGroup>
      <Label id={field} helpText={helpText}>
        {label}
      </Label>
      <ReduxInputField
        required
        disabled={disabled}
        classes="search-input"
        value={value}
        placeholder={placeholder}
        input={{
          onChange,
          value,
          name: field,
        }}
      />
    </FieldGroup>
  ) : (
    <ReduxInputField
      required
      disabled={disabled}
      classes="search-input"
      value={value}
      placeholder={placeholder}
      input={{
        onChange,
        value,
        name: field,
      }}
    />
  );
}
```

---
## `search/UserGroupSearch.tsx.txt`
**Path:** `search`  
```
import React from "react";
import { OrganizationUser } from "../../../generated/dashboard/graphqlSchema";
import UserGroupSelect from "../UserGroupSelect";

interface UserGroupSearchProps {
  field: string;
  updateQuery: (input: Record<string, unknown>) => void;
  placeholder: string;
  query: { [key: string]: unknown };
  label?: string;
}

function UserGroupSearch({
  field,
  updateQuery,
  placeholder,
  query,
  label,
}: UserGroupSearchProps) {
  const queryField = query[field] as string;
  const labelField = query.userGroupSelectedLabel as string;

  function onChange(value?: OrganizationUser) {
    updateQuery({
      [field]: value?.user.id,
      userGroupSelectedLabel: value
        ? `${value.user.name ?? ""} (${value.user.email})`
        : undefined,
    });
  }

  return (
    <UserGroupSelect
      placeholder={placeholder}
      onChange={onChange}
      selectValue={
        queryField && labelField
          ? {
              value: { user: { id: queryField } },
              label: labelField,
            }
          : undefined
      }
      label={label}
    />
  );
}

export default UserGroupSearch;
```

---
## `transaction_cash_flow/HistoricalCashFlowBarChart.tsx.txt`
**Path:** `transaction_cash_flow`  
```
import React from "react";
import {
  BarChart,
  ResponsiveContainer,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  Bar,
  ReferenceLine,
  LabelList,
  LabelProps,
  TooltipProps,
} from "recharts";
import abbreviateAmount from "../../../common/utilities/abbreviateAmount";
import colors from "../../../common/styles/colors";
import { CustomLegend } from "../../containers/account_groups/historical_balance
s_chart/HistoricalBalanceChartForGroupsUtils";
import { XAxisProps } from "../../../common/styles/cash_management/charts";

export type HistoricalCashFlowItem = {
  asOfDate?: string | null | undefined;
  prettyDirectionalInflow?: number | null | undefined;
  prettyDirectionalOutflow?: number | null | undefined;
  inflow?: number;
  outflow?: number;
};

export type HistoricalCashflowChartDataPoint = HistoricalCashFlowItem & {
  currency: string;
  dateShort: string;
  dateShortest: string;
};

const renderCustomizedLabel = (props: LabelProps) => {
  const { x, y, width, height, value } = props;

  if (!x || !y || !width || !height || !value) {
    return null;
  }
  // Don't show the label if we're below a certain height (a % of the container)
  if (height < 20 && height > -20) {
    return null;
  }

  // Pad the distance away from the Y-axis reference line
  const fromAxis = value < 0 ? 5 : -5;

  // This heuristic seems to work okay for the font size:
  // 1/4 of the width of the bar, with a min of 5 and max of 12
  const fontSize = Math.min(Math.max(Math.round(width / 4.0), 5), 12);

  return (
    <g>
      <text
        x={x + width / 2}
        y={y + height + fromAxis}
        fill="#1F2222"
        textAnchor="middle"
        dominantBaseline={value < 0 ? "hanging" : "auto"}
        fontSize={fontSize}
      >
        {abbreviateAmount(value, "USD")}
      </text>
    </g>
  );
};

export function tooltipFormatter(
  value: string | number | Array<string | number>,
  currency: string,
): string {
  if (typeof value === "string" || value instanceof Array) {
    return "N/A";
  }

  return Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(value);
}

interface CustomTooltipProps extends TooltipProps {
  categories: string[];
}

function CustomTooltip({ active, payload, categories }: CustomTooltipProps) {
  if (!active || !payload) return null;

  const data = payload[0].payload as HistoricalCashflowChartDataPoint;

  return (
    <div className="rounded-md border bg-white p-4 drop-shadow-md">
      <div className="flex flex-col gap-2">
        <div>
          {categories.map((category) => (
            <span className="flex flex-row gap-2 font-medium">
              {category}:
              <code>
                {Intl.NumberFormat("en-US", {
                  style: "currency",
                  currency: data.currency,
                }).format(data[`prettyDirectional${category}`] as bigint)}
              </code>
            </span>
          ))}
        </div>
        <code>{data.dateShort}</code>
      </div>
    </div>
  );
}

function getDateFormatKey(numTicks) {
  if (numTicks < 8) {
    return "dateLong";
  }

  if (numTicks === 8) {
    return "dateShort";
  }

  return "dateShortest";
}

export function HistoricalCashFlowBarChart({
  chartData,
}: {
  chartData: HistoricalCashflowChartDataPoint[];
}) {
  const currency = chartData[0]?.currency ?? "USD";

  return (
    <ResponsiveContainer width="100%" height={300}>
      <BarChart data={chartData} stackOffset="sign" height={300}>
        <XAxis
          dataKey={getDateFormatKey(chartData.length)}
          {...XAxisProps}
          interval={0}
        />
        <YAxis hide />
        <Tooltip
          cursor={{ fill: "#FAFAF9" }}
          formatter={(value) => tooltipFormatter(value, currency)}
          content={<CustomTooltip categories={["Inflow", "Outflow"]} />}
        />
        <Legend
          verticalAlign="bottom"
          align="left"
          iconSize={14}
          content={<CustomLegend />}
        />
        <ReferenceLine y={0} stroke={colors.gray["100"]} />
        <Bar
          dataKey="prettyDirectionalInflow"
          name="Inflow"
          fill={colors.categorical["7"]}
          stackId="stack"
          isAnimationActive={false}
          radius={[2, 2, 0, 0]}
        >
          <LabelList
            dataKey="prettyDirectionalInflow"
            content={renderCustomizedLabel}
          />
        </Bar>
        <Bar
          dataKey="prettyDirectionalOutflow"
          name="Outflow"
          fill={colors.qualitative.neutral}
          stackId="stack"
          isAnimationActive={false}
          radius={[2, 2, 0, 0]}
        >
          <LabelList
            dataKey="prettyDirectionalOutflow"
            content={renderCustomizedLabel}
          />
        </Bar>
      </BarChart>
    </ResponsiveContainer>
  );
}
```

---
## `transaction_cash_flow/HistoricalCashFlowChart.tsx.txt`
**Path:** `transaction_cash_flow`  
```
import React, { useEffect, useState } from "react";
import moment from "moment";
import { v4 } from "uuid";
import ChartView from "../../../common/ui-components/Charts/ChartView";
import { DateRangeFormValues } from "../../../common/ui-
components/DateRangeSelectField/DateRangeSelectField";
import { useHistoricalCashFlowQuery } from
"../../../generated/dashboard/graphqlSchema";
import DateSearch, { dateSearchMapper } from "../search/DateSearch";
import {
  HistoricalCashFlowBarChart,
  HistoricalCashFlowItem,
  HistoricalCashflowChartDataPoint,
} from "./HistoricalCashFlowBarChart";
import PlaceholderLineChart from "../PlaceholderLineChart";
import { ACCOUNT_DATE_RANGE_FILTER_OPTIONS } from
"../../containers/reconciliation/utils";
import trackEvent from "../../../common/utilities/trackEvent";
import { ACCOUNT_ACTIONS } from "../../../common/constants/analytics";

interface HistoricalCashFlowChartProps {
  entityId?: string;
  entityType?: string;
  currency?: string;
  dateRange?: DateRangeFormValues;
  setGlobalDateFilterLabel?: () => void;
}

interface HistoricalCashFlowQueryFilter {
  entityId?: string;
  entityType?: string;
  currency: string;
  asOfDate: DateRangeFormValues;
}

export default function HistoricalCashFlowChart({
  entityId,
  entityType,
  currency = "USD",
  dateRange,
  setGlobalDateFilterLabel,
}: HistoricalCashFlowChartProps) {
  const [query, setQuery] = useState<HistoricalCashFlowQueryFilter>({
    asOfDate: dateRange || ACCOUNT_DATE_RANGE_FILTER_OPTIONS[1].dateRange,
    entityId,
    entityType,
    currency,
  });

  const { data, loading, refetch } = useHistoricalCashFlowQuery({
    variables: {
      ...query,
      asOfDate: dateSearchMapper(query.asOfDate),
      currency,
    },
    notifyOnNetworkStatusChange: true,
  });

  const handleRefetch = async (newQuery: HistoricalCashFlowQueryFilter) => {
    setQuery({
      ...newQuery,
      asOfDate: newQuery.asOfDate,
    });
    await refetch({
      ...newQuery,
      asOfDate: dateSearchMapper(newQuery.asOfDate),
    });
  };

  useEffect(() => {
    void handleRefetch({
      ...query,
      currency,
      ...(dateRange && { asOfDate: dateRange }),
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currency, dateRange]);

  const searchComponents = [
    {
      field: "asOfDate",
      query,
      options: ACCOUNT_DATE_RANGE_FILTER_OPTIONS,
      component: DateSearch,
      updateQuery: (input: Record<string, DateRangeFormValues>) => {
        trackEvent(null, ACCOUNT_ACTIONS.CHANGED_WIDGET_DATE_FILTER, {
          widget: "HistoricalCashFlowChart",
        });
        void handleRefetch({ ...query, asOfDate: input.asOfDate, currency });
      },
      setGlobalDateFilterLabel,
      // so cascading date filter label updates when date range changes
      key: v4(),
      autoWidth: true,
      showStartAndEndDateArrow: false,
    },
  ];

  const toChartData = (
    input: HistoricalCashFlowItem[],
  ): HistoricalCashflowChartDataPoint[] =>
    input.map((item: HistoricalCashFlowItem) => {
      const date = moment(item.asOfDate);
      return {
        ...item,
        currency,
        dateShortest: date.format("M/D"),
        dateShort: date.format("MMM D"),
        dateLong: date.format("ddd, MMM D"),
      };
    });
  return (
    <ChartView
      title="Cash Flow"
      searchComponents={searchComponents}
      className="bg-background-default"
      loading={loading}
      childrenContainerClassName="flex flex-grow items-center justify-center"
      hasChartOptions
    >
      {data && data.historicalCashFlow.length > 0 ? (
        <HistoricalCashFlowBarChart
          chartData={toChartData(data.historicalCashFlow)}
        />
      ) : (
        <PlaceholderLineChart content="There is no data in this date range. If
        you believe this is an error, please contact support." />
      )}
    </ChartView>
  );
}
```

---
